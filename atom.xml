<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风骚的Mic</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://istio.tech/"/>
  <updated>2019-08-05T03:14:35.000Z</updated>
  <id>https://istio.tech/</id>
  
  <author>
    <name>Mic</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Alibaba Nacos配置中心服务端处理源码</title>
    <link href="https://istio.tech/2019/08/05/Alibaba-Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81/"/>
    <id>https://istio.tech/2019/08/05/Alibaba-Nacos配置中心服务端处理源码/</id>
    <published>2019-08-05T03:10:00.000Z</published>
    <updated>2019-08-05T03:14:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>服务端收到客户端的配置变更请求查询的长轮训请求之后，服务端怎么来处理这个长轮训呢？</p><a id="more"></a><h1 id="长轮训的时间间隔"><a href="#长轮训的时间间隔" class="headerlink" title="长轮训的时间间隔"></a>长轮训的时间间隔</h1><p>上节课讲到了配置更新的整个原理及源码，我们知道客户端会有一个长轮训的任务去检查服务器端的配置是否发生了变化，如果发生了变更，那么客户端会拿到变更的 groupKey 再根据 groupKey 去获取配置项的最新值更新到本地的缓存以及文件中，那么这种每次都靠客户端去请求，那请求的时间间隔设置多少合适呢？</p><p>如果间隔时间设置的太长的话有可能无法及时获取服务端的变更，如果间隔时间设置的太短的话，那么频繁的请求对于服务端来说无疑也是一种负担，所以最好的方式是客户端每隔一段长度适中的时间去服务端请求，而在这期间如果配置发生变更，服务端能够主动将变更后的结果推送给客户端，这样既能保证客户端能够实时感知到配置的变化，也降低了服务端的压力。 我们来看看nacos设置的间隔时间是多久</p><h2 id="长轮训的概念"><a href="#长轮训的概念" class="headerlink" title="长轮训的概念"></a>长轮训的概念</h2><p>那么在讲解原理之前，先给大家解释一下什么叫长轮训</p><p>客户端发起一个请求到服务端，服务端收到客户端的请求后，并不会立刻响应给客户端，而是先把这个请求hold住，然后服务端会在hold住的这段时间检查数据是否有更新，如果有，则响应给客户端，如果一直没有数据变更，则达到一定的时间（长轮训时间间隔）才返回。</p><p>长轮训典型的场景有： 扫码登录、扫码支付。</p><p><img src="/images/1564895144314.png" alt="1564895144314"></p><h2 id="客户端长轮训"><a href="#客户端长轮训" class="headerlink" title="客户端长轮训"></a>客户端长轮训</h2><p>回到我们昨天上课讲到的代码,在ClientWorker这个类里面，找到<code>checkUpdateConfigStr</code>这个方法，这里面就是去服务器端查询发生变化的groupKey。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;String&gt; <span class="title">checkUpdateConfigStr</span><span class="params">(String probeUpdateString, <span class="keyword">boolean</span> isInitializingCacheList)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; params = Arrays.asList(Constants.PROBE_MODIFY_REQUEST, probeUpdateString);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; headers = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">2</span>);</span><br><span class="line">        headers.add(<span class="string">"Long-Pulling-Timeout"</span>);</span><br><span class="line">        headers.add(<span class="string">""</span> + timeout);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// told server do not hang me up if new initializing cacheData added in</span></span><br><span class="line">        <span class="keyword">if</span> (isInitializingCacheList) &#123;</span><br><span class="line">            headers.add(<span class="string">"Long-Pulling-Timeout-No-Hangup"</span>);</span><br><span class="line">            headers.add(<span class="string">"true"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(probeUpdateString)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HttpResult result = agent.httpPost(Constants.CONFIG_CONTROLLER_PATH + <span class="string">"/listener"</span>, headers, params,</span><br><span class="line">                agent.getEncode(), timeout);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (HttpURLConnection.HTTP_OK == result.code) &#123;</span><br><span class="line">                setHealthServer(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> parseUpdateDataIdResponse(result.content);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                setHealthServer(<span class="keyword">false</span>);</span><br><span class="line">                LOGGER.error(<span class="string">"[&#123;&#125;] [check-update] get changed dataId error, code: &#123;&#125;"</span>, agent.getName(), result.code);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            setHealthServer(<span class="keyword">false</span>);</span><br><span class="line">            LOGGER.error(<span class="string">"["</span> + agent.getName() + <span class="string">"] [check-update] get changed dataId exception"</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个方法最终会发起http请求，注意这里面有一个<code>timeout</code>的属性，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpResult result = agent.httpPost(Constants.CONFIG_CONTROLLER_PATH + <span class="string">"/listener"</span>, headers, params,</span><br><span class="line">                agent.getEncode(), timeout);</span><br></pre></td></tr></table></figure><p>timeout是在init这个方法中赋值的，默认情况下是30秒，可以通过configLongPollTimeout进行修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.timeout = (<span class="keyword">long</span>)Math.max(NumberUtils.toInt(properties.getProperty(<span class="string">"configLongPollTimeout"</span>), <span class="number">30000</span>), <span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">this</span>.taskPenaltyTime = NumberUtils.toInt(properties.getProperty(<span class="string">"configRetryTime"</span>), <span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">this</span>.enableRemoteSyncConfig = Boolean.parseBoolean(properties.getProperty(<span class="string">"enableRemoteSyncConfig"</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所以从这里得出的一个基本结论是</p><blockquote><p>客户端发起一个轮询请求，超时时间是30s。 那么客户端为什么要等待30s才超时呢？不是越快越好吗？</p></blockquote><h2 id="客户端长轮训的时间间隔"><a href="#客户端长轮训的时间间隔" class="headerlink" title="客户端长轮训的时间间隔"></a>客户端长轮训的时间间隔</h2><p>我们可以在nacos的日志目录下<code>$NACOS_HOME/nacos/logs/config-client-request.log</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2019-08-04 13:22:19,736|0|nohangup|127.0.0.1|polling|1|55|0</span><br><span class="line">2019-08-04 13:22:49,443|29504|timeout|127.0.0.1|polling|1|55</span><br><span class="line">2019-08-04 13:23:18,983|29535|timeout|127.0.0.1|polling|1|55</span><br><span class="line">2019-08-04 13:23:48,493|29501|timeout|127.0.0.1|polling|1|55</span><br><span class="line">2019-08-04 13:24:18,003|29500|timeout|127.0.0.1|polling|1|55</span><br><span class="line">2019-08-04 13:24:47,509|29501|timeout|127.0.0.1|polling|1|55</span><br></pre></td></tr></table></figure><p>可以看到一个现象，在配置没有发生变化的情况下，客户端会等29.5s以上，才请求到服务器端的结果。然后客户端拿到服务器端的结果之后，在做后续的操作。</p><p>如果在配置变更的情况下，由于客户端基于长轮训的连接保持，所以返回的时间会非常的短，我们可以做个小实验，在nacos console中频繁修改数据然后再观察一下</p><p><code>config-client-request.log</code>的变化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2019-08-04 13:30:17,016|0|in-advance|127.0.0.1|polling|1|55|example+DEFAULT_GROUP</span><br><span class="line">2019-08-04 13:30:17,022|3|null|127.0.0.1|get|example|DEFAULT_GROUP||e10e4d5973c497e490a8d7a9e4e9be64|unknown</span><br><span class="line">2019-08-04 13:30:20,807|10|true|0:0:0:0:0:0:0:1|publish|example|DEFAULT_GROUP||81360b7e732a5dbb37d62d81cebb85d2|null</span><br><span class="line">2019-08-04 13:30:20,843|0|in-advance|127.0.0.1|polling|1|55|example+DEFAULT_GROUP</span><br><span class="line">2019-08-04 13:30:20,848|1|null|127.0.0.1|get|example|DEFAULT_GROUP||81360b7e732a5dbb37d62d81cebb85d2|unknown</span><br></pre></td></tr></table></figure><p><img src="/images/1564896925676.png" alt="1564896925676"></p><h1 id="服务端的处理"><a href="#服务端的处理" class="headerlink" title="服务端的处理"></a>服务端的处理</h1><p>分析完客户端之后，随着好奇心的驱使，服务端是如何处理客户端的请求的？那么同样，我们需要思考几个问题</p><ul><li>客户端的长轮训响应时间受到哪些因素的影响</li><li>客户端的超时时间为什么要设置30s</li></ul><p>客户端发送的请求地址是:<code>/v1/cs/configs/listener</code> 找到服务端对应的方法</p><h2 id="ConfigController"><a href="#ConfigController" class="headerlink" title="ConfigController"></a>ConfigController</h2><p>nacos是使用spring mvc提供的rest api。这里面会调用inner.doPollingConfig进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/listener"</span>, method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listener</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        request.setAttribute(<span class="string">"org.apache.catalina.ASYNC_SUPPORTED"</span>, <span class="keyword">true</span>);</span><br><span class="line">        String probeModify = request.getParameter(<span class="string">"Listening-Configs"</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(probeModify)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"invalid probeModify"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        probeModify = URLDecoder.decode(probeModify, Constants.ENCODE);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; clientMd5Map;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clientMd5Map = MD5Util.getClientMd5Map(probeModify);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"invalid probeModify"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// do long-polling</span></span><br><span class="line">        inner.doPollingConfig(request, response, clientMd5Map, probeModify.length());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="doPollingConfig"><a href="#doPollingConfig" class="headerlink" title="doPollingConfig"></a>doPollingConfig</h2><p>这个方法中，兼容了长轮训和短轮询的逻辑，我们只需要关注长轮训的部分。再次进入到<code>longPollingService.addLongPollingClient</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">doPollingConfig</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Map&lt;String, String&gt; clientMd5Map, <span class="keyword">int</span> probeRequestSize)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 长轮询</span></span><br><span class="line">        <span class="keyword">if</span> (LongPollingService.isSupportLongPolling(request)) &#123;</span><br><span class="line">            longPollingService.addLongPollingClient(request, response, clientMd5Map, probeRequestSize);</span><br><span class="line">            <span class="keyword">return</span> HttpServletResponse.SC_OK + <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// else 兼容短轮询逻辑</span></span><br><span class="line">        List&lt;String&gt; changedGroups = MD5Util.compareMd5(request, response, clientMd5Map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 兼容短轮询result</span></span><br><span class="line">        String oldResult = MD5Util.compareMd5OldResult(changedGroups);</span><br><span class="line">        String newResult = MD5Util.compareMd5ResultString(changedGroups);</span><br><span class="line"></span><br><span class="line">        String version = request.getHeader(Constants.CLIENT_VERSION_HEADER);</span><br><span class="line">        <span class="keyword">if</span> (version == <span class="keyword">null</span>) &#123;</span><br><span class="line">            version = <span class="string">"2.0.0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> versionNum = Protocol.getVersionNumber(version);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 2.0.4版本以前, 返回值放入header中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (versionNum &lt; START_LONGPOLLING_VERSION_NUM) &#123;</span><br><span class="line">            response.addHeader(Constants.PROBE_MODIFY_RESPONSE, oldResult);</span><br><span class="line">            response.addHeader(Constants.PROBE_MODIFY_RESPONSE_NEW, newResult);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            request.setAttribute(<span class="string">"content"</span>, newResult);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁用缓存</span></span><br><span class="line">        response.setHeader(<span class="string">"Pragma"</span>, <span class="string">"no-cache"</span>);</span><br><span class="line">        response.setDateHeader(<span class="string">"Expires"</span>, <span class="number">0</span>);</span><br><span class="line">        response.setHeader(<span class="string">"Cache-Control"</span>, <span class="string">"no-cache,no-store"</span>);</span><br><span class="line">        response.setStatus(HttpServletResponse.SC_OK);</span><br><span class="line">        <span class="keyword">return</span> HttpServletResponse.SC_OK + <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="longPollingService-addLongPollingClient"><a href="#longPollingService-addLongPollingClient" class="headerlink" title="longPollingService.addLongPollingClient"></a>longPollingService.addLongPollingClient</h2><p>从方法名字上可以推测出，这个方法应该是把客户端的长轮训请求添加到某个任务中去。</p><ul><li>获得客户端传递过来的超时时间，并且进行本地计算，提前500ms返回响应，这就能解释为什么客户端响应超时时间是29.5+了。当然如果<code>isFixedPolling=true</code>的情况下，不会提前返回响应</li><li>根据客户端请求过来的md5和服务器端对应的group下对应内容的md5进行比较，如果不一致，则通过<code>generateResponse</code>将结果返回</li><li>如果配置文件没有发生变化，则通过<code>scheduler.execute</code> 启动了一个定时任务，将客户端的长轮询请求封装成一个叫 ClientLongPolling 的任务，交给 scheduler 去执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLongPollingClient</span><span class="params">(HttpServletRequest req, HttpServletResponse rsp, Map&lt;String, String&gt; clientMd5Map,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">int</span> probeRequestSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//str表示超时时间，也就是timeout</span></span><br><span class="line">        String str = req.getHeader(LongPollingService.LONG_POLLING_HEADER);</span><br><span class="line">        String noHangUpFlag = req.getHeader(LongPollingService.LONG_POLLING_NO_HANG_UP_HEADER);</span><br><span class="line">        String appName = req.getHeader(RequestUtil.CLIENT_APPNAME_HEADER);</span><br><span class="line">        String tag = req.getHeader(<span class="string">"Vipserver-Tag"</span>);</span><br><span class="line">        <span class="keyword">int</span> delayTime = SwitchService.getSwitchInteger(SwitchService.FIXED_DELAY_TIME, <span class="number">500</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 提前500ms返回响应，为避免客户端超时 <span class="doctag">@qiaoyi</span>.dingqy 2013.10.22改动  add delay time for LoadBalance</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">long</span> timeout = Math.max(<span class="number">10000</span>, Long.parseLong(str) - delayTime);</span><br><span class="line">        <span class="keyword">if</span> (isFixedPolling()) &#123;</span><br><span class="line">            timeout = Math.max(<span class="number">10000</span>, getFixedPollingInterval());</span><br><span class="line">            <span class="comment">// do nothing but set fix polling timeout</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            List&lt;String&gt; changedGroups = MD5Util.compareMd5(req, rsp, clientMd5Map);</span><br><span class="line">            <span class="keyword">if</span> (changedGroups.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                generateResponse(req, rsp, changedGroups);</span><br><span class="line">                LogUtil.clientLog.info(<span class="string">"&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;"</span>,</span><br><span class="line">                    System.currentTimeMillis() - start, <span class="string">"instant"</span>, RequestUtil.getRemoteIp(req), <span class="string">"polling"</span>,</span><br><span class="line">                    clientMd5Map.size(), probeRequestSize, changedGroups.size());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (noHangUpFlag != <span class="keyword">null</span> &amp;&amp; noHangUpFlag.equalsIgnoreCase(TRUE_STR)) &#123;</span><br><span class="line">                LogUtil.clientLog.info(<span class="string">"&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;"</span>, System.currentTimeMillis() - start, <span class="string">"nohangup"</span>,</span><br><span class="line">                    RequestUtil.getRemoteIp(req), <span class="string">"polling"</span>, clientMd5Map.size(), probeRequestSize,</span><br><span class="line">                    changedGroups.size());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String ip = RequestUtil.getRemoteIp(req);</span><br><span class="line">        <span class="comment">// 一定要由HTTP线程调用，否则离开后容器会立即发送响应</span></span><br><span class="line">        <span class="keyword">final</span> AsyncContext asyncContext = req.startAsync();</span><br><span class="line">        <span class="comment">// AsyncContext.setTimeout()的超时时间不准，所以只能自己控制</span></span><br><span class="line">        asyncContext.setTimeout(<span class="number">0L</span>);</span><br><span class="line"></span><br><span class="line">        scheduler.execute(</span><br><span class="line">            <span class="keyword">new</span> ClientLongPolling(asyncContext, clientMd5Map, ip, probeRequestSize, timeout, appName, tag));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="ClientLongPolling"><a href="#ClientLongPolling" class="headerlink" title="ClientLongPolling"></a>ClientLongPolling</h2><p>接下来我们来分析一下，clientLongPolling到底做了什么操作。或者说我们可以先猜测一下应该会做什么事情</p><ul><li>这个任务要阻塞29.5s才能执行，因为立马执行没有任何意义，毕竟前面已经执行过一次了</li><li>如果在29.5s+之内，数据发生变化，需要提前通知。需要有一种监控机制</li></ul><p>基于这些猜想，我们可以看看它的实现过程</p><p>从代码粗粒度来看，它的实现似乎和我们的猜想一致，在run方法中，通过scheduler.schedule实现了一个定时任务，它的delay时间正好是前面计算的29.5s。在这个任务中，会通过MD5Util.compareMd5来进行计算</p><p>那另外一个，当数据发生变化以后，肯定不能等到29.5s之后才通知呀，那怎么办呢？我们发现有一个<code>allSubs</code>的东西，它似乎和发布订阅有关系。那是不是有可能当前的clientLongPolling订阅了数据变化的事件呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    asyncTimeoutFuture = scheduler.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                getRetainIps().put(ClientLongPolling.<span class="keyword">this</span>.ip, System.currentTimeMil·<span class="number">1</span>·s());</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 删除订阅关系</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                allSubs.remove(ClientLongPolling.<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isFixedPolling()) &#123;</span><br><span class="line">                    LogUtil.clientLog.info(<span class="string">"&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;"</span>,</span><br><span class="line">                                           (System.currentTimeMillis() - createTime),</span><br><span class="line">                                           <span class="string">"fix"</span>, RequestUtil.getRemoteIp((HttpServletRequest)asyncContext.getRequest()),</span><br><span class="line">                                           <span class="string">"polling"</span>,</span><br><span class="line">                                           clientMd5Map.size(), probeRequestSize);</span><br><span class="line">                    List&lt;String&gt; changedGroups = MD5Util.compareMd5(</span><br><span class="line">                        (HttpServletRequest)asyncContext.getRequest(),</span><br><span class="line">                        (HttpServletResponse)asyncContext.getResponse(), clientMd5Map);</span><br><span class="line">                    <span class="keyword">if</span> (changedGroups.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        sendResponse(changedGroups);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        sendResponse(<span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    LogUtil.clientLog.info(<span class="string">"&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;"</span>,</span><br><span class="line">                                           (System.currentTimeMillis() - createTime),</span><br><span class="line">                                           <span class="string">"timeout"</span>, RequestUtil.getRemoteIp((HttpServletRequest)asyncContext.getRequest()),</span><br><span class="line">                                           <span class="string">"polling"</span>,</span><br><span class="line">                                           clientMd5Map.size(), probeRequestSize);</span><br><span class="line">                    sendResponse(<span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                LogUtil.defaultLog.error(<span class="string">"long polling error:"</span> + t.getMessage(), t.getCause());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;, timeoutTime, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    allSubs.add(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="allSubs"><a href="#allSubs" class="headerlink" title="allSubs"></a>allSubs</h2><p>allSubs是一个队列，队列里面放了ClientLongPolling这个对象。这个队列似乎和配置变更有某种关联关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 长轮询订阅关系</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Queue&lt;ClientLongPolling&gt; allSubs;</span><br><span class="line"></span><br><span class="line">allSubs.add(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>那这个时候，我的第一想法是，先去看一下当前这个类的类图，发现LongPollingService集成了AbstractEventListener，事件监听？果然没猜错。</p><p><img src="/images/1564902541390.png" alt="1564902541390"></p><h2 id="AbstractEventListener"><a href="#AbstractEventListener" class="headerlink" title="AbstractEventListener"></a>AbstractEventListener</h2><p>这里面有一个抽象的onEvent方法，明显是用来处理事件的方法，而抽象方法必须由子类实现，所以意味着LongPollingService里面肯定实现了onEvent方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractEventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AbstractEventListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * automatic register</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            EventDispatcher.addEventListener(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 感兴趣的事件列表</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> event list</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">abstract</span> <span class="keyword">public</span> List&lt;Class&lt;? extends Event&gt;&gt; interest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 处理事件</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> event event</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event event)</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="LongPollingService-onEvent"><a href="#LongPollingService-onEvent" class="headerlink" title="LongPollingService.onEvent"></a>LongPollingService.onEvent</h2><p>这个事件的实现方法中</p><ul><li>判断事件类型是否为LocalDataChangeEvent</li><li>通过scheduler.execute执行DataChangeTask这个任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFixedPolling()) &#123;</span><br><span class="line">            <span class="comment">// ignore</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (event <span class="keyword">instanceof</span> LocalDataChangeEvent) &#123;</span><br><span class="line">                LocalDataChangeEvent evt = (LocalDataChangeEvent)event;</span><br><span class="line">                scheduler.execute(<span class="keyword">new</span> DataChangeTask(evt.groupKey, evt.isBeta, evt.betaIps));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="DataChangeTask-run"><a href="#DataChangeTask-run" class="headerlink" title="DataChangeTask.run"></a>DataChangeTask.run</h2><p>从名字可以看出来，这个是数据变化的任务，最让人兴奋的应该是，它里面有一个循环迭代器，从allSubs里面获得ClientLongPolling</p><p>最后通过clientSub.sendResponse把数据返回到客户端。所以，这也就能够理解为何数据变化能够实时触发更新了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ConfigService.getContentBetaMd5(groupKey);</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;ClientLongPolling&gt; iter = allSubs.iterator(); iter.hasNext(); ) &#123;</span><br><span class="line">            ClientLongPolling clientSub = iter.next();</span><br><span class="line">            <span class="keyword">if</span> (clientSub.clientMd5Map.containsKey(groupKey)) &#123;</span><br><span class="line">                <span class="comment">// 如果beta发布且不在beta列表直接跳过</span></span><br><span class="line">                <span class="keyword">if</span> (isBeta &amp;&amp; !betaIps.contains(clientSub.ip)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果tag发布且不在tag列表直接跳过</span></span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isNotBlank(tag) &amp;&amp; !tag.equals(clientSub.tag)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                getRetainIps().put(clientSub.ip, System.currentTimeMillis());</span><br><span class="line">                iter.remove(); <span class="comment">// 删除订阅关系</span></span><br><span class="line">                LogUtil.clientLog.info(<span class="string">"&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;"</span>,</span><br><span class="line">                                       (System.currentTimeMillis() - changeTime),</span><br><span class="line">                                       <span class="string">"in-advance"</span>,</span><br><span class="line">                                       RequestUtil.getRemoteIp((HttpServletRequest)clientSub.asyncContext.getRequest()),</span><br><span class="line">                                       <span class="string">"polling"</span>,</span><br><span class="line">                                       clientSub.clientMd5Map.size(), clientSub.probeRequestSize, groupKey);</span><br><span class="line">                clientSub.sendResponse(Arrays.asList(groupKey));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        LogUtil.defaultLog.error(<span class="string">"data change error:"</span> + t.getMessage(), t.getCause());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么接下来还有一个疑问是，数据变化之后是如何触发事件的呢？ 所以我们定位到数据变化的请求类中，在ConfigController这个类中，找到POST请求的方法</p><p>找到配置变更的位置， 发现数据持久化之后，会通过EventDispatcher进行事件发布<code>EventDispatcher.fireEvent</code> 但是这个事件似乎不是我们所关心的时间，原因是这里发布的事件是<code>ConfigDataChangeEvent</code>, 而LongPollingService感兴趣的事件是<code>LocalDataChangeEvent</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(method = RequestMethod.POST)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">publishConfig</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        <span class="comment">//省略部分代码</span></span><br><span class="line">        ConfigInfo configInfo = <span class="keyword">new</span> ConfigInfo(dataId, group, tenant, appName, content);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(betaIps)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(tag)) &#123;</span><br><span class="line">                persistService.insertOrUpdate(srcIp, srcUser, configInfo, time, configAdvanceInfo, <span class="keyword">false</span>);</span><br><span class="line">                EventDispatcher.fireEvent(<span class="keyword">new</span> ConfigDataChangeEvent(<span class="keyword">false</span>, dataId, group, tenant, time.getTime()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                persistService.insertOrUpdateTag(configInfo, tag, srcIp, srcUser, time, <span class="keyword">false</span>);</span><br><span class="line">                EventDispatcher.fireEvent(<span class="keyword">new</span> ConfigDataChangeEvent(<span class="keyword">false</span>, dataId, group, tenant, tag, time.getTime()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// beta publish</span></span><br><span class="line">            persistService.insertOrUpdateBeta(configInfo, betaIps, srcIp, srcUser, time, <span class="keyword">false</span>);</span><br><span class="line">            EventDispatcher.fireEvent(<span class="keyword">new</span> ConfigDataChangeEvent(<span class="keyword">true</span>, dataId, group, tenant, time.getTime()));</span><br><span class="line">        &#125;</span><br><span class="line">        ConfigTraceService.logPersistenceEvent(dataId, group, tenant, requestIpApp, time.getTime(),</span><br><span class="line">            LOCAL_IP, ConfigTraceService.PERSISTENCE_EVENT_PUB, content);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>后来我发现，在Nacos中有一个DumpService，它会定时把变更后的数据dump到磁盘上，DumpService在spring启动之后，会调用init方法启动几个dump任务。然后在任务执行结束之后，会触发一个LocalDataChangeEvent 的事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LogUtil.defaultLog.warn(<span class="string">"DumpService start"</span>);</span><br><span class="line">        DumpProcessor processor = <span class="keyword">new</span> DumpProcessor(<span class="keyword">this</span>);</span><br><span class="line">        DumpAllProcessor dumpAllProcessor = <span class="keyword">new</span> DumpAllProcessor(<span class="keyword">this</span>);</span><br><span class="line">        DumpAllBetaProcessor dumpAllBetaProcessor = <span class="keyword">new</span> DumpAllBetaProcessor(<span class="keyword">this</span>);</span><br><span class="line">        DumpAllTagProcessor dumpAllTagProcessor = <span class="keyword">new</span> DumpAllTagProcessor(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>简单总结一下刚刚分析的整个过程。</p><ul><li>客户端发起长轮训请求</li><li>服务端收到请求以后，先比较服务端缓存中的数据是否相同，如果不通，则直接返回</li><li>如果相同，则通过schedule延迟29.5s之后再执行比较</li><li>为了保证当服务端在29.5s之内发生数据变化能够及时通知给客户端，服务端采用事件订阅的方式来监听服务端本地数据变化的事件，一旦收到事件，则触发DataChangeTask的通知，并且遍历allStubs队列中的ClientLongPolling,把结果写回到客户端，就完成了一次数据的推送</li><li>如果 DataChangeTask 任务完成了数据的 “推送” 之后，ClientLongPolling 中的调度任务又开始执行了怎么办呢？<br>很简单，只要在进行 “推送” 操作之前，先将原来等待执行的调度任务取消掉就可以了，这样就防止了推送操作写完响应数据之后，调度任务又去写响应数据，这时肯定会报错的。所以，在ClientLongPolling方法中，最开始的一个步骤就是删除订阅事件</li></ul><p>所以总的来说，Nacos采用推+拉的形式，来解决最开始关于长轮训时间间隔的问题。当然，30s这个时间是可以设置的，而之所以定30s，应该是一个经验值。</p><h1 id="集群选举问题"><a href="#集群选举问题" class="headerlink" title="集群选举问题"></a>集群选举问题</h1><p>Nacos支持集群模式，很显然。 </p><p>而一旦涉及到集群，就涉及到主从，那么nacos是一种什么样的机制来实现的集群呢？</p><p>nacos的集群类似于zookeeper， 它分为leader角色和follower角色， 那么从这个角色的名字可以看出来，这个集群存在选举的机制。 因为如果自己不具备选举功能，角色的命名可能就是master/slave了，当然这只是我基于这么多组件的命名的一个猜测</p><h2 id="选举算法"><a href="#选举算法" class="headerlink" title="选举算法"></a>选举算法</h2><p>Nacos集群采用raft算法来实现，它是相对zookeeper的选举算法较为简单的一种。 </p><p>选举算法的核心在<code>RaftCore</code>  中，包括数据的处理和数据同步</p><p><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">raft算法演示地址</a></p><p>在Raft中，节点有三种角色：</p><ul><li>Leader：负责接收客户端的请求</li><li>Candidate：用于选举Leader的一种角色</li><li>Follower：负责响应来自Leader或者Candidate的请求</li></ul><p>选举分为两个节点</p><ul><li>服务启动的时候</li><li>leader挂了的时候</li></ul><p>所有节点启动的时候，都是follower状态。 如果在一段时间内如果没有收到leader的心跳（可能是没有leader，也可能是leader挂了），那么follower会变成Candidate。然后发起选举，选举之前，会增加term，这个term和zookeeper中的epoch的道理是一样的。</p><ul><li>follower会投自己一票，并且给其他节点发送票据vote，等到其他节点回复</li><li>在这个过程中，可能出现几种情况<ul><li>收到过半的票数通过，则成为leader</li><li>被告知其他节点已经成为leader，则自己切换为follower</li><li>一段时间内没有收到过半的投票，则重新发起选举</li></ul></li><li><strong>约束条件在任一term中，单个节点最多只能投一票</strong></li></ul><p>选举的几种情况</p><ul><li>第一种情况，赢得选举之后，leader会给所有节点发送消息，避免其他节点触发新的选举</li><li>第二种情况，比如有三个节点A B C。A B同时发起选举，而A的选举消息先到达C，C给A投了一票，当B的消息到达C时，已经不能满足上面提到的第一个约束，即C不会给B投票，而A和B显然都不会给对方投票。A胜出之后，会给B,C发心跳消息，节点B发现节点A的term不低于自己的term，知道有已经有Leader了，于是转换成follower</li><li>第三种情况， 没有任何节点获得majority投票，可能是平票的情况。加入总共有四个节点（A/B/C/D），Node C、Node D同时成为了candidate，但Node A投了NodeD一票，NodeB投了Node C一票，这就出现了平票 split vote的情况。这个时候大家都在等啊等，直到超时后重新发起选举。如果出现平票的情况，那么就延长了系统不可用的时间,因此raft引入了randomized election timeouts来尽量避免平票情况</li></ul><h2 id="数据的处理"><a href="#数据的处理" class="headerlink" title="数据的处理"></a>数据的处理</h2><p>对于事务操作，请求会转发给leader</p><p>非事务操作上，可以任意一个节点来处理</p><p>下面这段代码摘自 RaftCore ， 在发布内容的时候，做了两个事情</p><ul><li>如果当前的节点不是leader，则转发给leader节点处理</li><li>如果是，则向所有节点发送onPublish</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signalPublish</span><span class="params">(String key, Record value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isLeader()) &#123;</span><br><span class="line">            JSONObject params = <span class="keyword">new</span> JSONObject();</span><br><span class="line">            params.put(<span class="string">"key"</span>, key);</span><br><span class="line">            params.put(<span class="string">"value"</span>, value);</span><br><span class="line">            Map&lt;String, String&gt; parameters = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">            parameters.put(<span class="string">"key"</span>, key);</span><br><span class="line"></span><br><span class="line">            raftProxy.proxyPostLarge(getLeader().ip, API_PUB, params.toJSONString(), parameters);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            OPERATE_LOCK.lock();</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">final</span> Datum datum = <span class="keyword">new</span> Datum();</span><br><span class="line">            datum.key = key;</span><br><span class="line">            datum.value = value;</span><br><span class="line">            <span class="keyword">if</span> (getDatum(key) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                datum.timestamp.set(<span class="number">1L</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                datum.timestamp.set(getDatum(key).timestamp.incrementAndGet());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            JSONObject json = <span class="keyword">new</span> JSONObject();</span><br><span class="line">            json.put(<span class="string">"datum"</span>, datum);</span><br><span class="line">            json.put(<span class="string">"source"</span>, peers.local());</span><br><span class="line"></span><br><span class="line">            onPublish(datum, peers.local());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> String content = JSON.toJSONString(json);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(peers.majorityCount());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">final</span> String server : peers.allServersIncludeMyself()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isLeader(server)) &#123;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">final</span> String url = buildURL(server, API_ON_PUB);</span><br><span class="line">                HttpClient.asyncHttpPostLarge(url, Arrays.asList(<span class="string">"key="</span> + key), content, <span class="keyword">new</span> AsyncCompletionHandler&lt;Integer&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Integer <span class="title">onCompleted</span><span class="params">(Response response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (response.getStatusCode() != HttpURLConnection.HTTP_OK) &#123;</span><br><span class="line">                            Loggers.RAFT.warn(<span class="string">"[RAFT] failed to publish data to peer, datumId=&#123;&#125;, peer=&#123;&#125;, http code=&#123;&#125;"</span>,</span><br><span class="line">                                datum.key, server, response.getStatusCode());</span><br><span class="line">                            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        latch.countDown();</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> STATE <span class="title">onContentWriteCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> STATE.CONTINUE;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!latch.await(UtilsAndCommons.RAFT_PUBLISH_TIMEOUT, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                <span class="comment">// only majority servers return success can we consider this update success</span></span><br><span class="line">                Loggers.RAFT.error(<span class="string">"data publish failed, caused failed to notify majority, key=&#123;&#125;"</span>, key);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"data publish failed, caused failed to notify majority, key="</span> + key);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">            Loggers.RAFT.info(<span class="string">"signalPublish cost &#123;&#125; ms, key: &#123;&#125;"</span>, (end - start), key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            OPERATE_LOCK.unlock();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p># </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;服务端收到客户端的配置变更请求查询的长轮训请求之后，服务端怎么来处理这个长轮训呢？&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="https://istio.tech/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Nacos" scheme="https://istio.tech/tags/Nacos/"/>
    
      <category term="源码分析" scheme="https://istio.tech/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Alibaba Nacos配置中心的源码分析</title>
    <link href="https://istio.tech/2019/08/05/Alibaba-Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://istio.tech/2019/08/05/Alibaba-Nacos配置中心的源码分析/</id>
    <published>2019-08-05T03:09:00.000Z</published>
    <updated>2019-08-05T03:10:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>从源码层面揭秘Nacos如何实现配置中心的</p><a id="more"></a><h1 id="Nacos配置中心的原理分析"><a href="#Nacos配置中心的原理分析" class="headerlink" title="Nacos配置中心的原理分析"></a>Nacos配置中心的原理分析</h1><p>在前面的演示案例中，我们是基于springboot整合之后的方法，使得我们在操作的时候显得很简单，为了一探nacos的实现原理，我们基于Nacos的sdk来实现配置中心的访问</p><h2 id="SDK方式读取和保存配置"><a href="#SDK方式读取和保存配置" class="headerlink" title="SDK方式读取和保存配置"></a>SDK方式读取和保存配置</h2><p>Nacos提供了两种方式，一种是原生的SDK，另一种是open api. </p><p>sdk的文档，请<a href="https://nacos.io/zh-cn/docs/sdk.html" target="_blank" rel="noopener">点击这里</a></p><h3 id="引入依赖包"><a href="#引入依赖包" class="headerlink" title="引入依赖包"></a>引入依赖包</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;nacos-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="实现配置的写入和读取"><a href="#实现配置的写入和读取" class="headerlink" title="实现配置的写入和读取"></a>实现配置的写入和读取</h3><ul><li>使用NacosFactory构建ConfigService</li><li>通过getConfig来获得配置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String serverAddr=<span class="string">"localhost:8848"</span>;</span><br><span class="line">    String dataId=<span class="string">"example"</span>;</span><br><span class="line">    String groupId=<span class="string">"example_group"</span>;</span><br><span class="line">    Properties properties=<span class="keyword">new</span> Properties();</span><br><span class="line">    properties.put(<span class="string">"serverAddr"</span>,serverAddr);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//通过nacosfactory创建一个配置中心的服务</span></span><br><span class="line">        ConfigService configService=NacosFactory.createConfigService(properties);</span><br><span class="line">        <span class="comment">// 5000表示读取配置的超时时间,如果超时或者出现网络故障，会抛出NacosException的异常</span></span><br><span class="line">        String content=configService.getConfig(dataId,groupId,<span class="number">3000</span>);</span><br><span class="line">        System.out.println(content);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现配置的监听"><a href="#实现配置的监听" class="headerlink" title="实现配置的监听"></a>实现配置的监听</h3><p>上面这种形式是纯静态的方式读取，不能动态感知到配置的变化，我们可以添加一个监听器。一旦配置发生变化，则会调用监听器的回调函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">configService.addListener(dataId, groupId, <span class="keyword">new</span> Listener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Executor <span class="title">getExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveConfigInfo</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"receive config:"</span>+s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><blockquote><p>演示： 在nacos控制台修改配置，会触发监听。</p></blockquote><h2 id="配置中心的实现原理猜想"><a href="#配置中心的实现原理猜想" class="headerlink" title="配置中心的实现原理猜想"></a>配置中心的实现原理猜想</h2><p>接下来我们去了解nacos实现配置中心的原理之前，我们先思考一个问题，如果我们需要实现一个配置中心，需要考虑到哪些问题，或者需要满足哪些条件</p><ul><li>服务器-配置持久化存储</li><li>客户端远程访问服务端的数据</li><li>客户端本地缓存配置信息</li><li>客户端如何与服务器端进行数据交互？ &lt;服务端推数据给客户端；客户端从服务端拉数据&gt;</li></ul><blockquote><p>客户端拉取服务端的数据与服务端推送数据给客户端相比，优势在哪呢，为什么 Nacos 不设计成主动推送数据，而是要客户端去拉取呢？如果用推的方式，服务端需要维持与客户端的长连接，这样的话需要耗费大量的资源，并且还需要考虑连接的有效性，例如需要通过心跳来维持两者之间的连接。而用拉的方式，客户端只需要通过一个无状态的 http 请求即可获取到服务端的数据。</p></blockquote><h2 id="简单分析Nacos的源码"><a href="#简单分析Nacos的源码" class="headerlink" title="简单分析Nacos的源码"></a>简单分析Nacos的源码</h2><p>基于前面的猜想，我们来看看Nacos的实现是否和我们猜想的一致</p><h3 id="NacosFactory-createConfigService"><a href="#NacosFactory-createConfigService" class="headerlink" title="NacosFactory.createConfigService"></a>NacosFactory.createConfigService</h3><p>创建一个ConfigService，通过源码可以看到，本质上是通过反射实例化了一个NacosConfigService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigService <span class="title">createConfigService</span><span class="params">(Properties properties)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ConfigFactory.createConfigService(properties);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigService <span class="title">createConfigService</span><span class="params">(Properties properties)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt; driverImplClass = Class.forName(<span class="string">"com.alibaba.nacos.client.config.NacosConfigService"</span>);</span><br><span class="line">        Constructor constructor = driverImplClass.getConstructor(Properties.class);</span><br><span class="line">        ConfigService vendorImpl = (ConfigService) constructor.newInstance(properties);</span><br><span class="line">        <span class="keyword">return</span> vendorImpl;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NacosException(NacosException.CLIENT_INVALID_PARAM, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NacosConfigService"><a href="#NacosConfigService" class="headerlink" title="NacosConfigService"></a>NacosConfigService</h3><p>通过NacosConfigService的构造方法，可以看到它主要会做几个事情</p><ul><li>初始化一个HttpAgent，这里又用到了装饰起模式，实际工作的类是ServerHttpAgent, MetricsHttpAgent内部也是调用了ServerHttpAgent的方法，增加了监控统计的信息</li><li>ClientWorker， 客户端的一个工作累，agent作为参数传入到clientworker，可以基本猜测到里面会用到agent做一些远程相关的事情</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NacosConfigService</span><span class="params">(Properties properties)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        <span class="comment">//省略部分代码</span></span><br><span class="line">        agent = <span class="keyword">new</span> MetricsHttpAgent(<span class="keyword">new</span> ServerHttpAgent(properties));</span><br><span class="line">        agent.start();</span><br><span class="line">        worker = <span class="keyword">new</span> ClientWorker(agent, configFilterChainManager, properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ClientWorker"><a href="#ClientWorker" class="headerlink" title="ClientWorker"></a>ClientWorker</h3><p>可以看到 ClientWorker 除了将 HttpAgent 维持在自己内部，还创建了两个线程池：</p><p>第一个线程池是只拥有一个线程用来执行定时任务的 executor，executor 每隔 10ms 就会执行一次 checkConfigInfo() 方法，从方法名上可以知道是每 10 ms 检查一次配置信息。</p><p>第二个线程池是一个普通的线程池，从 ThreadFactory 的名称可以看到这个线程池是做长轮询的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClientWorker</span><span class="params">(<span class="keyword">final</span> HttpAgent agent, <span class="keyword">final</span> ConfigFilterChainManager configFilterChainManager, <span class="keyword">final</span> Properties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.agent = agent;</span><br><span class="line">        <span class="keyword">this</span>.configFilterChainManager = configFilterChainManager;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize the timeout parameter</span></span><br><span class="line"></span><br><span class="line">        init(properties);</span><br><span class="line">       <span class="comment">//初始化一个定时调度的线程池，重写了threadfactory方法</span></span><br><span class="line">        executor = Executors.newScheduledThreadPool(<span class="number">1</span>, <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">                t.setName(<span class="string">"com.alibaba.nacos.client.Worker."</span> + agent.getName());</span><br><span class="line">                t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//初始化一个定时调度的线程池，从里面的name名字来看，似乎和长轮训有关系。而这个长轮训应该是和nacos服务端的长轮训</span></span><br><span class="line">        executorService = Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors(), <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">                t.setName(<span class="string">"com.alibaba.nacos.client.Worker.longPolling."</span> + agent.getName());</span><br><span class="line">                t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//设置定时任务的执行频率，并且调用checkConfigInfo这个方法，猜测是定时去检测配置是否发生了变化</span></span><br><span class="line">        <span class="comment">//首次执行延迟时间为1毫秒、延迟时间为10毫秒</span></span><br><span class="line">        executor.scheduleWithFixedDelay(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    checkConfigInfo();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    LOGGER.error(<span class="string">"["</span> + agent.getName() + <span class="string">"] [sub-check] rotate check error"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1L</span>, <span class="number">10L</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="checkConfigInfo"><a href="#checkConfigInfo" class="headerlink" title="checkConfigInfo"></a>checkConfigInfo</h3><p>接着，我们顺着初始化的代码，继续往下看.</p><p>这个方法主要的目的是用来检查服务端的配置信息是否发生了变化。如果有变化，则触发listener通知</p><p><strong>cacheMap</strong>: AtomicReference&lt;Map&lt;String, CacheData&gt;&gt; cacheMap  用来存储监听变更的缓存集合。key是根据dataID/group/tenant(租户) 拼接的值。Value是对应存储在nacos服务器上的配置文件的内容。</p><p>默认情况下，每个长轮训LongPullingRunnable任务默认处理3000个监听配置集。如果超过3000， 则需要启动多个LongPollingRunnable去执行。</p><p>currentLongingTaskCount保存已启动的LongPullingRunnable任务数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkConfigInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 分任务</span></span><br><span class="line">        <span class="keyword">int</span> listenerSize = cacheMap.get().size();</span><br><span class="line">        <span class="comment">// 向上取整为批数，监听的配置数量除以3000，得到一个整数，代表长轮训任务的数量</span></span><br><span class="line">        <span class="keyword">int</span> longingTaskCount = (<span class="keyword">int</span>) Math.ceil(listenerSize / ParamUtil.getPerTaskConfigSize());</span><br><span class="line">        <span class="comment">//currentLongingTaskCount表示当前的长轮训任务数量，如果小于计算的结果，则可以继续创建</span></span><br><span class="line">        <span class="keyword">if</span> (longingTaskCount &gt; currentLongingTaskCount) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="keyword">int</span>) currentLongingTaskCount; i &lt; longingTaskCount; i++) &#123;</span><br><span class="line">                <span class="comment">// 要判断任务是否在执行 这块需要好好想想。 任务列表现在是无序的。变化过程可能有问题</span></span><br><span class="line">                executorService.execute(<span class="keyword">new</span> LongPollingRunnable(i));</span><br><span class="line">            &#125;</span><br><span class="line">            currentLongingTaskCount = longingTaskCount; <span class="comment">//更新当前长轮训人数数量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="LongPollingRunnable-run"><a href="#LongPollingRunnable-run" class="headerlink" title="LongPollingRunnable.run"></a>LongPollingRunnable.run</h3><p>初始化new LongPollingRunnable()丢给 executorService线程池来处理，所以我们可以找到LongPollingRunnable里面的run方法</p><p>这个方法传递了一个taskid， tasked用来区分cacheMap中的任务批次, 保存到cacheDatas这个集合中</p><p><code>cacheData.isUseLocalConfigInfo</code>  这个值的变化来自于checkLocalConfig这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;CacheData&gt; cacheDatas = <span class="keyword">new</span> ArrayList&lt;CacheData&gt;();</span><br><span class="line">    List&lt;String&gt; inInitializingCacheList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// check failover config</span></span><br><span class="line">        <span class="keyword">for</span> (CacheData cacheData : cacheMap.get().values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cacheData.getTaskId() == taskId) &#123; <span class="comment">//对cacheMap中的数据进行分批</span></span><br><span class="line">                cacheDatas.add(cacheData);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    checkLocalConfig(cacheData); <span class="comment">//通过本地文件中缓存的数据和cacheData集合中的数据进行比对，判断是否出现数据变化</span></span><br><span class="line">                    <span class="keyword">if</span> (cacheData.isUseLocalConfigInfo()) &#123;<span class="comment">//这里表示数据有变化，需要通知监听器</span></span><br><span class="line">                        cacheData.checkListenerMd5();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    LOGGER.error(<span class="string">"get local config info error"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//省略部分代码</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="checkLocalConfig"><a href="#checkLocalConfig" class="headerlink" title="checkLocalConfig"></a>checkLocalConfig</h4><p>检查本地配置，这里面有三种情况</p><ul><li>如果isUseLocalConfigInfo为false，但是本地缓存路径的文件是存在的，那么把isUseLocalConfigInfo设置为true，并且更新cacheData的内容以及文件的更新时间</li><li>如果isUseLocalCOnfigInfo为true，但是本地缓存文件不存在，则设置为false，不通知监听器</li><li>isUseLocalConfigInfo为true，并且本地缓存文件也存在，但是缓存的的时间和文件的更新时间不一致，则更新cacheData中的内容，并且isUseLocalConfigInfo设置为true</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkLocalConfig</span><span class="params">(CacheData cacheData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String dataId = cacheData.dataId;</span><br><span class="line">        <span class="keyword">final</span> String group = cacheData.group;</span><br><span class="line">        <span class="keyword">final</span> String tenant = cacheData.tenant;</span><br><span class="line">        File path = LocalConfigInfoProcessor.getFailoverFile(agent.getName(), dataId, group, tenant);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有 -&gt; 有</span></span><br><span class="line">        <span class="comment">//本地缓存文件存在，并且isUseLocalConfigInfo为false</span></span><br><span class="line">        <span class="keyword">if</span> (!cacheData.isUseLocalConfigInfo() &amp;&amp; path.exists()) &#123;</span><br><span class="line">            <span class="comment">//更新cacheData中的值</span></span><br><span class="line">            String content = LocalConfigInfoProcessor.getFailover(agent.getName(), dataId, group, tenant);</span><br><span class="line">            String md5 = MD5.getInstance().getMD5String(content);</span><br><span class="line">            cacheData.setUseLocalConfigInfo(<span class="keyword">true</span>);</span><br><span class="line">            cacheData.setLocalConfigInfoVersion(path.lastModified());</span><br><span class="line">            cacheData.setContent(content);</span><br><span class="line">  </span><br><span class="line">            LOGGER.warn(<span class="string">"[&#123;&#125;] [failover-change] failover file created. dataId=&#123;&#125;, group=&#123;&#125;, tenant=&#123;&#125;, md5=&#123;&#125;, content=&#123;&#125;"</span>,</span><br><span class="line">                agent.getName(), dataId, group, tenant, md5, ContentUtils.truncateContent(content));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有 -&gt; 没有。不通知业务监听器，从server拿到配置后通知。</span></span><br><span class="line">        <span class="keyword">if</span> (cacheData.isUseLocalConfigInfo() &amp;&amp; !path.exists()) &#123;</span><br><span class="line">            cacheData.setUseLocalConfigInfo(<span class="keyword">false</span>);</span><br><span class="line">            LOGGER.warn(<span class="string">"[&#123;&#125;] [failover-change] failover file deleted. dataId=&#123;&#125;, group=&#123;&#125;, tenant=&#123;&#125;"</span>, agent.getName(),</span><br><span class="line">                dataId, group, tenant);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有变更</span></span><br><span class="line">        <span class="keyword">if</span> (cacheData.isUseLocalConfigInfo() &amp;&amp; path.exists()</span><br><span class="line">            &amp;&amp; cacheData.getLocalConfigInfoVersion() != path.lastModified()) &#123;</span><br><span class="line">            String content = LocalConfigInfoProcessor.getFailover(agent.getName(), dataId, group, tenant);</span><br><span class="line">            String md5 = MD5.getInstance().getMD5String(content);</span><br><span class="line">            cacheData.setUseLocalConfigInfo(<span class="keyword">true</span>);</span><br><span class="line">            cacheData.setLocalConfigInfoVersion(path.lastModified());</span><br><span class="line">            cacheData.setContent(content);</span><br><span class="line">            LOGGER.warn(<span class="string">"[&#123;&#125;] [failover-change] failover file changed. dataId=&#123;&#125;, group=&#123;&#125;, tenant=&#123;&#125;, md5=&#123;&#125;, content=&#123;&#125;"</span>,</span><br><span class="line">                agent.getName(), dataId, group, tenant, md5, ContentUtils.truncateContent(content));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="checkListenerMd5"><a href="#checkListenerMd5" class="headerlink" title="checkListenerMd5"></a>checkListenerMd5</h4><p>遍历用户自己添加的监听器，如果发现数据的md5值不同，则发送通知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkListenerMd5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ManagerListenerWrap wrap : listeners) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!md5.equals(wrap.lastCallMd5)) &#123;</span><br><span class="line">                safeNotifyListener(dataId, group, content, md5, wrap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="检查服务端配置"><a href="#检查服务端配置" class="headerlink" title="检查服务端配置"></a>检查服务端配置</h3><p>在LongPollingRunnable.run中，先通过本地配置的读取和检查来判断数据是否发生变化从而实现变化的通知</p><p>接着，当前的线程还需要去远程服务器上获得最新的数据，检查哪些数据发生了变化</p><ul><li>通过checkUpdateDataIds获取远程服务器上数据变更的dataid</li><li>遍历这些变化的集合，然后调用getServerConfig从远程服务器获得对应的内容</li><li>更新本地的cache，设置为服务器端返回的内容</li><li>最后遍历cacheDatas，找到变化的数据进行通知</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check server config</span></span><br><span class="line"><span class="comment">//从服务端获取发生变化的数据的DataID列表，保存在List&lt;String&gt;集合中</span></span><br><span class="line">List&lt;String&gt; changedGroupKeys = checkUpdateDataIds(cacheDatas, inInitializingCacheList);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String groupKey : changedGroupKeys) &#123;</span><br><span class="line">    String[] key = GroupKey.parseKey(groupKey);</span><br><span class="line">    String dataId = key[<span class="number">0</span>];</span><br><span class="line">    String group = key[<span class="number">1</span>];</span><br><span class="line">    String tenant = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (key.length == <span class="number">3</span>) &#123;</span><br><span class="line">        tenant = key[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String content = getServerConfig(dataId, group, tenant, <span class="number">3000L</span>);</span><br><span class="line">        CacheData cache = cacheMap.get().get(GroupKey.getKeyTenant(dataId, group, tenant));</span><br><span class="line">        cache.setContent(content);</span><br><span class="line">        LOGGER.info(<span class="string">"[&#123;&#125;] [data-received] dataId=&#123;&#125;, group=&#123;&#125;, tenant=&#123;&#125;, md5=&#123;&#125;, content=&#123;&#125;"</span>,</span><br><span class="line">                    agent.getName(), dataId, group, tenant, cache.getMd5(),</span><br><span class="line">                    ContentUtils.truncateContent(content));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NacosException ioe) &#123;</span><br><span class="line">        String message = String.format(</span><br><span class="line">            <span class="string">"[%s] [get-update] get changed config exception. dataId=%s, group=%s, tenant=%s"</span>,</span><br><span class="line">            agent.getName(), dataId, group, tenant);</span><br><span class="line">        LOGGER.error(message, ioe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (CacheData cacheData : cacheDatas) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cacheData.isInitializing() || inInitializingCacheList</span><br><span class="line">        .contains(GroupKey.getKeyTenant(cacheData.dataId, cacheData.group, cacheData.tenant))) &#123;</span><br><span class="line">        cacheData.checkListenerMd5();</span><br><span class="line">        cacheData.setInitializing(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">inInitializingCacheList.clear();</span><br><span class="line"></span><br><span class="line">executorService.execute(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><h4 id="checkUpdateDataIds"><a href="#checkUpdateDataIds" class="headerlink" title="checkUpdateDataIds"></a>checkUpdateDataIds</h4><ul><li>首先从cacheDatas集合中找到isUseLocalConfigInfo为false的缓存</li><li>调用checkUpdateConfigStr</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;String&gt; <span class="title">checkUpdateDataIds</span><span class="params">(List&lt;CacheData&gt; cacheDatas, List&lt;String&gt; inInitializingCacheList)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (CacheData cacheData : cacheDatas) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cacheData.isUseLocalConfigInfo()) &#123;</span><br><span class="line">                sb.append(cacheData.dataId).append(WORD_SEPARATOR);</span><br><span class="line">                sb.append(cacheData.group).append(WORD_SEPARATOR);</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isBlank(cacheData.tenant)) &#123;</span><br><span class="line">                    sb.append(cacheData.getMd5()).append(LINE_SEPARATOR);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sb.append(cacheData.getMd5()).append(WORD_SEPARATOR);</span><br><span class="line">                    sb.append(cacheData.getTenant()).append(LINE_SEPARATOR);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cacheData.isInitializing()) &#123;</span><br><span class="line">                    <span class="comment">// cacheData 首次出现在cacheMap中&amp;首次check更新</span></span><br><span class="line">                    inInitializingCacheList</span><br><span class="line">                        .add(GroupKey.getKeyTenant(cacheData.dataId, cacheData.group, cacheData.tenant));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> isInitializingCacheList = !inInitializingCacheList.isEmpty();</span><br><span class="line">        <span class="keyword">return</span> checkUpdateConfigStr(sb.toString(), isInitializingCacheList);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过长轮训的方式，从远程服务器获得变化的数据进行返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;String&gt; <span class="title">checkUpdateConfigStr</span><span class="params">(String probeUpdateString, <span class="keyword">boolean</span> isInitializingCacheList)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; params = Arrays.asList(Constants.PROBE_MODIFY_REQUEST, probeUpdateString);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; headers = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">2</span>);</span><br><span class="line">        headers.add(<span class="string">"Long-Pulling-Timeout"</span>);</span><br><span class="line">        headers.add(<span class="string">""</span> + timeout);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// told server do not hang me up if new initializing cacheData added in</span></span><br><span class="line">        <span class="keyword">if</span> (isInitializingCacheList) &#123;</span><br><span class="line">            headers.add(<span class="string">"Long-Pulling-Timeout-No-Hangup"</span>);</span><br><span class="line">            headers.add(<span class="string">"true"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(probeUpdateString)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HttpResult result = agent.httpPost(Constants.CONFIG_CONTROLLER_PATH + <span class="string">"/listener"</span>, headers, params,</span><br><span class="line">                agent.getEncode(), timeout);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (HttpURLConnection.HTTP_OK == result.code) &#123;</span><br><span class="line">                setHealthServer(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> parseUpdateDataIdResponse(result.content);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                setHealthServer(<span class="keyword">false</span>);</span><br><span class="line">                LOGGER.error(<span class="string">"[&#123;&#125;] [check-update] get changed dataId error, code: &#123;&#125;"</span>, agent.getName(), result.code);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            setHealthServer(<span class="keyword">false</span>);</span><br><span class="line">            LOGGER.error(<span class="string">"["</span> + agent.getName() + <span class="string">"] [check-update] get changed dataId exception"</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="getServerConfig"><a href="#getServerConfig" class="headerlink" title="getServerConfig"></a>getServerConfig</h4><p>根据dataId、group、tenant等信息，使用http请求从远程服务器上获得配置信息，读取到数据之后缓存到本地文件中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getServerConfig</span><span class="params">(String dataId, String group, String tenant, <span class="keyword">long</span> readTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(group)) &#123;</span><br><span class="line">            group = Constants.DEFAULT_GROUP;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HttpResult result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; params = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(tenant)) &#123;</span><br><span class="line">                params = Arrays.asList(<span class="string">"dataId"</span>, dataId, <span class="string">"group"</span>, group);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                params = Arrays.asList(<span class="string">"dataId"</span>, dataId, <span class="string">"group"</span>, group, <span class="string">"tenant"</span>, tenant);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//发起http请求</span></span><br><span class="line">            result = agent.httpGet(Constants.CONFIG_CONTROLLER_PATH, <span class="keyword">null</span>, params, agent.getEncode(), readTimeout);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            String message = String.format(</span><br><span class="line">                <span class="string">"[%s] [sub-server] get server config exception, dataId=%s, group=%s, tenant=%s"</span>, agent.getName(),</span><br><span class="line">                dataId, group, tenant);</span><br><span class="line">            LOGGER.error(message, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NacosException(NacosException.SERVER_ERROR, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断返回的code，进行对应的处理</span></span><br><span class="line">        <span class="keyword">switch</span> (result.code) &#123;</span><br><span class="line">            <span class="keyword">case</span> HttpURLConnection.HTTP_OK:</span><br><span class="line">                LocalConfigInfoProcessor.saveSnapshot(agent.getName(), dataId, group, tenant, result.content);</span><br><span class="line">                <span class="keyword">return</span> result.content;</span><br><span class="line">            <span class="keyword">case</span> HttpURLConnection.HTTP_NOT_FOUND:</span><br><span class="line">                LocalConfigInfoProcessor.saveSnapshot(agent.getName(), dataId, group, tenant, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">case</span> HttpURLConnection.HTTP_CONFLICT: &#123;</span><br><span class="line">                LOGGER.error(</span><br><span class="line">                    <span class="string">"[&#123;&#125;] [sub-server-error] get server config being modified concurrently, dataId=&#123;&#125;, group=&#123;&#125;, "</span></span><br><span class="line">                        + <span class="string">"tenant=&#123;&#125;"</span>, agent.getName(), dataId, group, tenant);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NacosException(NacosException.CONFLICT,</span><br><span class="line">                    <span class="string">"data being modified, dataId="</span> + dataId + <span class="string">",group="</span> + group + <span class="string">",tenant="</span> + tenant);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> HttpURLConnection.HTTP_FORBIDDEN: &#123;</span><br><span class="line">                LOGGER.error(<span class="string">"[&#123;&#125;] [sub-server-error] no right, dataId=&#123;&#125;, group=&#123;&#125;, tenant=&#123;&#125;"</span>, agent.getName(), dataId,</span><br><span class="line">                    group, tenant);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NacosException(result.code, result.content);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                LOGGER.error(<span class="string">"[&#123;&#125;] [sub-server-error]  dataId=&#123;&#125;, group=&#123;&#125;, tenant=&#123;&#125;, code=&#123;&#125;"</span>, agent.getName(), dataId,</span><br><span class="line">                    group, tenant, result.code);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NacosException(result.code,</span><br><span class="line">                    <span class="string">"http error, code="</span> + result.code + <span class="string">",dataId="</span> + dataId + <span class="string">",group="</span> + group + <span class="string">",tenant="</span> + tenant);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Nacos服务端数据如何存储"><a href="#Nacos服务端数据如何存储" class="headerlink" title="Nacos服务端数据如何存储"></a>Nacos服务端数据如何存储</h2><p>客户端获得配置中心的流程分析结束之后，还有一个疑惑是，nacos server上如何存储配置呢？</p><p>在standalone模式下，Nacos默认使用derby数据库来存储配置信息。在Nacos_PATH/data目录，有一个derby-data的文件， Derby是Java编写的数据库，是Apache的开源项目，默认的所有配置就是存在derby这个数据库中。</p><p>Nacos还可以支持mysql的存储，如果想要修改，可以按照以下步骤执行</p><p><strong>只有集群模式下才能用mysql</strong></p><ol><li><p>创建一个nacos_config的数据库，把nacos-mysql.sql 的脚本文件导入进去</p></li><li><p>修改NACOS_PATH/conf/application.properties ，增加mysql的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.platform=mysql</span><br><span class="line">db.num=1</span><br><span class="line">db.url.0=jdbc:mysql://localhost:3306/nacos_config</span><br><span class="line">db.user=root</span><br><span class="line">db.password=root</span><br></pre></td></tr></table></figure></li><li><p>修改cluster.conf </p></li><li><p>为了演示效果，直接把集群的三个节点都设置为localhost</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">localhost</span><br><span class="line">localhost</span><br><span class="line">localhost</span><br></pre></td></tr></table></figure></li><li><p>启动命令<code>startup.cmd -m cluster</code> </p></li><li><p>登录nacos控制台，保存一条配置信息后，可以在数据库中config_info表找到对应的数据。同时在NACOS_PATH/data/config-data/DEFAULT_GROUP/多了一个example的文件，这个文件的内容就是dataid=example下的所有数据</p></li></ol><h1 id="Dubbo-Nacos实现发现和健康监测"><a href="#Dubbo-Nacos实现发现和健康监测" class="headerlink" title="Dubbo+Nacos实现发现和健康监测"></a>Dubbo+Nacos实现发现和健康监测</h1><p>实现服务注册与发现，大家都比较熟悉了，没多久之前才讲过zookeeper；  本次案例采用dubbo2.6.5版本。 </p><h2 id="jar包依赖"><a href="#jar包依赖" class="headerlink" title="jar包依赖"></a>jar包依赖</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.2.1.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;dubbo&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.6.5&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.0.1&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;nacos-discovery-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.2.1&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;dubbo-registry-nacos&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.0.1&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h2><p>修改注册中心协议为nacos</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">dubbo</span></span><br><span class="line">  <span class="string">registry</span></span><br><span class="line"><span class="attr">     address:</span> <span class="attr">nacos://127.0.0.1:8848</span></span><br></pre></td></tr></table></figure><p>## </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从源码层面揭秘Nacos如何实现配置中心的&lt;/p&gt;
    
    </summary>
    
      <category term="技术文章" scheme="https://istio.tech/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Nacos" scheme="https://istio.tech/tags/Nacos/"/>
    
      <category term="源码分析" scheme="https://istio.tech/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Alibaba Nacos的基本使用</title>
    <link href="https://istio.tech/2019/08/05/Alibaba-Nacos%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://istio.tech/2019/08/05/Alibaba-Nacos的基本使用/</id>
    <published>2019-08-05T03:08:00.000Z</published>
    <updated>2019-08-05T03:09:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>初步了解Nacos的基本使用</p><a id="more"></a><h1 id="关于Spring-Cloud-Alibaba"><a href="#关于Spring-Cloud-Alibaba" class="headerlink" title="关于Spring Cloud Alibaba"></a>关于Spring Cloud Alibaba</h1><p>前面一个阶段，我们讲完了Spring Cloud Alibaba生态中的Dubbo组件，当然，我们没有基于spring cloud project的形式来讲解，而是基于组件的形式形式来讲，原因是spring cloud本质上就是对各个组件的集成。</p><p>目前Spring Cloud Alibaba这个生态中，已经有相对成熟的体系</p><ol><li><strong>Dubbo</strong>                              用于实现高性能Java RPC 通信</li><li><strong>Nacos</strong>                               服务注册发现、配置管理、服务管理</li><li><strong>Sentinel</strong>                             流量控制、熔断降级、系统负载保护</li><li><strong>RocketMQ</strong>                          分布式消息系统，提供低延时的、高可靠的消息发布与订阅服务</li><li><strong>Seata</strong>                                高性能微服务分布式事务解决方案</li><li><strong>Alibaba Cloud OSS</strong>             阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。</li><li><strong>Alibaba Cloud SchedulerX</strong>   阿里中间件团队开发的一款分布式任务调度产品，支持周期性的任务与固定时间点触发任务。</li><li><strong>Alibaba Cloud SMS</strong>             覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li></ol><p>在2019年8月1号，spring-cloud-alibaba发布了第一个毕业版本（从孵化器仓库毕业），发布了V2.1.0.RELEASE版本，这个版本中针对</p><ol><li>Sentinel进行了升级，升级到了1.6.3版本</li><li>Nacos Discovery更新到了1.1.1版本</li><li>Nacos Config更新到1.1.1版本</li><li>Dubbo Spring Cloud 更新到2.7.3版本</li><li>Seata更新到0.7.1</li></ol><p>另外，相比于Spring Cloud Netflix 生态，到2020年，archaus/hystrix/ribbon/zuul/turbine等starter都会进入维护模式，进入维护模式意味着spring cloud团队不会再向这些模块中添加新的功能，但是仍然会修复安全问题和一些block级别的bug。只是没有新的功能迭代了，spring cloud netflix仍然可以继续使用。</p><blockquote><p>文章链接-&gt;<a href="https://spring.io/blog/2018/12/12/spring-cloud-greenwich-rc1-available-now#spring-cloud-netflix-projects-entering-maintenance-mode" target="_blank" rel="noopener">spring-cloud-netflix-projects-entering-maintenance-mode</a></p></blockquote><p>进入维护模式的最根本原因还是Netflix对于zuul、ribbon等项目维护投入比较少、所以spring cloud 会在greenwich中把这些项目都进入到维护模式。</p><p>当然，这些组件会有相应功能的其他组件代理，有些还在孵化中。有些已经毕业了，比如alibaba这套标准</p><h1 id="初步理解Nacos"><a href="#初步理解Nacos" class="headerlink" title="初步理解Nacos"></a>初步理解Nacos</h1><p>前面的课程已经详细分析了Dubbo这个框架，提供了一个高性能的RPC通信服务以及服务治理。那么接下来了解一下Nacos，好在这些组件都是国内开源的，不管是从源码层面，还是文档这块，都比国外的组件来的丰富。所以使得我们的学习效率也提升了不少</p><h2 id="Nacos是什么"><a href="#Nacos是什么" class="headerlink" title="Nacos是什么"></a>Nacos是什么</h2><p>Nacos提供了统一配置管理、服务发现与注册。 其中服务注册和发现的功能，相当于dubbo里面使用到的zookeeper、 或者spring cloud里面应用到的consoul以及eureka。</p><h2 id="Nacos的特性"><a href="#Nacos的特性" class="headerlink" title="Nacos的特性"></a>Nacos的特性</h2><h3 id="服务发现和服务健康监测"><a href="#服务发现和服务健康监测" class="headerlink" title="服务发现和服务健康监测"></a>服务发现和服务健康监测</h3><p>Nacos提供了基于RPC的服务发现，服务提供者可以将自身的服务通过原生API或者openApi来实现服务的注册，服务消费者可以使用API或者Http来查找和发现服务</p><p>同时，Nacos提供了对服务的实时监控检查，当发现服务不可用时，可以实现对服务的动态下线从而阻止服务消费者向不健康的服务发送请求。</p><h3 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h3><p>传统的配置管理，是基于项目中的配置文件来实现，当出现配置文件变更时需要重新部署，而动态配置中心可以将配置进行统一的管理，是的配置变得更加灵活以及高效。</p><p>动态配置中心可以实现路由规则的动态配置、限流规则的动态配置、动态数据源、开关、动态UI等场景</p><p>国内比较有名的开源配置中心: Aollo / diamond / disconf </p><h1 id="Nacos的基本应用"><a href="#Nacos的基本应用" class="headerlink" title="Nacos的基本应用"></a>Nacos的基本应用</h1><h2 id="Nacos的下载"><a href="#Nacos的下载" class="headerlink" title="Nacos的下载"></a>Nacos的下载</h2><p>首先，我们需要先启动Nacos服务，启动服务有两种方式，一种是直接下载已经编译好的包直接运行。另一种是通过源码来构建。 我们基于源码先来构建</p><p>因为目前版本发布比较频繁，所以我们讲的时候，它的内容也一直在变化。基本上我们只需要简单了解它的应用就行</p><h2 id="从github上下载源码"><a href="#从github上下载源码" class="headerlink" title="从github上下载源码"></a>从github上下载源码</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/alibaba/nacos.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> nacos/</span><br><span class="line"></span><br><span class="line">mvn -Prelease-nacos clean install -U</span><br><span class="line"></span><br><span class="line">ls -al distribution/target/</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> distribution/target/nacos-server-$version/nacos/bin</span><br></pre></td></tr></table></figure><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux系统下：   sh startup.sh -m standalone</span><br><span class="line"></span><br><span class="line">window系统：  <span class="built_in">cmd</span> startup.<span class="built_in">cmd</span></span><br></pre></td></tr></table></figure><h2 id="访问nacos"><a href="#访问nacos" class="headerlink" title="访问nacos"></a>访问nacos</h2><p><a href="http://localhost:8848/nacos" target="_blank" rel="noopener">http://localhost:8848/nacos</a></p><p>默认的帐号密码是:nacos/nacos</p><h1 id="Nacos配置中心的实践"><a href="#Nacos配置中心的实践" class="headerlink" title="Nacos配置中心的实践"></a>Nacos配置中心的实践</h1><p>我们去了解一个技术，最好的方式就是快速构建一个应用，首先我们基于Nacos作为配置中心的基本应用</p><h2 id="添加jar包依赖"><a href="#添加jar包依赖" class="headerlink" title="添加jar包依赖"></a>添加jar包依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-config-spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>版本 0.2.x.RELEASE 对应的是 Spring Boot 2.x 版本，版本 0.1.x.RELEASE 对应的是 Spring Boot 1.x 版本。</p></blockquote><h2 id="application-yaml"><a href="#application-yaml" class="headerlink" title="application.yaml"></a>application.yaml</h2><p>在yaml文件中添加nacos服务端的地址</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nacos:</span></span><br><span class="line"><span class="attr">  config:</span></span><br><span class="line"><span class="attr">    server-addr:</span> <span class="attr">localhost:8848</span></span><br></pre></td></tr></table></figure><h2 id="NacosConfigController"><a href="#NacosConfigController" class="headerlink" title="NacosConfigController"></a>NacosConfigController</h2><p>创建一个controller，用来测试从nacos配置中心获取数据的场景</p><p>dataId 可以认为是一个配置集，一个系统可以有多个配置集，一般我们可以使用包名来命名，从而很好的达到数据分类的目的</p><p>groupId 配置分组，这个和dataId类似，但是它的纬度更高一些，可能是基于项目层面进行划分</p><p>autoRefreshed 自动更新配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NacosPropertySource</span>(dataId =<span class="string">"example"</span>,autoRefreshed = <span class="keyword">true</span>,groupId = <span class="string">"example_group"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosConfigController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//value表示默认值，保险起见，在实际应用中，尽量设置好默认值</span></span><br><span class="line">    <span class="meta">@NacosValue</span>(value = <span class="string">"$&#123;info:hello nacos&#125;"</span>,autoRefreshed = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> String info;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/get"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h2><ul><li>启动服务，访问<a href="http://localhost:8080/get" target="_blank" rel="noopener">http://localhost:8080/get</a> ，浏览器会显示info的默认值，因为这个时候nacos还没有配置info的key</li><li>进入控制台，增加配置，dataid=example，groupid=example_group, 并且增加 info = xx的value属性</li><li>再次刷新url，就可以读取到值的变化</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初步了解Nacos的基本使用&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nacos" scheme="https://istio.tech/tags/Nacos/"/>
    
      <category term="Spring Cloud Alibaba" scheme="https://istio.tech/tags/Spring-Cloud-Alibaba/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析之请求发送流程</title>
    <link href="https://istio.tech/2019/08/05/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E8%AF%B7%E6%B1%82%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B/"/>
    <id>https://istio.tech/2019/08/05/Dubbo源码分析之请求发送流程/</id>
    <published>2019-08-05T03:05:00.000Z</published>
    <updated>2019-08-05T03:06:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要分析一下客户端发起一次远程通信的时候，客户端和服务端分别是如何处理的</p><a id="more"></a><h1 id="客户端生成的proxy"><a href="#客户端生成的proxy" class="headerlink" title="客户端生成的proxy"></a>客户端生成的proxy</h1><p>上节课，我们分析到消费者初始化完成之后，会生成一个proxy，而这个proxy本质上是一个动态代理类。</p><h2 id="JavassistProxyFactory-getProxy"><a href="#JavassistProxyFactory-getProxy" class="headerlink" title="JavassistProxyFactory.getProxy"></a>JavassistProxyFactory.getProxy</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.getProxy(interfaces).newInstance(<span class="keyword">new</span> InvokerInvocationHandler(invoker));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们来分解一下，这个invoker实际上是：MockClusterWrapper(FailoverCluster(directory))</p><p>然后通过InvokerInvocationHandler做了一层包装变成了</p><p>InvokerInvocationHandler(MockClusterWrapper(FailoverCluster(directory)))</p><h2 id="proxy-getProxy"><a href="#proxy-getProxy" class="headerlink" title="proxy.getProxy"></a>proxy.getProxy</h2><p>这个方法里面，会生成一个动态代理的方法，我们通过debug可以看到动态字节码的拼接过程。它代理了当前这个接口的方法<code>sayHello</code> , 并且方法里面是使用handler.invoke进行调用的。</p><p>而handler又是这样一个实现：InvokerInvocationHandler(MockClusterWrapper(FailoverCluster(directory)))</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.<span class="function">String <span class="title">sayHello</span><span class="params">(java.lang.String arg0)</span></span>&#123;</span><br><span class="line">  Object[] args = <span class="keyword">new</span> Object[<span class="number">1</span>]; </span><br><span class="line">  args[<span class="number">0</span>] = ($w)$<span class="number">1</span>; </span><br><span class="line">  Object ret = handler.invoke(<span class="keyword">this</span>, methods[<span class="number">0</span>], args); </span><br><span class="line"><span class="keyword">return</span> (java.lang.String)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="消费端调用的过程"><a href="#消费端调用的过程" class="headerlink" title="消费端调用的过程"></a>消费端调用的过程</h1><p>handler的调用链路为：InvokerInvocationHandler(MockClusterWrapper(FailoverCluster(directory)))</p><h2 id="图解调用链"><a href="#图解调用链" class="headerlink" title="图解调用链"></a>图解调用链</h2><p><img src="/images/1564553854105.png" alt="1564553854105"></p><h2 id="InvokerInvocationHandler-invoke"><a href="#InvokerInvocationHandler-invoke" class="headerlink" title="InvokerInvocationHandler.invoke"></a>InvokerInvocationHandler.invoke</h2><p>这个方法主要判断当前调用的远程方法，如果是tostring、hashcode、equals，就直接返回</p><p>否则，调用invoker.invoke,进入到<code>MockClusterWrapper.invoke</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">        <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(invoker, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"toString"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"hashCode"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"equals"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.equals(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//createInvocation,参数为目标方法名称和目标方法的参数，看起来似乎是组装一个传输的对象</span></span><br><span class="line">        <span class="keyword">return</span> invoker.invoke(createInvocation(method, args)).recreate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="MockClusterInvoker-invoke"><a href="#MockClusterInvoker-invoke" class="headerlink" title="MockClusterInvoker.invoke"></a>MockClusterInvoker.invoke</h2><p>Mock，在这里面有两个逻辑</p><ol><li>是否客户端强制配置了mock调用，那么在这种场景中主要可以用来解决服务端还没开发好的时候直接使用本地数据进行测试</li><li>是否出现了异常，如果出现异常则使用配置好的Mock类来实现服务的降级</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        Result result = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//从url中获得MOCK_KEY对应的value</span></span><br><span class="line">        String value = directory.getUrl().getMethodParameter(invocation.getMethodName(), Constants.MOCK_KEY, Boolean.FALSE.toString()).trim();</span><br><span class="line">    <span class="comment">//如果没有配置mock，则直接传递给下个invoker调用</span></span><br><span class="line">        <span class="keyword">if</span> (value.length() == <span class="number">0</span> || value.equalsIgnoreCase(<span class="string">"false"</span>)) &#123;</span><br><span class="line">            <span class="comment">//no mock</span></span><br><span class="line">            result = <span class="keyword">this</span>.invoker.invoke(invocation);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value.startsWith(<span class="string">"force"</span>)) &#123;<span class="comment">//如果强制为本地调用，则执行mockInvoke</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">"force-mock: "</span> + invocation.getMethodName() + <span class="string">" force-mock enabled , url : "</span> + directory.getUrl());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//force:direct mock</span></span><br><span class="line">            result = doMockInvoke(invocation, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//fail-mock</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = <span class="keyword">this</span>.invoker.invoke(invocation);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.isBiz()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果远程调用出现异常，则使用Mock进行处理</span></span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"fail-mock: "</span> + invocation.getMethodName() + <span class="string">" fail-mock enabled , url : "</span> + directory.getUrl(), e);</span><br><span class="line">                &#125;</span><br><span class="line">                result = doMockInvoke(invocation, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="AbstractClusterInvoker-invoke"><a href="#AbstractClusterInvoker-invoke" class="headerlink" title="AbstractClusterInvoker.invoke"></a>AbstractClusterInvoker.invoke</h2><p>下一个invoke，应该进入FailoverClusterInvoke，但是在这里它又用到了模版方法，所以直接进入到父类的invoke方法中</p><ol><li><p>绑定attachments，Dubbo中，可以通过 RpcContext 上的 setAttachment 和 getAttachment 在服务消费方和提供方之间进行参数的隐式传递，所以这段代码中会去绑定attachments</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RpcContext.getContext().setAttachment(<span class="string">"index"</span>, <span class="string">"1"</span>)</span><br></pre></td></tr></table></figure></li><li><p>通过list获得invoker列表，这个列表基本可以猜测到是从directory里面获得的、但是这里面还实现了服务路由的逻辑，简单来说就是先拿到invoker列表，然后通过router进行服务路由，筛选出符合路由规则的服务提供者（暂时不细讲，属于另外一个逻辑）</p></li><li><p>initLoadBalance 初始化负载均衡机制</p></li><li><p>执行doInvoke</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        checkWhetherDestroyed();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// attachments，这个是什么意</span></span><br><span class="line">        Map&lt;String, String&gt; contextAttachments = RpcContext.getContext().getAttachments();</span><br><span class="line">        <span class="keyword">if</span> (contextAttachments != <span class="keyword">null</span> &amp;&amp; contextAttachments.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            ((RpcInvocation) invocation).addAttachments(contextAttachments);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; invokers = list(invocation);</span><br><span class="line">        LoadBalance loadbalance = initLoadBalance(invokers, invocation);</span><br><span class="line">        RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);</span><br><span class="line">        <span class="keyword">return</span> doInvoke(invocation, invokers, loadbalance);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="initLoadBalance"><a href="#initLoadBalance" class="headerlink" title="initLoadBalance"></a>initLoadBalance</h2><p>不用看这个代码，基本也能猜测到，会从url中获得当前的负载均衡算法，然后使用spi机制来获得负载均衡的扩展点。然后返回一个具体的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> LoadBalance <span class="title">initLoadBalance</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(invokers)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(invokers.get(<span class="number">0</span>).getUrl()</span><br><span class="line">                    .getMethodParameter(RpcUtils.getMethodName(invocation), Constants.LOADBALANCE_KEY, Constants.DEFAULT_LOADBALANCE));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(Constants.DEFAULT_LOADBALANCE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="FailoverClusterInvoker-doInvoke"><a href="#FailoverClusterInvoker-doInvoke" class="headerlink" title="FailoverClusterInvoker.doInvoke"></a>FailoverClusterInvoker.doInvoke</h2><p>这段代码逻辑也很好理解，因为我们之前在讲Dubbo的时候说过容错机制，而failover是失败重试，所以这里面应该会实现容错的逻辑</p><ul><li>获得重试的次数，并且进行循环</li><li>获得目标服务，并且记录当前已经调用过的目标服务防止下次继续将请求发送过去</li><li>如果执行成功，则返回结果</li><li>如果出现异常，判断是否为业务异常，如果是则抛出，否则，进行下一次重试</li></ul><p><img src="http://dubbo.apache.org/docs/zh-cn/user/sources/images/cluster.jpg" alt="cluster"></p><ul><li>这里的 <code>Invoker</code> 是 <code>Provider</code> 的一个可调用 <code>Service</code> 的抽象，<code>Invoker</code> 封装了 <code>Provider</code> 地址及 <code>Service</code> 接口信息</li><li><code>Directory</code> 代表多个 <code>Invoker</code>，可以把它看成 <code>List&lt;Invoker&gt;</code> ，但与 <code>List</code> 不同的是，它的值可能是动态变化的，比如注册中心推送变更</li><li><code>Cluster</code> 将 <code>Directory</code> 中的多个 <code>Invoker</code> 伪装成一个 <code>Invoker</code>，对上层透明，伪装过程包含了容错逻辑，调用失败后，重试另一个</li><li><code>Router</code> 负责从多个 <code>Invoker</code> 中按路由规则选出子集，比如读写分离，应用隔离等</li><li><code>LoadBalance</code> 负责从多个 <code>Invoker</code> 中选出具体的一个用于本次调用，选的过程包含了负载均衡算法，调用失败后，需要重选</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, <span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; copyInvokers = invokers;</span><br><span class="line">        checkInvokers(copyInvokers, invocation);</span><br><span class="line">        String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">        <span class="keyword">int</span> len = getUrl().getMethodParameter(methodName, Constants.RETRIES_KEY, Constants.DEFAULT_RETRIES) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            len = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// retry loop.</span></span><br><span class="line">        RpcException le = <span class="keyword">null</span>; <span class="comment">// last exception.</span></span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; invoked = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(copyInvokers.size()); <span class="comment">// invoked invokers.</span></span><br><span class="line">        Set&lt;String&gt; providers = <span class="keyword">new</span> HashSet&lt;String&gt;(len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">//Reselect before retry to avoid a change of candidate `invokers`.</span></span><br><span class="line">            <span class="comment">//<span class="doctag">NOTE:</span> if `invokers` changed, then `invoked` also lose accuracy.</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                checkWhetherDestroyed();</span><br><span class="line">                copyInvokers = list(invocation);</span><br><span class="line">                <span class="comment">// check again</span></span><br><span class="line">                checkInvokers(copyInvokers, invocation);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//通过负载均衡获得目标invoker</span></span><br><span class="line">            Invoker&lt;T&gt; invoker = select(loadbalance, invocation, copyInvokers, invoked);</span><br><span class="line">            invoked.add(invoker);<span class="comment">//记录已经调用过的服务，下次调用会进行过滤</span></span><br><span class="line">            RpcContext.getContext().setInvokers((List) invoked);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//服务调用成功，直接返回结果</span></span><br><span class="line">                Result result = invoker.invoke(invocation);</span><br><span class="line">                <span class="keyword">if</span> (le != <span class="keyword">null</span> &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Although retry the method "</span> + methodName</span><br><span class="line">                            + <span class="string">" in the service "</span> + getInterface().getName()</span><br><span class="line">                            + <span class="string">" was successful by the provider "</span> + invoker.getUrl().getAddress()</span><br><span class="line">                            + <span class="string">", but there have been failed providers "</span> + providers</span><br><span class="line">                            + <span class="string">" ("</span> + providers.size() + <span class="string">"/"</span> + copyInvokers.size()</span><br><span class="line">                            + <span class="string">") from the registry "</span> + directory.getUrl().getAddress()</span><br><span class="line">                            + <span class="string">" on the consumer "</span> + NetUtils.getLocalHost()</span><br><span class="line">                            + <span class="string">" using the dubbo version "</span> + Version.getVersion() + <span class="string">". Last error is: "</span></span><br><span class="line">                            + le.getMessage(), le);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.isBiz()) &#123; <span class="comment">// 如果是业务异常，直接抛出不进行重试</span></span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">                le = e;<span class="comment">//记录异常信息，进行下一次循环</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                le = <span class="keyword">new</span> RpcException(e.getMessage(), e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                providers.add(invoker.getUrl().getAddress());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(le.getCode(), <span class="string">"Failed to invoke the method "</span></span><br><span class="line">                + methodName + <span class="string">" in the service "</span> + getInterface().getName()</span><br><span class="line">                + <span class="string">". Tried "</span> + len + <span class="string">" times of the providers "</span> + providers</span><br><span class="line">                + <span class="string">" ("</span> + providers.size() + <span class="string">"/"</span> + copyInvokers.size()</span><br><span class="line">                + <span class="string">") from the registry "</span> + directory.getUrl().getAddress()</span><br><span class="line">                + <span class="string">" on the consumer "</span> + NetUtils.getLocalHost() + <span class="string">" using the dubbo version "</span></span><br><span class="line">                + Version.getVersion() + <span class="string">". Last error is: "</span></span><br><span class="line">                + le.getMessage(), le.getCause() != <span class="keyword">null</span> ? le.getCause() : le);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>在调用invoker.invoke之前，会需要通过select选择一个合适的服务进行调用，而这个选择的过程其实就是负载均衡的实现</p><p>所有负载均衡实现类均继承自 AbstractLoadBalance，该类实现了 LoadBalance 接口，并封装了一些公共的逻辑。所以在分析负载均衡实现之前，先来看一下 AbstractLoadBalance 的逻辑。首先来看一下负载均衡的入口方法 select，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">select</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(invokers)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 invokers 列表中仅有一个 Invoker，直接返回即可，无需进行负载均衡</span></span><br><span class="line">    <span class="keyword">if</span> (invokers.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用 doSelect 方法进行负载均衡，该方法为抽象方法，由子类实现</span></span><br><span class="line">    <span class="keyword">return</span> doSelect(invokers, url, invocation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>负载均衡的子类实现有四个，默认情况下是RandomLoadBalance</p><h2 id="randomLoadBalance"><a href="#randomLoadBalance" class="headerlink" title="randomLoadBalance"></a>randomLoadBalance</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = invokers.size();</span><br><span class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> sameWeight = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 下面这个循环有两个作用，第一是计算总权重 totalWeight，</span></span><br><span class="line">        <span class="comment">// 第二是检测每个服务提供者的权重是否相同</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> weight = getWeight(invokers.get(i), invocation);</span><br><span class="line">            <span class="comment">// 累加权重</span></span><br><span class="line">            totalWeight += weight;</span><br><span class="line">            <span class="comment">// 检测当前服务提供者的权重与上一个服务提供者的权重是否相同，</span></span><br><span class="line">            <span class="comment">// 不相同的话，则将 sameWeight 置为 false。</span></span><br><span class="line">            <span class="keyword">if</span> (sameWeight &amp;&amp; i &gt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; weight != getWeight(invokers.get(i - <span class="number">1</span>), invocation)) &#123;</span><br><span class="line">                sameWeight = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 下面的 if 分支主要用于获取随机数，并计算随机数落在哪个区间上</span></span><br><span class="line">        <span class="keyword">if</span> (totalWeight &gt; <span class="number">0</span> &amp;&amp; !sameWeight) &#123;</span><br><span class="line">            <span class="comment">// 随机获取一个 [0, totalWeight) 区间内的数字</span></span><br><span class="line">            <span class="keyword">int</span> offset = random.nextInt(totalWeight);</span><br><span class="line">            <span class="comment">// 循环让 offset 数减去服务提供者权重值，当 offset 小于0时，返回相应的 Invoker。</span></span><br><span class="line">            <span class="comment">// 举例说明一下，我们有 servers = [A, B, C]，weights = [5, 3, 2]，offset = 7。</span></span><br><span class="line">            <span class="comment">// 第一次循环，offset - 5 = 2 &gt; 0，即 offset &gt; 5，</span></span><br><span class="line">            <span class="comment">// 表明其不会落在服务器 A 对应的区间上。</span></span><br><span class="line">            <span class="comment">// 第二次循环，offset - 3 = -1 &lt; 0，即 5 &lt; offset &lt; 8，</span></span><br><span class="line">            <span class="comment">// 表明其会落在服务器 B 对应的区间上</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                <span class="comment">// 让随机值 offset 减去权重值</span></span><br><span class="line">                offset -= getWeight(invokers.get(i), invocation);</span><br><span class="line">                <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 返回相应的 Invoker</span></span><br><span class="line">                    <span class="keyword">return</span> invokers.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果所有服务提供者权重值相同，此时直接随机返回一个即可</span></span><br><span class="line">         <span class="keyword">return</span> invokers.get(ThreadLocalRandom.current().nextInt(length));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过从RegistryDirectory中获得的invoker是什么呢？这个很重要，因为它决定了接下来的调用过程。这个时候我们需要去了解这个invoker是在哪里初始化的？</p><h1 id="可调用的Invoker初始化过程"><a href="#可调用的Invoker初始化过程" class="headerlink" title="可调用的Invoker初始化过程"></a>可调用的Invoker初始化过程</h1><h2 id="RegistryDirectory"><a href="#RegistryDirectory" class="headerlink" title="RegistryDirectory"></a>RegistryDirectory</h2><p>在RegistryDirectory中有一个成员属性，保存了服务地方地址对应的invoke信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Invoker&lt;T&gt;&gt; urlInvokerMap;</span><br></pre></td></tr></table></figure><h2 id="toInvokers"><a href="#toInvokers" class="headerlink" title="toInvokers"></a>toInvokers</h2><p>这个invoker是动态的，基于注册中心的变化而变化的。它的初始化过程的链路是</p><p>RegistryDirectory.notify-&gt;refreshInvoker-&gt;toInvokers 西面的这段代码中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (invoker == <span class="keyword">null</span>) &#123; <span class="comment">// Not in the cache, refer again                </span></span><br><span class="line"> invoker = <span class="keyword">new</span> InvokerDelegate&lt;&gt;(protocol.refer(serviceType, url), url, providerUrl);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>是基于protocol.refer来构建的invoker，并且使用InvokerDelegate进行了委托,在dubboprotocol中，是这样构建invoker的。返回的是一个DubboInvoker对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; serviceType, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">       optimizeSerialization(url);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// create rpc invoker.</span></span><br><span class="line">       DubboInvoker&lt;T&gt; invoker = <span class="keyword">new</span> DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);</span><br><span class="line">       invokers.add(invoker);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> invoker;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>所以这个invoker应该是：InvokerDelegate(ProtocolFilterWrapper(ListenerInvokerWrapper(DubboInvoker())</p><p>ProtocolFilterWrapper-&gt;这个是一个invoker的过滤链路</p><p>ListenerInvokerWrapper-&gt; 这里面暂时没做任何的实现</p><p>所以我们可以直接看到DubboInvoker这个类里面来</p><h1 id="DubboInvoker"><a href="#DubboInvoker" class="headerlink" title="DubboInvoker"></a>DubboInvoker</h1><h2 id="AbstractInvoker-invoke"><a href="#AbstractInvoker-invoke" class="headerlink" title="AbstractInvoker.invoke"></a>AbstractInvoker.invoke</h2><p>这里面也是对Invocation的attachments进行处理，把attachment加入到Invocation中</p><p>这里的attachment，实际上是目标服务的接口信息以及版本信息</p><h2 id="DubboInvoker-doInvoker"><a href="#DubboInvoker-doInvoker" class="headerlink" title="DubboInvoker.doInvoker"></a>DubboInvoker.doInvoker</h2><p>这里面看到一个很熟悉的东西，就是ExchangeClient，这个是客户端和服务端之间的连接</p><p>然后如果当前方法有返回值，也就是isOneway=false,则执行else逻辑，然后通过异步的形式进行通信</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        RpcInvocation inv = (RpcInvocation) invocation;</span><br><span class="line">        <span class="keyword">final</span> String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">    <span class="comment">//将目标方法以及版本好作为参数放入到Invocation中</span></span><br><span class="line">        inv.setAttachment(PATH_KEY, getUrl().getPath());</span><br><span class="line">        inv.setAttachment(VERSION_KEY, version);</span><br><span class="line">       <span class="comment">//获得客户端连接</span></span><br><span class="line">        ExchangeClient currentClient;</span><br><span class="line">        <span class="keyword">if</span> (clients.length == <span class="number">1</span>) &#123;</span><br><span class="line">            currentClient = clients[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currentClient = clients[index.getAndIncrement() % clients.length];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断方法是否有返回值</span></span><br><span class="line">            <span class="keyword">boolean</span> isOneway = RpcUtils.isOneway(getUrl(), invocation);</span><br><span class="line">            <span class="comment">//获得超时时间， 默认是1s</span></span><br><span class="line">            <span class="keyword">int</span> timeout = getUrl().getMethodParameter(methodName, TIMEOUT_KEY, DEFAULT_TIMEOUT);</span><br><span class="line">            <span class="keyword">if</span> (isOneway) &#123;<span class="comment">//如果没有返回值</span></span><br><span class="line">                <span class="keyword">boolean</span> isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, <span class="keyword">false</span>);</span><br><span class="line">                currentClient.send(inv, isSent);</span><br><span class="line">                RpcContext.getContext().setFuture(<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(invocation);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                AsyncRpcResult asyncRpcResult = <span class="keyword">new</span> AsyncRpcResult(inv);</span><br><span class="line">                CompletableFuture&lt;Object&gt; responseFuture = currentClient.request(inv, timeout);</span><br><span class="line">                responseFuture.whenComplete((obj, t) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        asyncRpcResult.completeExceptionally(t);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        asyncRpcResult.complete((AppResponse) obj);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                RpcContext.getContext().setFuture(<span class="keyword">new</span> FutureAdapter(asyncRpcResult));</span><br><span class="line">                <span class="keyword">return</span> asyncRpcResult;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.TIMEOUT_EXCEPTION, <span class="string">"Invoke remote method timeout. method: "</span> + invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.NETWORK_EXCEPTION, <span class="string">"Failed to invoke remote method: "</span> + invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="currentClient-request"><a href="#currentClient-request" class="headerlink" title="currentClient.request"></a>currentClient.request</h2><p>currentClient还记得是一个什么对象吗？ </p><p>它实际是一个ReferenceCountExchangeClient(HeaderExchangeClient())</p><p>所以它的调用链路是</p><p>ReferenceCountExchangeClient-&gt;HeaderExchangeClient-&gt;HeaderExchangeChannel-&gt;(request方法)</p><p>最终，把构建好的RpcInvocation，组装到一个Request对象中进行传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Object&gt; <span class="title">request</span><span class="params">(Object request, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>.getLocalAddress(), <span class="keyword">null</span>, <span class="string">"Failed to send request "</span> + request + <span class="string">", cause: The channel "</span> + <span class="keyword">this</span> + <span class="string">" is closed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建请求对象</span></span><br><span class="line">        Request req = <span class="keyword">new</span> Request();</span><br><span class="line">        req.setVersion(Version.getProtocolVersion());</span><br><span class="line">        req.setTwoWay(<span class="keyword">true</span>);</span><br><span class="line">        req.setData(request);</span><br><span class="line">        DefaultFuture future = DefaultFuture.newFuture(channel, req, timeout);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//NettyClient</span></span><br><span class="line">            channel.send(req);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            future.cancel();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>channel.send的调用链路</p><p>AbstractPeer.send -&gt;AbstractClient.send-&gt;NettyChannel.send</p><p>通过NioSocketChannel把消息发送出去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture future = channel.writeAndFlush(message);</span><br></pre></td></tr></table></figure><h1 id="服务端接收消息的处理流程"><a href="#服务端接收消息的处理流程" class="headerlink" title="服务端接收消息的处理流程"></a>服务端接收消息的处理流程</h1><p>客户端把消息发送出去之后，服务端会收到消息，然后把执行的结果返回到客户端</p><h2 id="服务端接收到消息"><a href="#服务端接收到消息" class="headerlink" title="服务端接收到消息"></a>服务端接收到消息</h2><p>服务端这边接收消息的处理链路，也比较复杂，我们回到NettServer中创建io的过程.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childOption(ChannelOption.TCP_NODELAY, Boolean.TRUE)</span><br><span class="line">                .childOption(ChannelOption.SO_REUSEADDR, Boolean.TRUE)</span><br><span class="line">                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">// <span class="doctag">FIXME:</span> should we use getTimeout()?</span></span><br><span class="line">                        <span class="keyword">int</span> idleTimeout = UrlUtils.getIdleTimeout(getUrl());</span><br><span class="line">                        NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyServer.<span class="keyword">this</span>);</span><br><span class="line">                        ch.pipeline()<span class="comment">//.addLast("logging",new LoggingHandler(LogLevel.INFO))//for debug</span></span><br><span class="line">                                .addLast(<span class="string">"decoder"</span>, adapter.getDecoder())</span><br><span class="line">                                .addLast(<span class="string">"encoder"</span>, adapter.getEncoder())</span><br><span class="line">                                .addLast(<span class="string">"server-idle-handler"</span>, <span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">0</span>, idleTimeout, MILLISECONDS))</span><br><span class="line">                                .addLast(<span class="string">"handler"</span>, nettyServerHandler);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure><p>handler配置的是nettyServerHandler</p><p>server-idle-handler 表示心跳处理的机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> NettyServerHandler nettyServerHandler = <span class="keyword">new</span> NettyServerHandler(getUrl(), <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>Handler与Servlet中的filter很像，通过Handler可以完成通讯报文的解码编码、拦截指定的报文、统一对日志错误进行处理、统一对请求进行计数、控制Handler执行与否</p><h2 id="handler-channelRead"><a href="#handler-channelRead" class="headerlink" title="handler.channelRead()"></a>handler.channelRead()</h2><p>服务端收到读的请求是，会进入这个方法。</p><p>接着通过handler.received来处理msg，这个handle的链路很长，比较复杂，我们需要逐步剖析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        handler.received(channel, msg);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        NettyChannel.removeChannelIfDisconnected(ctx.channel());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handler-&gt;MultiMessageHandler-&gt;HeartbeatHandler-&gt;AllChannelHandler-&gt;DecodeHandler-&gt;HeaderExchangeHandler-&gt;</p><p>最后进入这个方法-&gt;DubboProtocol$requestHandler(receive)</p><p>MultiMessageHandler: 复合消息处理</p><p>HeartbeatHandler：心跳消息处理，接收心跳并发送心跳响应</p><p>AllChannelHandler：业务线程转化处理器，把接收到的消息封装成ChannelEventRunnable可执行任务给线程池处理</p><p>DecodeHandler:业务解码处理器</p><h2 id="服务端处理链路"><a href="#服务端处理链路" class="headerlink" title="服务端处理链路"></a>服务端处理链路</h2><p><img src="/images/1564555999942.png" alt="1564555999942"></p><h2 id="HeaderExchangeHandler-received"><a href="#HeaderExchangeHandler-received" class="headerlink" title="HeaderExchangeHandler.received"></a>HeaderExchangeHandler.received</h2><p>交互层请求响应处理，有三种处理方式</p><ol><li>handlerRequest，双向请求</li><li>handler.received 单向请求</li><li>handleResponse 响应消息</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">final</span> ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">                <span class="comment">// handle request.</span></span><br><span class="line">                Request request = (Request) message;</span><br><span class="line">                <span class="keyword">if</span> (request.isEvent()) &#123;</span><br><span class="line">                    handlerEvent(channel, request);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (request.isTwoWay()) &#123;</span><br><span class="line">                        handleRequest(exchangeChannel, request);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        handler.received(exchangeChannel, request.getData());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Response) &#123;</span><br><span class="line">                handleResponse(channel, (Response) message);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isClientSide(channel)) &#123;</span><br><span class="line">                    Exception e = <span class="keyword">new</span> Exception(<span class="string">"Dubbo client can not supported string message: "</span> + message + <span class="string">" in channel: "</span> + channel + <span class="string">", url: "</span> + channel.getUrl());</span><br><span class="line">                    logger.error(e.getMessage(), e);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    String echo = handler.telnet(channel, (String) message);</span><br><span class="line">                    <span class="keyword">if</span> (echo != <span class="keyword">null</span> &amp;&amp; echo.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        channel.send(echo);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handler.received(exchangeChannel, message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            HeaderExchangeChannel.removeChannelIfDisconnected(channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="ExchangeHandler-reply"><a href="#ExchangeHandler-reply" class="headerlink" title="ExchangeHandler.reply"></a>ExchangeHandler.reply</h2><p>接着进入到ExchangeHandler.reply这个方法中</p><ul><li>把message转化为Invocation</li><li>调用getInvoker获得一个Invoker对象</li><li>然后通过<code>Result result = invoker.invoke(inv);</code> 进行调用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Object&gt; <span class="title">reply</span><span class="params">(ExchangeChannel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!(message <span class="keyword">instanceof</span> Invocation)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(channel, <span class="string">"Unsupported request: "</span></span><br><span class="line">                        + (message == <span class="keyword">null</span> ? <span class="keyword">null</span> : (message.getClass().getName() + <span class="string">": "</span> + message))</span><br><span class="line">                        + <span class="string">", channel: consumer: "</span> + channel.getRemoteAddress() + <span class="string">" --&gt; provider: "</span> + channel.getLocalAddress());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Invocation inv = (Invocation) message;</span><br><span class="line">            Invoker&lt;?&gt; invoker = getInvoker(channel, inv);</span><br><span class="line">            <span class="comment">// 需要考虑到回调的问题</span></span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.toString().equals(inv.getAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) &#123;</span><br><span class="line">                String methodsStr = invoker.getUrl().getParameters().get(<span class="string">"methods"</span>);</span><br><span class="line">                <span class="keyword">boolean</span> hasMethod = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (methodsStr == <span class="keyword">null</span> || !methodsStr.contains(<span class="string">","</span>)) &#123;</span><br><span class="line">                    hasMethod = inv.getMethodName().equals(methodsStr);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    String[] methods = methodsStr.split(<span class="string">","</span>);</span><br><span class="line">                    <span class="keyword">for</span> (String method : methods) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (inv.getMethodName().equals(method)) &#123;</span><br><span class="line">                            hasMethod = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!hasMethod) &#123;</span><br><span class="line">                    logger.warn(<span class="keyword">new</span> IllegalStateException(<span class="string">"The methodName "</span> + inv.getMethodName()</span><br><span class="line">                            + <span class="string">" not found in callback service interface ,invoke will be ignored."</span></span><br><span class="line">                            + <span class="string">" please update the api interface. url is:"</span></span><br><span class="line">                            + invoker.getUrl()) + <span class="string">" ,invocation is :"</span> + inv);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            RpcContext rpcContext = RpcContext.getContext();</span><br><span class="line">            rpcContext.setRemoteAddress(channel.getRemoteAddress());</span><br><span class="line">            Result result = invoker.invoke(inv);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> AsyncRpcResult) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((AsyncRpcResult) result).getResultFuture().thenApply(r -&gt; (Object) r);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> CompletableFuture.completedFuture(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="getInvoker"><a href="#getInvoker" class="headerlink" title="getInvoker"></a>getInvoker</h2><p>这里面是获得一个invoker的实现</p><p><code>DubboExporter&lt;?&gt; exporter = (DubboExporter&lt;?&gt;) exporterMap.get(serviceKey);</code></p><p>这段代码非常熟悉，exporterMap不就是我们之前在分析服务发布的过程中，保存的Invoker吗？</p><p>而key，就是对应的interface:port 。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Invoker&lt;?&gt; getInvoker(Channel channel, Invocation inv) <span class="keyword">throws</span> RemotingException &#123;</span><br><span class="line">        <span class="keyword">boolean</span> isCallBackServiceInvoke = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isStubServiceInvoke = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> port = channel.getLocalAddress().getPort();</span><br><span class="line">        String path = inv.getAttachments().get(Constants.PATH_KEY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if it's callback service on client side</span></span><br><span class="line">        isStubServiceInvoke = Boolean.TRUE.toString().equals(inv.getAttachments().get(Constants.STUB_EVENT_KEY));</span><br><span class="line">        <span class="keyword">if</span> (isStubServiceInvoke) &#123;</span><br><span class="line">            port = channel.getRemoteAddress().getPort();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//callback</span></span><br><span class="line">        isCallBackServiceInvoke = isClientSide(channel) &amp;&amp; !isStubServiceInvoke;</span><br><span class="line">        <span class="keyword">if</span> (isCallBackServiceInvoke) &#123;</span><br><span class="line">            path += <span class="string">"."</span> + inv.getAttachments().get(Constants.CALLBACK_SERVICE_KEY);</span><br><span class="line">            inv.getAttachments().put(IS_CALLBACK_SERVICE_INVOKE, Boolean.TRUE.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String serviceKey = serviceKey(port, path, inv.getAttachments().get(Constants.VERSION_KEY), inv.getAttachments().get(Constants.GROUP_KEY));</span><br><span class="line">        DubboExporter&lt;?&gt; exporter = (DubboExporter&lt;?&gt;) exporterMap.get(serviceKey);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (exporter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(channel, <span class="string">"Not found exported service: "</span> + serviceKey + <span class="string">" in "</span> + exporterMap.keySet() + <span class="string">", may be version or group mismatch "</span> +</span><br><span class="line">                    <span class="string">", channel: consumer: "</span> + channel.getRemoteAddress() + <span class="string">" --&gt; provider: "</span> + channel.getLocalAddress() + <span class="string">", message:"</span> + inv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> exporter.getInvoker();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="exporterMap"><a href="#exporterMap" class="headerlink" title="exporterMap"></a>exporterMap</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap = new ConcurrentHashMap&lt;String, Exporter&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure><p>在服务发布时，实际上是把invoker包装成了DubboExpoter。然后放入到exporterMap中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">       URL url = invoker.getUrl();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// export service.</span></span><br><span class="line">       String key = serviceKey(url);</span><br><span class="line">       DubboExporter&lt;T&gt; exporter = <span class="keyword">new</span> DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">       exporterMap.put(key, exporter);</span><br></pre></td></tr></table></figure><h2 id="invoker-invoke-inv"><a href="#invoker-invoke-inv" class="headerlink" title="invoker.invoke(inv);"></a>invoker.invoke(inv);</h2><p>接着调用invoker.invoke</p><p>那么再会议一下，此时的invoker是一个什么呢？</p><p>invoker=ProtocolFilterWrapper(InvokerDelegate(DelegateProviderMetaDataInvoker(AbstractProxyInvoker)))</p><p>最后一定会进入到这个代码里面</p><h2 id="AbstractProxyInvoker"><a href="#AbstractProxyInvoker" class="headerlink" title="AbstractProxyInvoker"></a>AbstractProxyInvoker</h2><p>在AbstractProxyInvoker里面，doInvoker本质上调用的是wrapper.invokeMethod()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Object[] arguments)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>而Wrapper是一个动态代理类，它的定义是这样的， 最终调用w.sayHello()方法进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invokeMethod</span><span class="params">(Object o, String n, Class[] p, Object[] v)</span> <span class="keyword">throws</span> java.lang.reflect.InvocationTargetException </span>&#123;</span><br><span class="line">        com.gupaoedu.dubbo.practice.ISayHelloService w;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            w = ((com.gupaoedu.dubbo.practice.ISayHelloService) $<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"sayHello"</span>.equals($<span class="number">2</span>) &amp;&amp; $<span class="number">3</span>.length == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ($w) w.sayHello((java.lang.String) $<span class="number">4</span>[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.lang.reflect.InvocationTargetException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> org.apache.dubbo.common.bytecode.NoSuchMethodException(<span class="string">"Not found method \""</span> + $<span class="number">2</span> + <span class="string">"\" in class com.gupaoedu.dubbo.practice.ISayHelloService."</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要分析一下客户端发起一次远程通信的时候，客户端和服务端分别是如何处理的&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="https://istio.tech/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="源码分析" scheme="https://istio.tech/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="Dubbo" scheme="https://istio.tech/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>HashMap1.8源码分析</title>
    <link href="https://istio.tech/2019/07/28/HashMap1-8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://istio.tech/2019/07/28/HashMap1-8源码分析/</id>
    <published>2019-07-28T15:11:00.000Z</published>
    <updated>2019-07-28T15:19:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于HashMap想必大家都不陌生，无论是平时code还是面试都经常和它打交道。今天我们通过源码的层面来分析一下它的实现原理，注意本文基于的是JDK1.8。</p><a id="more"></a><p>问题是从哪边开始聊起呢？我觉得不妨先从一段熟悉的代码开始。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"Jack"</span>);</span><br></pre></td></tr></table></figure><p>然后我们会迫不及待点开HashMap这个类，发现里面有大量的属性和方法，一脸懵逼。那就直接点开put方法？点了之后发现下面这段代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>依旧一脸懵逼，完全没有看下去的欲望，怎么办？为什么会这样？原因是我们不了解HashMap的数据结构，什么意思？也就是说，当把key，value存储到HashMap中之后，不知道它们是以何种数据排列的方式去存储的，这样根本就不明白源码写的思路是什么，所以我们先把目光转向到数据结构，更准备地说是HashMap的数据结构。</p><h1 id="1-HashMap数据结构"><a href="#1-HashMap数据结构" class="headerlink" title="1 HashMap数据结构"></a>1 HashMap数据结构</h1><p>从网上的很多资料我们知道，HashMap1.7的数据结构是数组+链表，HashMap1.8的数据结构是数组+链表+红黑树，下面这张图我画出了HashMap1.8的数据结构。</p><p><img src="/images/image-20190304144017271.png" alt></p><p>有些哥们可能会说，我在网上看到的不是这样。这时候你可以发挥空间想象能力逆时针旋转个90度，也就是下面这样的展示形式。</p><p><img src="/images/image-20190304144257210.png" alt></p><p>不管如何，反正都能体现出是数组+链表+红黑树的数据结构的方式。虽然数据结构是知道了，但是关键是图解中的每个小格子表示的是什么呢？对于我们了解HashMap的原理和源码有什么作用吗？先别急，一个个来看，先看每个小格子表示什么。</p><h1 id="2-每个小格子的含义"><a href="#2-每个小格子的含义" class="headerlink" title="2 每个小格子的含义"></a>2 每个小格子的含义</h1><p>我们可以猜想一下，每个小格子表示里面至少包含了key，value，为什么这么说呢？因为hashmap.put(key,value)之后，就会形成上述的数组+链表+红黑树的结构，那这个结构中的每个小格子至少把key和value涵盖进去了，如果不是，那么key,value怎么存储呢？ok，假如这个猜想是对的，那Java中想要同时存储key,value两个值，该怎么表示呢？我觉得可以用XXX类，比如下面的伪代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XXX</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer key;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我觉得靠谱，如果真的是这样，那么要想形成上述的数据结构的图解，只需要创建一个个XXX类的对象，然后排列好它们的方式不就ok了吗？没错，关键这个排列要形式数组+链表+红黑树的数据结构。我们暂且给XXX一个名称叫”Node”，于是就是这样了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer key;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候有些哥们想，上面都是你主观的一个猜想，源码中真的是这样做的吗？我们不妨在HashMap类中搜索一下”Node”，发现有这样一个内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok，至此每个小格子表示的含义猜想和验证已经完成，发现源码中真的也有这样一个Node类，并且里面维护了key和value属性，至于其他属性是什么含义，我们后面再聊。</p><h1 id="3-Node的排列方式-数据结构"><a href="#3-Node的排列方式-数据结构" class="headerlink" title="3 Node的排列方式/数据结构"></a>3 Node的排列方式/数据结构</h1><p>上面既然已经验证了小格子对应的就是Node类，或者可以称为是Node节点。接下来我们的任务就是将这些节点来排列成数组+链表+红黑树的形式。</p><h2 id="3-1-数组"><a href="#3-1-数组" class="headerlink" title="3.1 数组"></a>3.1 数组</h2><p>想要将Node节点形式数组，按照以往的经验只需要在类中维护一个Node[]的属性即可，那么源码中是否有这样做呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment">    * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment">    * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment">    * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p>我们会发现源码中维护了这样一个成员变量，Node&lt;K,V&gt;[] table，这样数组的排列方式就解决了。</p><h2 id="3-2-链表"><a href="#3-2-链表" class="headerlink" title="3.2 链表"></a>3.2 链表</h2><p>链表无非就是Node节点和Node节点的关系的维护，这个关系可以分为单向链表或者双向链表，在前面的图解中我们发现这个链表是单向的，但是如果要想在源码中验证这个单向链表，只需要在原来的Node类中维护一个Node属性，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer key;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="keyword">private</span> Node next;    <span class="comment">//单向链表属性的维护</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那源码中是否是这样做的呢？通过下面代码中的Node&lt;K,V&gt; next属性可以发现的确是单向链表的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-红黑树"><a href="#3-3-红黑树" class="headerlink" title="3.3 红黑树"></a>3.3 红黑树</h2><p>红黑树是一种特殊的二叉树，对于二叉树我们比较熟悉，会有父节点，左子树，右子树等。</p><p>这时候我们会想，源码中是否有这样来做呢？搜索”TreeNode”，发现会有这样一段代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn</span></span><br><span class="line"><span class="comment">     * extends Node) so can be used as extension of either regular or</span></span><br><span class="line"><span class="comment">     * linked node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>跟我们的猜想是一样的，有表示父节点的parent属性，有表示左子树的left属性，还有表示右子树的right属性。</p><h2 id="3-4-总结"><a href="#3-4-总结" class="headerlink" title="3.4 总结"></a>3.4 总结</h2><p>通过上面3点源码的分析，可以感受到数组，链表和红黑树的代码，也就是能够验证HashMap1.8的数据结构是数组+链表+红黑树的实现方式。</p><h1 id="4-再看HashMap1-8源码"><a href="#4-再看HashMap1-8源码" class="headerlink" title="4 再看HashMap1.8源码"></a>4 再看HashMap1.8源码</h1><p>经过前面的分析，已经能够得到结论HashMap1.8果然是基于数组+链表+红黑树的方式实现的。</p><p>这时候再看HashMap1.8源码的实现就会很清晰。</p><p>当put(key,value)的时候，肯定先要创建数组，然后基于数组的下标索引创建出链表或者红黑树。这里有一点要注意，上述HashMap的数据结构图解是最终的效果图，但是在没有put任何数据之前，这个数据结构是什么都没有的，也就是一片空白，是需要经过一个个Node节点创建然后形成起来的。</p><p>所以先要创建出数组。</p><h2 id="4-1-数组的创建"><a href="#4-1-数组的创建" class="headerlink" title="4.1 数组的创建"></a>4.1 数组的创建</h2><p>在putVal方法中开始有这段代码。判断table是否为null，也就是Node[]数组是否为null，如果是，则需要先初始化数组的大小。初始化数组的大小是通过resize()方法，我们定位到resize()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br></pre></td></tr></table></figure><ul><li>resize()</li></ul><p>注意下面的代码截取的是resize()方法的间断性部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//再次判断数组是否为null，如果为null，则oldCap赋值为0</span></span><br><span class="line"><span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line"><span class="comment">//此时oldCap的判断会走这段逻辑</span></span><br><span class="line"><span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">    <span class="comment">//将DEFAULT_INITIAL_CAPACITY赋值给变量newCap</span></span><br><span class="line">   <span class="comment">//DEFAULT_INITIAL_CAPACITY值为16，指的是数组的默认大小，后面会具体说这个大小</span></span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    <span class="comment">//DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY===&gt;16*0.75=12</span></span><br><span class="line">    <span class="comment">//DEFAULT_LOAD_FACTOR值为0.75，得到的结果12是扩容的标准，这个值后面也会说</span></span><br><span class="line">    newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是根据这个默认数组的大小16初始化数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line"><span class="comment">//根据newCap=16初始化数组的大小，并且赋值给table，此时成员变量Node[]数组大小为16</span></span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br></pre></td></tr></table></figure><p>到这里，在上述的数据结构图解中，数组的部分就已经形成。但是里面还没有存元素，这个元素的类型前面我们已经分析过，应该是Node节点，换句话说也就是有key,value等这些组成的Node的对象。</p><h2 id="4-2-put之前Node节点位置的确定"><a href="#4-2-put之前Node节点位置的确定" class="headerlink" title="4.2 put之前Node节点位置的确定"></a>4.2 put之前Node节点位置的确定</h2><p>Node节点要想存储到上面初始化好的数组中，关键是到底存到哪个位置呢？上述数组初始化的大小为16，也就是Node节点到底是落在0-15索引的哪个位置。有哥们可能会想要不就从下标0开始存储？虽然是可行，但是问题是什么时候存储到1的位置呢？什么时候存储到2的位置呢？似乎这个界限不明确，还是放弃这样的想法。那怎么确定？要不这样，使用Random对象随机出一个0-15之间的数值？好像可以，如果是这样，万一不小心随机的数值一直是1和2，那最终可能只有1和2位置以及下面有Node节点，其他位置没有得到充分的利用，如下图所示。</p><p>这时候，1和2所在位置索引下面的节点就会很多。一方面看起来不美观其他位置没有得到充分的利用，另外一方面每次想要查询尾端的节点的值时，要经历过的过程必须知道前一个节点是什么，此时时间和空间复杂度比较高，所以Random这种产生Node节点位置的方式不合理。</p><p><img src="/images/image-20190304181624047.png" alt></p><ul><li>得到Node节点在数组中的位置</li></ul><p>经过上述尝试后，不妨这样，具体的位置由Node节点中的key本身来决定，也就是根据key来得到这个落点值。</p><p>我们可以将这个过程分为两步，第一：根据key得到一个整型数；第二：控制这个整形数在0-15之间。</p><p>（1）根据key得到整型数hash</p><p>key.hashCode():因为在Object类中有一个hashCode()方法，是一个native的方法，可以得到一个int类型的整型数，正好符合我们的想法。</p><p>我们暂且用一个int hash=key.hashCode()记录这个整型数的值，后面会调整。</p><p>（2）控制整型数hash的范围在0-15之间</p><p>int index=hash%16，此时index的结果就是0-15之间，后面这块也会调整。</p><p>至少目前为止这个落点我们能够计算出来了，虽然后面还会优化这块内容，但是思路是没错的。</p><ul><li>优化控制整型数hash的范围</li></ul><p>原来我们是通过hash%16这种方式，但是效率不够高，不妨一起来看下源码中是怎么做的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>可以发现，源码中是通过hash%(n-1)这种方式，而不是hash%n，注意这里的n是数组的大小，比如默认大小16。</p><p>先不管这样做的优势如何，也就是也得到0-15的数值，我们就将这个&amp;计算通过二进制来折腾一下。</p><p>hash:                     010100101010101010101010101                 32位</p><p>n-1:                                                                        01111                 15的二进制表示</p><hr><p>​                                        index</p><p>这个index最终结果最小值为00000，最大值为01111，换算成10进制，也就是0-15，即和hash%n的结果是一样的。那为什么作者使用的是&amp;运算而不是%运算呢？很简单，&amp;这样的效率更高，速度更快，这也是面试中很重要的一个点，大家一定要注意。</p><ul><li>优化hash值的计算方式</li></ul><p>原来hash的计算方式直接是key.hashCode()，得出的结果直接和n-1进行&amp;运算，得到index之后，就可以确定Node节点的位置了，但是这样真的好吗？其实index的结果真正取决于hash值，因为n-1是01111。</p><p>所以hash的值，或者说是hash二进制表示最后的几位决定了index的值，我们希望的是index的值尽可能不一样，这样数组每个索引位置能尽肯能得到充分的利用，雨露均沾嘛，不然index值重复的可能性太高的话，就会形成像原来Random设想的那种方案，一方面不美观，一方面影响时间和空间复杂度。</p><p>那么hash值的最后几位能否尽可能不一样呢？或者说源码中对hash的计算方式和我们原来认为的key.hashCode()是否一样呢？不妨一起来看下put方法调用的时候，有一个hash(key)函数，点开该方法代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会发现，它采用的是使用key.hashCode()的高16位和低16位异或的方式</p><p>0101010101001100100101010010101010原本是这样</p><p>01010101010011001</p><p>00101010010101010        ^</p><hr><p>​                           hash       这个hash结果采用的是key.hashCode()高低16位进行异或运算后的结果</p><p>也就是说这里让key.hashCode()的高16位和低16位都参与了运算，得到的hash值最后几位重复的可能性会大大降低，也就是hash(key)算法的设计。所以平时面试中问HashMap中hash算法的设计是怎样的，就是上面的这个过程。</p><p>同时到这里也解决了源码中Node类里面为什么有一个int hash的属性，其实这个属性就是保存的hash算法计算的结果值，这个值确定了，Node节点落点的位置就确定了，也就是按照面向对象的思想，Node节点最终落到哪个数组的位置它自己得知道。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;     <span class="comment">//保存hash函数最终计算的hash值</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-数组大小为什么是2的N次幂"><a href="#4-3-数组大小为什么是2的N次幂" class="headerlink" title="4.3 数组大小为什么是2的N次幂"></a>4.3 数组大小为什么是2的N次幂</h2><p>这时候我们先不着急看put下面的代码，不妨来看一下对于数组默认大小属性的定义。</p><p>不难发现，这个DEFAULT_INITIAL_CAPACITY采用的是位移运算，也就是1向左位移4位，也就是1后面加上4个0，也就是10000，换算成10进制，就是2的4次方，即16。</p><p>有哥们可能会想为什么采用位移运算？因为速度快。对于DEFAULT_INITIAL_CAPACITY上面有注释，意思是必须是2的N次幂，也就是数组的大小必须是2的N次幂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure><p>这时候来想想为什么呢？不妨再回到计算Node落点的(n-1)&amp;hash。</p><p>hash:                     010100101010101010101010101                 32位</p><p>n-1:                                                                        01111                 15的二进制表示</p><hr><p>​                                        index</p><p>我们上面说过，index的值尽可能的不要重复，不然最终Node节点都集中在一两个索引位置之下了。为了尽可能不重复，hash算法进行了高低16位的异或计算。n-1的值是01111所以index的结果实际上取决于hash的值，试想一下如果n-1不是01111，如果是01110会怎样？这时候hash的二进制结果最后一位无论是1还是0，index重复的可能性就会增加，所以必须保证n-1的结果是01111，换句话说必须保证n是10000这样的形式，也就是n[数组的大小]必须是2的N次幂。</p><ul><li>如果在初始化HashMap的时候传入的大小不是2的N次幂呢？</li></ul><p>总有人会不按照规则出牌，这时候就需要看HashMap的构造函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">    initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">    initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">    loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">//最终会调用tableSizeFor调整数组的大小</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继而来看tableSizeFor(initialCapacity)到底做了什么，我们会发现，这个方法会根据传入的cap得到一个2的N次幂的值作为数组的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-继续源码的put过程"><a href="#4-4-继续源码的put过程" class="headerlink" title="4.4 继续源码的put过程"></a>4.4 继续源码的put过程</h2><p>上面已经对数组进行了初始化，也得到了每个Node节点应该在的位置。</p><p>这时候比如真的来一个key和value，得到该Node节点应该在的位置，接下来的流程该是如何呢？肯定要判断原来数组该索引位置中是否有Node节点。若没有，则直接将该节点放到该位置；若有，有的话就再看咯。</p><p>我们先来看没有的时候，源码是怎么做的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">//直接根据hash,key,value创建出一个Node节点放到数组下标对应的位置</span></span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>如果有的话，则不能直接放到该位置，如下图所示</p><p><img src="/images/image-20190304191149132.png" alt></p><p>这个时候可以分为三种情况：</p><p>如果key值相同，只需要将原来下标位置的value值替换掉即可；</p><p>如果key值不同，则将新的节点放到原来索引节点的后面形成单向链表；</p><p>如果key值不同，原来索引下面已经是红黑树的数据结构了，则按照红黑树的数据结构将新的节点存储。</p><h3 id="4-4-1-仅仅替换value值"><a href="#4-4-1-仅仅替换value值" class="headerlink" title="4.4.1 仅仅替换value值"></a>4.4.1 仅仅替换value值</h3><p><img src="/images/image-20190304191626023.png" alt></p><p><code>代码实现</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; e; K k;</span><br><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">    <span class="comment">//使用一个临时变量e节点记录一下</span></span><br><span class="line">                e = p;</span><br></pre></td></tr></table></figure><p>如果最终e的值不为空，则使用新value替换老的value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-2-按照红黑树方式存储Node"><a href="#4-4-2-按照红黑树方式存储Node" class="headerlink" title="4.4.2 按照红黑树方式存储Node"></a>4.4.2 按照红黑树方式存储Node</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">    e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br></pre></td></tr></table></figure><h3 id="4-4-3-按链表方式存储Node"><a href="#4-4-3-按链表方式存储Node" class="headerlink" title="4.4.3 按链表方式存储Node"></a>4.4.3 按链表方式存储Node</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//循环遍历原来索引下链表，有可能原来已经是链表的数据结构了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//要把新的节点放到链表的最末尾的节点才行</span></span><br><span class="line">            <span class="comment">//所以这边要一直循环遍历到链表节点的next为null，说明已经到了末尾了</span></span><br><span class="line">            p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//如果链表的长度超过某个值，就将链表转红黑树，这块后面会说</span></span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在链表put的过程中同样也是判断key值是否相同</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        p = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-5-链表转红黑树"><a href="#4-5-链表转红黑树" class="headerlink" title="4.5 链表转红黑树"></a>4.5 链表转红黑树</h2><p>通过上述代码可以发现在链表put的过程中，如果链表太长会将其转成红黑树。我们先想想为什么要转？之前说如果index的结果一样，key值不同，会慢慢往Node节点往下延长形成链表的数据结构，但是对于链表而言，长度太长的话，存取效率会低，因为链表要想找到某个节点必须要知道它的上一个节点。</p><p>但是即使采用了hash算法，保证了数组的大小是2的N次幂，还是避免不了链表长度慢慢变长，这时候查询或者插入效率降低，怎么办呢？不妨这样将链表的结构变形成树形结构，如下图所示。</p><p><img src="/images/image-20190304192953352.png" alt></p><p>那转换的条件是什么呢？也就是链表到底多长才需要转呢？在源码中是怎样定义的？</p><p>也就是说链表节点长度超过8就需要转红黑树，如果红黑树中节点数目小于6就再转成链表。</p><p>而且之前在链表节点不断增加时候代码也是这样判断的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果链表的长度超过某个值，就将链表转红黑树，这块后面会说</span></span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                treeifyBin(tab, hash);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment"> * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment"> * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment"> * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment"> * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment"> * shrinkage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment"> * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment"> * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment"> * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment"> * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment"> * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="4-6-数组扩容的探讨"><a href="#4-6-数组扩容的探讨" class="headerlink" title="4.6 数组扩容的探讨"></a>4.6 数组扩容的探讨</h2><p>到这边想必大家都有点累了，此时把自己的脑袋给放空，只回想一个图，就是一开始HashMap的数据结构图，一张由数组+链表+红黑树的图。通过上述的分析，我们发现数组的索引位置会被Node节点占用，而且index相同的情况下还会形成链表或者红黑树的结构。试想有没有这样一种情况，就是数组的索引位置不够用了，或者说虽然可以不断往下形成链表或者红黑树，但是数组的大小难道就一直保持在16不变吗？比如Node节点已经像下面这样的分布了呢？</p><p>大家应该能明白我想表达的意思，这时候你会发现数据结构比较复杂，也不利于我们的存取节点了。所以得要指定一个标准，比如整个数据结构中节点的数量超过某个值之后就把数组的大小扩大一下，这样可以有效减轻节点的一个分布压力。就像是链表太长要转红黑树一样。那这个数组扩大的临界值怎么确定呢？</p><p><img src="/images/image-20190304193928061.png" alt></p><h3 id="4-6-1-扩容-加载因子"><a href="#4-6-1-扩容-加载因子" class="headerlink" title="4.6.1 扩容/加载因子"></a>4.6.1 扩容/加载因子</h3><p>在成员变量中有一个这样的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><h3 id="4-6-2-扩容标准"><a href="#4-6-2-扩容标准" class="headerlink" title="4.6.2 扩容标准"></a>4.6.2 扩容标准</h3><p>这个临界值的确定可以用数组大小*扩容因子，其实在数组初始化方法resize中我们见过这个公式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br></pre></td></tr></table></figure><p>这个newThr=16*0.75=12就是扩容的标准，在resize()方法中最终将这个赋值给了一个成员变量，赋值的过程如下所示，也就是说这个threshold等于12。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threshold = newThr;</span><br></pre></td></tr></table></figure><h3 id="4-6-3-扩容过程"><a href="#4-6-3-扩容过程" class="headerlink" title="4.6.3 扩容过程"></a>4.6.3 扩容过程</h3><p>每当put一个Node节点成功，最后会有这段代码的判断。</p><p>也就是说会通过一个成员变量size，默认值为0，记录每次put的次数，如果这个++size&gt;threshold[12]，之后就进行resize()操作，也就是进行扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">           resize();</span><br></pre></td></tr></table></figure><ul><li>数组的2倍扩容</li></ul><p>到这里，我们能够知道resize()除了有初始化数组的功能，还会有扩容的功能，而且这个扩容会2倍扩容，原因是要保证数组的大小必须是2的N次幂，原因前面已经说过咯。</p><p>判断数组的大小，此时数组大小是16。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br></pre></td></tr></table></figure><p>此时oldCap的大小则大于0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过向左位移1位将数组的大小*2</span></span><br><span class="line">    <span class="comment">//同时扩容的标准12也需要变成24，也就是oldThr&lt;&lt;1</span></span><br><span class="line">    <span class="comment">//这里采用位移也是因为效率高</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">        newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当新数组的大小变成32之后，就将新数组的大小创建成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br></pre></td></tr></table></figure><p>此时会面临一个问题，新创建数组中没有任何Node节点，我们需要将原来数组中的Node节点”搬运“到新的数组中，那怎么搬运呢？</p><ul><li>老数组中Node节点搬运到新数组中</li></ul><p>搬运要按照节点的类型来区分，我们可以采取这样的方式，先循环遍历原来数组的索引位置，要确保原来数组下表位置不为空才有必要进行搬运。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候可以分为3种情况。</p><p>（1）数组索引下标下面没有元素</p><p>这时候只需要使用hash值重新&amp;上新数组n-1的值，计算节点在新数组中的位置即可。</p><p><img src="/images/image-20190304213315800.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br></pre></td></tr></table></figure><p>（2）数组索引下标下面有元素，且元素类型为红黑树</p><p>如果索引下面的节点类型是红黑树，则按照红黑树的方式将Node节点切分，然后移动到新的数组中。</p><p><img src="/images/image-20190304213236203.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br></pre></td></tr></table></figure><p>（3）数组索引下标下面有所愿，且元素类型为链表</p><p><img src="/images/image-20190304213353962.png" alt></p><p>这种情况表示原数组索引下面的节点类型为链表，此时要循环遍历链表，使用的是do-while循环。</p><p>下面这段代码最重要的其实是这句话</p><p><code>if ((e.hash &amp; oldCap) == 0)</code>，也就是这块会计算链表中每个节点的hash&amp;oldCap的值，最终结果和0比较，根据结果进行不同的处理，那么这种结果什么时候为0，什么时候不为0呢?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        next = e.next;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">        newTab[j] = loHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">        newTab[j + oldCap] = hiHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把if ((e.hash &amp; oldCap) == 0)这个计算公式写出来</p><p>hash:                 010010101001100101010101101010</p><p>oldCap:                                                                    10000     &amp;</p><hr><p>​                                                                                 result</p><p>上述result到底何时才为0？细心的哥们会发现只有hash的倒数第5位位0的时候，结果才会0，否则结果不为0，而且为0的时候result和不为0的result相差是10000，也就是16，也就是oldCap的大小。</p><p>本来要移动老数组中链表的Node节点要重新计算hash&amp;(n-1)的值，但是此时只要知道hash的倒数第5位是否为0，就能知道本来应该计算的结果。</p><p>如果hash二进制表示倒数第5位为0，即使采用hash&amp;(n-1)的结果还是和原来index一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">        loHead = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        loTail.next = e;</span><br><span class="line">    loTail = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果hash二进制表示倒数第5位为1，那么采用hash&amp;(n-1)的结果就会比原来index大oldCap的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">        hiHead = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        hiTail.next = e;</span><br><span class="line">    hiTail = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实上述两段代码形成的最终结果是，也就是节点在新的数组中的位置要么是在原来位置，要么是在原来位置+oldCap的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">    loTail.next = <span class="keyword">null</span>;</span><br><span class="line">    newTab[j] = loHead;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">    hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">    newTab[j + oldCap] = hiHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><p>通过本文分析，我们了解了HashMap1.8的数据结构以及源码原理源码实现，包括hash算法，put过程，加载因子，扩容等，希望对大家有所帮助。如若有不对之处，欢迎大家一起探讨交流，谢谢。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于HashMap想必大家都不陌生，无论是平时code还是面试都经常和它打交道。今天我们通过源码的层面来分析一下它的实现原理，注意本文基于的是JDK1.8。&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="https://istio.tech/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="源码分析" scheme="https://istio.tech/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="HashMap" scheme="https://istio.tech/tags/HashMap/"/>
    
      <category term="红黑树" scheme="https://istio.tech/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析系列之Invoker及服务注册</title>
    <link href="https://istio.tech/2019/07/28/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BInvoker%E5%8F%8A%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/"/>
    <id>https://istio.tech/2019/07/28/Dubbo源码分析系列之Invoker及服务注册/</id>
    <published>2019-07-28T15:08:00.000Z</published>
    <updated>2019-07-28T15:09:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>分析服务发布过程中所构建的Invoker，以及服务注册的流程</p><a id="more"></a><h1 id="Invoker是什么"><a href="#Invoker是什么" class="headerlink" title="Invoker是什么"></a>Invoker是什么</h1><p>从前面的分析来看，服务的发布分三个阶段</p><p>第一个阶段会创造一个invoker</p><p>第二个阶段会把经历过一系列处理的invoker（各种包装），在DubboProtocol中保存到exporterMap中</p><p>第三个阶段把dubbo协议的url地址注册到注册中心上</p><p>前面没有分析Invoker，我们来简单看看Invoker到底是一个啥东西。</p><p>Invoker是Dubbo领域模型中非常重要的一个概念, 和ExtensionLoader的重要性是一样的，如果Invoker没有搞懂，那么不算是看懂了Dubbo的源码。我们继续回到ServiceConfig中export的代码，这段代码是还没有分析过的。以这个作为入口来分析我们前面export出去的invoker到底是啥东西</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));</span><br></pre></td></tr></table></figure><h2 id="ProxyFacotory-getInvoker"><a href="#ProxyFacotory-getInvoker" class="headerlink" title="ProxyFacotory.getInvoker"></a>ProxyFacotory.getInvoker</h2><p>这个是一个代理工程，用来生成invoker，从它的定义来看，它是一个自适应扩展点，看到这样的扩展点，我们几乎可以不假思索的想到它会存在一个动态适配器类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();</span><br></pre></td></tr></table></figure><h2 id="ProxyFactory"><a href="#ProxyFactory" class="headerlink" title="ProxyFactory"></a>ProxyFactory</h2><p>这个方法的简单解读为： 它是一个spi扩展点，并且默认的扩展实现是javassit, 这个接口中有三个方法，并且都是加了@Adaptive的自适应扩展点。所以如果调用getInvoker方法，应该会返回一个ProxyFactory$Adaptive</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"javassist"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, <span class="keyword">boolean</span> generic)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException</span>;</span><br></pre></td></tr></table></figure><h2 id="ProxyFactory-Adaptive"><a href="#ProxyFactory-Adaptive" class="headerlink" title="ProxyFactory$Adaptive"></a>ProxyFactory$Adaptive</h2><p>这个自适应扩展点，做了两件事情</p><ul><li>通过ExtensionLoader.getExtensionLoader(ProxyFactory.class).getExtension(extName)获取了一个指定名称的扩展点,</li><li>在dubbo-rpc-api/resources/META-INF/com.alibaba.dubbo.rpc.ProxyFactory中，定义了javassis=JavassisProxyFactory</li><li>调用JavassisProxyFactory的getInvoker方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">dubbo</span>.<span class="title">rpc</span>.<span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">getProxy</span><span class="params">(org.apache.dubbo.rpc.Invoker arg0)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.Invoker argument == null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg0.getUrl() == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.Invoker argument getUrl() == null"</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class="line">        String extName = url.getParameter(<span class="string">"proxy"</span>, <span class="string">"javassist"</span>);</span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.rpc.ProxyFactory) name from url ("</span> + url.toString() + <span class="string">") use keys([proxy])"</span>);</span><br><span class="line">        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.getProxy(arg0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">getProxy</span><span class="params">(org.apache.dubbo.rpc.Invoker arg0, <span class="keyword">boolean</span> arg1)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.Invoker argument == null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg0.getUrl() == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.Invoker argument getUrl() == null"</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class="line">        String extName = url.getParameter(<span class="string">"proxy"</span>, <span class="string">"javassist"</span>);</span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.rpc.ProxyFactory) name from url ("</span> + url.toString() + <span class="string">") use keys([proxy])"</span>);</span><br><span class="line">        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.getProxy(arg0, arg1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.<span class="function">Invoker <span class="title">getInvoker</span><span class="params">(java.lang.Object arg0, java.lang.Class arg1, org.apache.dubbo.common.URL arg2)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg2 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg2;</span><br><span class="line">        String extName = url.getParameter(<span class="string">"proxy"</span>, <span class="string">"javassist"</span>);</span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.rpc.ProxyFactory) name from url ("</span> + url.toString() + <span class="string">") use keys([proxy])"</span>);</span><br><span class="line">        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.getInvoker(arg0, arg1, arg2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavassistProxyFactory-getInvoker"><a href="#JavassistProxyFactory-getInvoker" class="headerlink" title="JavassistProxyFactory.getInvoker"></a>JavassistProxyFactory.getInvoker</h2><p>javassist是一个动态类库，用来实现动态代理的。</p><p>proxy:接口的实现: com.gupaoedu.practice.dubbo.SayHelloServiceImpl</p><p>type:接口全称 com.gupaoedu.dubbo.ISayHelloService</p><p>url:协议地址：registry://…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Wrapper cannot handle this scenario correctly: the classname contains '$'</span></span><br><span class="line">        <span class="keyword">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class="string">'$'</span>) &lt; <span class="number">0</span> ? proxy.getClass() : type);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Object[] arguments)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="javassist生成的动态代理代码"><a href="#javassist生成的动态代理代码" class="headerlink" title="javassist生成的动态代理代码"></a>javassist生成的动态代理代码</h2><p>通过断点的方式（Wrapper258行），在Wrapper.getWrapper中的makeWrapper，会创建一个动态代理，核心的方法invokeMethod代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invokeMethod</span><span class="params">(Object o, String n, Class[] p, Object[] v)</span> <span class="keyword">throws</span> java.lang.reflect.InvocationTargetException </span>&#123;</span><br><span class="line">        com.gupaoedu.dubbo.practice.ISayHelloService w;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            w = ((com.gupaoedu.dubbo.practice.ISayHelloService) $<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"sayHello"</span>.equals($<span class="number">2</span>) &amp;&amp; $<span class="number">3</span>.length == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ($w) w.sayHello((java.lang.String) $<span class="number">4</span>[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.lang.reflect.InvocationTargetException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> org.apache.dubbo.common.bytecode.NoSuchMethodException(<span class="string">"Not found method \""</span> + $<span class="number">2</span> + <span class="string">"\" in class com.gupaoedu.dubbo.practice.ISayHelloService."</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>构建好了代理类之后，返回一个AbstractproxyInvoker,并且它实现了doInvoke方法，这个地方似乎看到了dubbo消费者调用过来的时候触发的影子，因为wrapper.invokeMethod本质上就是触发上面动态代理类的方法invokeMethod.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Object[] arguments)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>所以，简单总结一下Invoke本质上应该是一个代理，经过层层包装最终进行了发布。当消费者发起请求的时候，会获得这个invoker进行调用。</p><p>最终发布出去的invoker, 也不是单纯的一个代理，也是经过多层包装</p><p>InvokerDelegate(DelegateProviderMetaDataInvoker(AbstractProxyInvoker()))</p><h1 id="服务注册流程"><a href="#服务注册流程" class="headerlink" title="服务注册流程"></a>服务注册流程</h1><p>关于服务发布这一条线分析完成之后，再来了解一下服务注册的过程，希望大家还记得我们之所以走到这一步，是因为我们在RegistryProtocol这个类中，看到了服务发布的流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class="line">        <span class="comment">// url to export locally</span></span><br><span class="line">        URL providerUrl = getProviderUrl(originInvoker);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Subscribe the override data</span></span><br><span class="line">        <span class="comment">// FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call</span></span><br><span class="line">        <span class="comment">//  the same service. Because the subscribed is cached key with the name of the service, it causes the</span></span><br><span class="line">        <span class="comment">//  subscription information to cover.</span></span><br><span class="line">        <span class="keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(providerUrl);</span><br><span class="line">        <span class="keyword">final</span> OverrideListener overrideSubscribeListener = <span class="keyword">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class="line">        overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line"></span><br><span class="line">        providerUrl = overrideUrlWithConfig(providerUrl, overrideSubscribeListener);</span><br><span class="line">        <span class="comment">//export invoker</span></span><br><span class="line">        <span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker, providerUrl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// url to registry</span></span><br><span class="line">        <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line">        <span class="keyword">final</span> URL registeredProviderUrl = getRegisteredProviderUrl(providerUrl, registryUrl);</span><br><span class="line">        ProviderInvokerWrapper&lt;T&gt; providerInvokerWrapper = ProviderConsumerRegTable.registerProvider(originInvoker,</span><br><span class="line">                registryUrl, registeredProviderUrl);</span><br><span class="line">        <span class="comment">//to judge if we need to delay publish</span></span><br><span class="line">        <span class="keyword">boolean</span> register = registeredProviderUrl.getParameter(<span class="string">"register"</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (register) &#123;</span><br><span class="line">            register(registryUrl, registeredProviderUrl);</span><br><span class="line">            providerInvokerWrapper.setReg(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Deprecated! Subscribe to override rules in 2.6.x or before.</span></span><br><span class="line">        registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line"></span><br><span class="line">        exporter.setRegisterUrl(registeredProviderUrl);</span><br><span class="line">        exporter.setSubscribeUrl(overrideSubscribeUrl);</span><br><span class="line">        <span class="comment">//Ensure that a new exporter instance is returned every time export</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DestroyableExporter&lt;&gt;(exporter);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="服务注册核心代码"><a href="#服务注册核心代码" class="headerlink" title="服务注册核心代码"></a>服务注册核心代码</h2><p>从export方法中抽离出来的部分代码，就是服务注册的流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// url to registry</span></span><br><span class="line">        <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line">        <span class="keyword">final</span> URL registeredProviderUrl = getRegisteredProviderUrl(providerUrl, registryUrl);</span><br><span class="line">        ProviderInvokerWrapper&lt;T&gt; providerInvokerWrapper = ProviderConsumerRegTable.registerProvider(originInvoker,</span><br><span class="line">                registryUrl, registeredProviderUrl);</span><br><span class="line">        <span class="comment">//to judge if we need to delay publish</span></span><br><span class="line">        <span class="keyword">boolean</span> register = registeredProviderUrl.getParameter(<span class="string">"register"</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (register) &#123;</span><br><span class="line">            register(registryUrl, registeredProviderUrl);</span><br><span class="line">            providerInvokerWrapper.setReg(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="getRegistry"><a href="#getRegistry" class="headerlink" title="getRegistry"></a>getRegistry</h2><ol><li>把url转化为对应配置的注册中心的具体协议</li><li>根据具体协议，从registryFactory中获得指定的注册中心实现</li></ol><p>那么这个registryFactory具体是怎么赋值的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Registry <span class="title">getRegistry</span><span class="params">(<span class="keyword">final</span> Invoker&lt;?&gt; originInvoker)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把url转化为配置的具体协议，比如zookeeper://ip:port. 这样后续获得的注册中心就会是基于zk的实现</span></span><br><span class="line">        URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class="line">        <span class="keyword">return</span> registryFactory.getRegistry(registryUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在RegistryProtocol中存在一段这样的代码，很明显这是通过依赖注入来实现的扩展点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RegistryFactory registryFactory; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRegistryFactory</span><span class="params">(RegistryFactory registryFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.registryFactory = registryFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照扩展点的加载规则，我们可以先看看/META-INF/dubbo/internal路径下找到RegistryFactory的配置文件.这个factory有多个扩展点的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dubbo=org.apache.dubbo.registry.dubbo.DubboRegistryFactory</span><br><span class="line">multicast=org.apache.dubbo.registry.multicast.MulticastRegistryFactory</span><br><span class="line">zookeeper=org.apache.dubbo.registry.zookeeper.ZookeeperRegistryFactory</span><br><span class="line">redis=org.apache.dubbo.registry.redis.RedisRegistryFactory</span><br><span class="line">consul=org.apache.dubbo.registry.consul.ConsulRegistryFactory</span><br><span class="line"></span><br><span class="line">etcd3=org.apache.dubbo.registry.etcd.EtcdRegistryFactory</span><br></pre></td></tr></table></figure><p>接着，找到RegistryFactory的实现, 发现它里面有一个自适应的方法，根据url中protocol传入的值进行适配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"dubbo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RegistryFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;<span class="string">"protocol"</span>&#125;)</span><br><span class="line">    <span class="function">Registry <span class="title">getRegistry</span><span class="params">(URL url)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="RegistryFactory-Adaptive"><a href="#RegistryFactory-Adaptive" class="headerlink" title="RegistryFactory$Adaptive"></a>RegistryFactory$Adaptive</h2><p>由于在前面的代码中，url中的protocol已经改成了zookeeper，那么这个时候根据zookeeper获得的spi扩展点应该是ZookeeperRegistryFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegistryFactory</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">dubbo</span>.<span class="title">registry</span>.<span class="title">RegistryFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.registry.<span class="function">Registry <span class="title">getRegistry</span><span class="params">(org.apache.dubbo.common.URL arg0)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg0;</span><br><span class="line">        String extName = ( url.getProtocol() == <span class="keyword">null</span> ? <span class="string">"dubbo"</span> : url.getProtocol() );</span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.registry.RegistryFactory) name from url ("</span> + url.toString() + <span class="string">") use keys([protocol])"</span>);</span><br><span class="line">        org.apache.dubbo.registry.RegistryFactory extension = (org.apache.dubbo.registry.RegistryFactory)ExtensionLoader.getExtensionLoader(org.apache.dubbo.registry.RegistryFactory.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.getRegistry(arg0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ZookeeperRegistryFactory"><a href="#ZookeeperRegistryFactory" class="headerlink" title="ZookeeperRegistryFactory"></a>ZookeeperRegistryFactory</h2><p>这个方法中并没有getRegistry方法，而是在父类AbstractRegistryFactory</p><ul><li>从缓存REGISTRIES中，根据key获得对应的Registry</li><li>如果不存在，则创建Registry</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Registry <span class="title">getRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        url = URLBuilder.from(url)</span><br><span class="line">                .setPath(RegistryService.class.getName())</span><br><span class="line">                .addParameter(Constants.INTERFACE_KEY, RegistryService.class.getName())</span><br><span class="line">                .removeParameters(Constants.EXPORT_KEY, Constants.REFER_KEY)</span><br><span class="line">                .build();</span><br><span class="line">        String key = url.toServiceStringWithoutResolving();</span><br><span class="line">        <span class="comment">// Lock the registry access process to ensure a single instance of the registry</span></span><br><span class="line">        LOCK.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Registry registry = REGISTRIES.get(key);</span><br><span class="line">            <span class="keyword">if</span> (registry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> registry;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//创建注册中心</span></span><br><span class="line">            registry = createRegistry(url);</span><br><span class="line">            <span class="keyword">if</span> (registry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Can not create registry "</span> + url);</span><br><span class="line">            &#125;</span><br><span class="line">            REGISTRIES.put(key, registry);</span><br><span class="line">            <span class="keyword">return</span> registry;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Release the lock</span></span><br><span class="line">            LOCK.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="createRegistry"><a href="#createRegistry" class="headerlink" title="createRegistry"></a>createRegistry</h2><p>创建一个zookeeperRegistry，把url和zookeepertransporter作为参数传入。</p><p>zookeeperTransporter 这个属性也是基于依赖注入来赋值的，具体的流程就不再分析了，这个的值应该是</p><p><code>CuratorZookeeperTransporter</code> 表示具体使用什么框架来和zk产生连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Registry <span class="title">createRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ZookeeperRegistry(url, zookeeperTransporter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ZookeeperRegistry"><a href="#ZookeeperRegistry" class="headerlink" title="ZookeeperRegistry"></a>ZookeeperRegistry</h2><p>这个方法中使用了CuratorZookeeperTransport来实现zk的连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZookeeperRegistry</span><span class="params">(URL url, ZookeeperTransporter zookeeperTransporter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(url);</span><br><span class="line">        <span class="keyword">if</span> (url.isAnyHost()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"registry address == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//获得group名称</span></span><br><span class="line">        String group = url.getParameter(Constants.GROUP_KEY, DEFAULT_ROOT);</span><br><span class="line">        <span class="keyword">if</span> (!group.startsWith(Constants.PATH_SEPARATOR)) &#123;</span><br><span class="line">            group = Constants.PATH_SEPARATOR + group;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.root = group;</span><br><span class="line">    <span class="comment">//产生一个zookeeper连接</span></span><br><span class="line">        zkClient = zookeeperTransporter.connect(url);</span><br><span class="line">    <span class="comment">//添加zookeeper状态变化事件</span></span><br><span class="line">        zkClient.addStateListener(state -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (state == StateListener.RECONNECTED) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    recover();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    logger.error(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="registry-register-registedProviderUrl"><a href="#registry-register-registedProviderUrl" class="headerlink" title="registry.register(registedProviderUrl);"></a>registry.register(registedProviderUrl);</h2><p>继续往下分析，会调用registry.register去讲dubbo://的协议地址注册到zookeeper上</p><p>这个方法会调用FailbackRegistry类中的register. 为什么呢？因为ZookeeperRegistry这个类中并没有register这个方法，但是他的父类FailbackRegistry中存在register方法，而这个类又重写了AbstractRegistry类中的register方法。所以我们可以直接定位大FailbackRegistry这个类中的register方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">register(registryUrl, registeredProviderUrl);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL registryUrl, URL registeredProviderUrl)</span> </span>&#123;</span><br><span class="line">        Registry registry = registryFactory.getRegistry(registryUrl);</span><br><span class="line">        registry.register(registeredProviderUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FailbackRegistry-register"><a href="#FailbackRegistry-register" class="headerlink" title="FailbackRegistry.register"></a>FailbackRegistry.register</h2><ul><li>FailbackRegistry，从名字上来看，是一个失败重试机制</li><li>调用父类的register方法，讲当前url添加到缓存集合中</li></ul><p>调用doRegister方法，这个方法很明显，是一个抽象方法，会由ZookeeperRegistry子类实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.register(url);</span><br><span class="line">        removeFailedRegistered(url);</span><br><span class="line">        removeFailedUnregistered(url);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用子类实现真正的服务注册，把url注册到zk上</span></span><br><span class="line">            doRegister(url);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Throwable t = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果开启了启动时检测，则直接抛出异常</span></span><br><span class="line">            <span class="keyword">boolean</span> check = getUrl().getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)</span><br><span class="line">                    &amp;&amp; url.getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)</span><br><span class="line">                    &amp;&amp; !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol());</span><br><span class="line">            <span class="keyword">boolean</span> skipFailback = t <span class="keyword">instanceof</span> SkipFailbackWrapperException;</span><br><span class="line">            <span class="keyword">if</span> (check || skipFailback) &#123;</span><br><span class="line">                <span class="keyword">if</span> (skipFailback) &#123;</span><br><span class="line">                    t = t.getCause();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to register "</span> + url + <span class="string">" to registry "</span> + getUrl().getAddress() + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.error(<span class="string">"Failed to register "</span> + url + <span class="string">", waiting for retry, cause: "</span> + t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将失败的注册请求记录到失败列表，定时重试</span></span><br><span class="line">            addFailedRegistered(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="ZookeeperRegistry-doRegister"><a href="#ZookeeperRegistry-doRegister" class="headerlink" title="ZookeeperRegistry.doRegister"></a>ZookeeperRegistry.doRegister</h2><p>最终调用curator的客户端把服务地址注册到zk</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, <span class="keyword">true</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to register "</span> + url + <span class="string">" to zookeeper "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="思考服务消费应该要具备的逻辑"><a href="#思考服务消费应该要具备的逻辑" class="headerlink" title="思考服务消费应该要具备的逻辑"></a>思考服务消费应该要具备的逻辑</h1><p>如果要实现服务的消费，大家可以结合之前手写rpc的课程来思考一下</p><ol><li>生成远程服务的代理</li><li>获得目标服务的url地址</li><li>实现远程网络通信</li><li>实现负载均衡</li><li>实现集群容错</li></ol><p><img src="http://dubbo.apache.org/docs/zh-cn/dev/sources/images/dubbo_rpc_refer.jpg" alt="/dev-guide/images/dubbo_rpc_refer.jpg"></p><h1 id="服务的消费"><a href="#服务的消费" class="headerlink" title="服务的消费"></a>服务的消费</h1><p>消费端的代码解析是从下面这段代码开始的</p><p><code>&lt;dubbo:reference id=&quot;xxxService&quot; interface=&quot;xxx.xxx.Service&quot;/&gt;</code></p><p>注解的方式的初始化入口是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReferenceAnnotationBeanPostProcessor-&gt;ReferenceBeanInvocationHandler.init-&gt;ReferenceConfig.get() 获得一个远程代理类</span><br></pre></td></tr></table></figure><h2 id="ReferenceConfig-get"><a href="#ReferenceConfig-get" class="headerlink" title="ReferenceConfig.get"></a>ReferenceConfig.get</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkAndUpdateSubConfigs(); <span class="comment">//检查和修改配置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The invoker of ReferenceConfig("</span> + url + <span class="string">") has already destroyed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ref == <span class="keyword">null</span>) &#123; <span class="comment">//如果当前接口的远程代理引用为空，则进行初始化</span></span><br><span class="line">            init();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ref;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><p>初始化的过程，和服务发布的过程类似，会有特别多的判断以及参数的组装. 我们只需要关注createProxy，创建代理类的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line"> ref = createProxy(map);   </span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="createProxy"><a href="#createProxy" class="headerlink" title="createProxy"></a>createProxy</h2><p>代码比较长，但是逻辑相对比较清晰</p><ol><li>判断是否为本地调用，如果是则使用injvm协议进行调用</li><li>判断是否为点对点调用，如果是则把url保存到urls集合中，如果url为1，进入步骤4，如果urls&gt;1 ，则执行5</li><li>如果是配置了注册中心，遍历注册中心，把url添加到urls集合，url为1，进入步骤4，如果urls&gt;1 ，则执行5</li><li>直连构建invoker</li><li>构建invokers集合，通过cluster合并多个invoker</li><li>最后调用 ProxyFactory 生成代理类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createProxy</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldJvmRefer(map)) &#123; <span class="comment">//判断是否是在同一个jvm进程中调用</span></span><br><span class="line">            URL url = <span class="keyword">new</span> URL(Constants.LOCAL_PROTOCOL, Constants.LOCALHOST_VALUE, <span class="number">0</span>, interfaceClass.getName()).addParameters(map);</span><br><span class="line">            invoker = refprotocol.refer(interfaceClass, url);</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"Using injvm service "</span> + interfaceClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//url 如果不为空，说明是点对点通信</span></span><br><span class="line">            <span class="keyword">if</span> (url != <span class="keyword">null</span> &amp;&amp; url.length() &gt; <span class="number">0</span>) &#123; <span class="comment">// user specified URL, could be peer-to-peer address, or register center's address.</span></span><br><span class="line">                String[] us = Constants.SEMICOLON_SPLIT_PATTERN.split(url);</span><br><span class="line">                <span class="keyword">if</span> (us != <span class="keyword">null</span> &amp;&amp; us.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String u : us) &#123;</span><br><span class="line">                        URL url = URL.valueOf(u);</span><br><span class="line">                        <span class="keyword">if</span> (StringUtils.isEmpty(url.getPath())) &#123;</span><br><span class="line">                            url = url.setPath(interfaceName);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 检测 url 协议是否为 registry，若是，表明用户想使用指定的注册中心</span></span><br><span class="line">                        <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">                             <span class="comment">// 将 map 转换为查询字符串，并作为 refer 参数的值添加到 url 中</span></span><br><span class="line">                            urls.add(url.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 合并 url，移除服务提供者的一些配置（这些配置来源于用户配置的 url 属性），</span></span><br><span class="line">                        <span class="comment">// 比如线程池相关配置。并保留服务提供者的部分配置，比如版本，group，时间戳等</span></span><br><span class="line">                        <span class="comment">// 最后将合并后的配置设置为 url 查询字符串中。</span></span><br><span class="line">                            urls.add(ClusterUtils.mergeUrl(url, map));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// assemble URL from register center's configuration</span></span><br><span class="line">                checkRegistry(); <span class="comment">//校验注册中心的配置以及是否有必要从配置中心组装url</span></span><br><span class="line">                <span class="comment">//这里的代码实现和服务端类似，也是根据注册中心配置进行解析得到URL</span></span><br><span class="line">      <span class="comment">//这里的URL肯定也是： registry://ip:port/org.apache.dubbo.service.RegsitryService</span></span><br><span class="line">                List&lt;URL&gt; us = loadRegistries(<span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (CollectionUtils.isNotEmpty(us)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (URL u : us) &#123;</span><br><span class="line">                        URL monitorUrl = loadMonitor(u);</span><br><span class="line">                        <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));</span><br><span class="line">                        &#125;</span><br><span class="line">                        urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果没有配置注册中心，则报错</span></span><br><span class="line">                <span class="keyword">if</span> (urls.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No such any registry to reference "</span> + interfaceName + <span class="string">" on the consumer "</span> + NetUtils.getLocalHost() + <span class="string">" use dubbo version "</span> + Version.getVersion() + <span class="string">", please config &lt;dubbo:registry address=\"...\" /&gt; to your spring config."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//如果值配置了一个注册中心或者一个服务提供者，直接使用refprotocol.refer</span></span><br><span class="line">            <span class="keyword">if</span> (urls.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                invoker = refprotocol.refer(interfaceClass, urls.get(<span class="number">0</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                List&lt;Invoker&lt;?&gt;&gt; invokers = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;?&gt;&gt;();</span><br><span class="line">                URL registryURL = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (URL url : urls) &#123;<span class="comment">//遍历urls生成多个invoker</span></span><br><span class="line">                    invokers.add(refprotocol.refer(interfaceClass, url));</span><br><span class="line">                    <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">                        registryURL = url; <span class="comment">// use last registry url</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (registryURL != <span class="keyword">null</span>) &#123; <span class="comment">//如果registryUrl不为空，构建静态directory</span></span><br><span class="line">                    <span class="comment">// 使用RegistryAwareCluster</span></span><br><span class="line">                    URL u = registryURL.addParameter(Constants.CLUSTER_KEY, RegistryAwareCluster.NAME);</span><br><span class="line">                    <span class="comment">// 通过Cluster将多个invoker合并 RegistryAwareClusterInvoker(StaticDirectory) -&gt; FailoverClusterInvoker(RegistryDirectory, will execute route) -&gt; Invoker</span></span><br><span class="line">                    invoker = cluster.join(<span class="keyword">new</span> StaticDirectory(u, invokers));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                    invoker = cluster.join(<span class="keyword">new</span> StaticDirectory(invokers));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//检查invoker的有效性</span></span><br><span class="line">        <span class="keyword">if</span> (shouldCheck() &amp;&amp; !invoker.isAvailable()) &#123;</span><br><span class="line">            <span class="comment">// make it possible for consumer to retry later if provider is temporarily unavailable</span></span><br><span class="line">            initialized = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to check the status of the service "</span> + interfaceName + <span class="string">". No provider available for the service "</span> + (group == <span class="keyword">null</span> ? <span class="string">""</span> : group + <span class="string">"/"</span>) + interfaceName + (version == <span class="keyword">null</span> ? <span class="string">""</span> : <span class="string">":"</span> + version) + <span class="string">" from the url "</span> + invoker.getUrl() + <span class="string">" to the consumer "</span> + NetUtils.getLocalHost() + <span class="string">" use dubbo version "</span> + Version.getVersion());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Refer dubbo service "</span> + interfaceClass.getName() + <span class="string">" from url "</span> + invoker.getUrl());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@since</span> 2.7.0</span></span><br><span class="line"><span class="comment">         * ServiceData Store</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        MetadataReportService metadataReportService = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((metadataReportService = getMetadataReportService()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            URL consumerURL = <span class="keyword">new</span> URL(Constants.CONSUMER_PROTOCOL, map.remove(Constants.REGISTER_IP_KEY), <span class="number">0</span>, map.get(Constants.INTERFACE_KEY), map);</span><br><span class="line">            metadataReportService.publishConsumer(consumerURL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// create service proxy</span></span><br><span class="line">        <span class="keyword">return</span> (T) proxyFactory.getProxy(invoker);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="protocol-refer"><a href="#protocol-refer" class="headerlink" title="protocol.refer"></a>protocol.refer</h2><p>这里通过指定的协议来调用refer生成一个invoker对象，invoker前面讲过，它是一个代理对象。那么在当前的消费端而言，invoker主要用于执行远程调用。</p><p>这个protocol，又是一个自适应扩展点，它得到的是一个Protocol$Adaptive.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Protocol refprotocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension()</span><br></pre></td></tr></table></figure><p>这段代码中，根据当前的协议url，得到一个指定的扩展点，传递进来的参数中，协议地址为registry://，所以，我们可以直接定位到RegistryProtocol.refer代码</p><blockquote><p><strong>Protocol$Adaptive中的refer方法</strong></p></blockquote><p>根据当前的协议扩展名registry, 获得一个被包装过的RegistryProtocol</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> org.apache.dubbo.rpc.<span class="function">Invoker <span class="title">refer</span><span class="params">(java.lang.Class arg0, org.apache.dubbo.common.URL arg1)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg1 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg1;</span><br><span class="line">        String extName = ( url.getProtocol() == <span class="keyword">null</span> ? <span class="string">"dubbo"</span> : url.getProtocol() );</span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url ("</span> + url.toString() + <span class="string">") use keys([protocol])"</span>);</span><br><span class="line">        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.refer(arg0, arg1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="RegistryProtocol-refer"><a href="#RegistryProtocol-refer" class="headerlink" title="RegistryProtocol.refer"></a>RegistryProtocol.refer</h2><p>这里面的代码逻辑比较简单</p><ul><li>组装注册中心协议的url</li><li>判断是否配置legroup，如果有，则cluster=getMergeableCluster()，构建invoker</li><li>doRefer构建invoker</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">//这段代码也很熟悉，就是根据配置的协议，生成注册中心的url: zookeeper://</span></span><br><span class="line">       url = URLBuilder.from(url)</span><br><span class="line">               .setProtocol(url.getParameter(REGISTRY_KEY, DEFAULT_REGISTRY))</span><br><span class="line">               .removeParameter(REGISTRY_KEY)</span><br><span class="line">               .build();</span><br><span class="line">       Registry registry = registryFactory.getRegistry(url);</span><br><span class="line">       <span class="keyword">if</span> (RegistryService.class.equals(type)) &#123;</span><br><span class="line">           <span class="keyword">return</span> proxyFactory.getInvoker((T) registry, type, url);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 解析group参数，根据group决定cluster的类型</span></span><br><span class="line">       Map&lt;String, String&gt; qs = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY));</span><br><span class="line">       String group = qs.get(Constants.GROUP_KEY);</span><br><span class="line">       <span class="keyword">if</span> (group != <span class="keyword">null</span> &amp;&amp; group.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> ((COMMA_SPLIT_PATTERN.split(group)).length &gt; <span class="number">1</span> || <span class="string">"*"</span>.equals(group)) &#123;</span><br><span class="line">               <span class="keyword">return</span> doRefer(getMergeableCluster(), registry, type, url);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> doRefer(cluster, registry, type, url);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="doRefer"><a href="#doRefer" class="headerlink" title="doRefer"></a>doRefer</h2><p>doRefer里面就稍微复杂一些，涉及到比较多的东西，我们先关注主线</p><ul><li>构建一个RegistryDirectory</li><li>构建一个consumer://协议的地址注册到注册中心</li><li>订阅zookeeper中节点的变化</li><li>调用cluster.join方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doRefer</span><span class="params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//RegistryDirectory初始化</span></span><br><span class="line">        RegistryDirectory&lt;T&gt; directory = <span class="keyword">new</span> RegistryDirectory&lt;T&gt;(type, url);</span><br><span class="line">        directory.setRegistry(registry);</span><br><span class="line">        directory.setProtocol(protocol);</span><br><span class="line">        <span class="comment">// all attributes of REFER_KEY</span></span><br><span class="line">        Map&lt;String, String&gt; parameters = <span class="keyword">new</span> HashMap&lt;String, String&gt;(directory.getUrl().getParameters());</span><br><span class="line">    <span class="comment">//注册consumer://协议的url</span></span><br><span class="line">        URL subscribeUrl = <span class="keyword">new</span> URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), <span class="number">0</span>, type.getName(), parameters);</span><br><span class="line">        <span class="keyword">if</span> (!ANY_VALUE.equals(url.getServiceInterface()) &amp;&amp; url.getParameter(REGISTER_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            directory.setRegisteredConsumerUrl(getRegisteredConsumerUrl(subscribeUrl, url));</span><br><span class="line">            registry.register(directory.getRegisteredConsumerUrl());</span><br><span class="line">        &#125;</span><br><span class="line">        directory.buildRouterChain(subscribeUrl);</span><br><span class="line">    <span class="comment">//订阅事件监听</span></span><br><span class="line">        directory.subscribe(subscribeUrl.addParameter(CATEGORY_KEY,</span><br><span class="line">                PROVIDERS_CATEGORY + <span class="string">","</span> + CONFIGURATORS_CATEGORY + <span class="string">","</span> + ROUTERS_CATEGORY));</span><br><span class="line"><span class="comment">//构建invoker</span></span><br><span class="line">        Invoker invoker = cluster.join(directory);</span><br><span class="line">        ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);</span><br><span class="line">        <span class="keyword">return</span> invoker;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="Cluster是什么"><a href="#Cluster是什么" class="headerlink" title="Cluster是什么"></a>Cluster是什么</h1><p>我们只关注一下Invoker这个代理类的创建过程,其他的暂且不关心</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoker invoker=cluster.join(directory)</span><br></pre></td></tr></table></figure><p>cluster其实是在RegistryProtocol中通过set方法完成依赖注入的，并且，它还是一个被包装的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCluster</span><span class="params">(Cluster cluster)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cluster = cluster;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Cluster扩展点的定义, 由于它是一个自适应扩展点，那么会动态生成一个Cluster$Adaptive的动态代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(FailoverCluster.NAME)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cluster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Cluster-Adaptive"><a href="#Cluster-Adaptive" class="headerlink" title="Cluster$Adaptive"></a>Cluster$Adaptive</h2><p>在动态适配的类中会基于extName，选择一个合适的扩展点进行适配，由于默认情况下cluster:failover，所以</p><p>getExtension(“failover”)理论上应该返回FailOverCluster。但实际上，这里做了包装</p><p>MockClusterWrapper（FailOverCluster）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cluster</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">dubbo</span>.<span class="title">rpc</span>.<span class="title">cluster</span>.<span class="title">Cluster</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.<span class="function">Invoker <span class="title">join</span><span class="params">(org.apache.dubbo.rpc.cluster.Directory arg0)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.cluster.Directory argument == null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg0.getUrl() == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.cluster.Directory argument getUrl() == null"</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class="line">        String extName = url.getParameter(<span class="string">"cluster"</span>, <span class="string">"failover"</span>);</span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.rpc.cluster.Cluster) name from url ("</span> + url.toString() + <span class="string">") use keys([cluster])"</span>);</span><br><span class="line">        org.apache.dubbo.rpc.cluster.Cluster extension = (org.apache.dubbo.rpc.cluster.Cluster)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.cluster.Cluster.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.join(arg0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cluster-join"><a href="#cluster-join" class="headerlink" title="cluster.join"></a>cluster.join</h2><p>所以再回到doRefer方法，下面这段代码, 实际是调用MockClusterWrapper(FailOverCluster.join)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoker invoker = cluster.join(directory);</span><br></pre></td></tr></table></figure><p>所以这里返回的invoker，应该是MockClusterWrapper(FailOverCluster（directory）)</p><blockquote><p>接着回到ReferenceConfig.createProxy方法中的最后一行</p></blockquote><h2 id="proxyFactory-getProxy"><a href="#proxyFactory-getProxy" class="headerlink" title="proxyFactory.getProxy"></a>proxyFactory.getProxy</h2><p>拿到invoker之后，会调用获得一个动态代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (T) proxyFactory.getProxy(invoker);</span><br></pre></td></tr></table></figure><p>而这里的proxyFactory又是一个自适应扩展点，所以会进入下面的方法</p><h2 id="JavassistProxyFactory-getProxy"><a href="#JavassistProxyFactory-getProxy" class="headerlink" title="JavassistProxyFactory.getProxy"></a>JavassistProxyFactory.getProxy</h2><p>通过这个方法生成了一个动态代理类，并且对invoker再做了一层处理，InvokerInvocationHandler。意味着后续发起服务调用的时候，会由InvokerInvocationHandler来进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.getProxy(interfaces).newInstance(<span class="keyword">new</span> InvokerInvocationHandler(invoker));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="proxy-getProxy"><a href="#proxy-getProxy" class="headerlink" title="proxy.getProxy"></a>proxy.getProxy</h2><p>在proxy.getProxy这个方法中会生成一个动态代理类，通过debug的形式可以看到动态代理类的原貌</p><p>在getProxy这个方法位置加一个断点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy = (Proxy) pc.newInstance();</span><br></pre></td></tr></table></figure><p>然后在debug窗口，找到ccp这个变量 -&gt; mMethods。</p><p>![1564292685365](F:\教研-课件\vip课程\第三轮\课程研发\Java架构课件\Mic老师\分布式专题\03. 微服务系列之阿里体系\11. Apache Dubbo进阶之服务注册源码分析\1564292685365.png)</p><p>调整一下格式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.<span class="function">String <span class="title">sayHello</span><span class="params">(java.lang.String arg0)</span></span>&#123;</span><br><span class="line">  Object[] args = <span class="keyword">new</span> Object[<span class="number">1</span>]; </span><br><span class="line">  args[<span class="number">0</span>] = ($w)$<span class="number">1</span>; </span><br><span class="line">  Object ret = handler.invoke(<span class="keyword">this</span>, methods[<span class="number">0</span>], args); </span><br><span class="line"><span class="keyword">return</span> (java.lang.String)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个sayHello方法可以看出，我们通过</p><p>@Reference注入的一个对象实例本质上就是一个动态代理类，通过调用这个类中的方法，会触发</p><p>handler.invoke(), 而这个handler就是InvokerInvocationHandler</p><h1 id="网络连接的建立"><a href="#网络连接的建立" class="headerlink" title="网络连接的建立"></a>网络连接的建立</h1><p>前面分析的逻辑中，只讲到了动态代理类的生成，那么目标服务地址信息以及网络通信的建立在哪里实现的呢？我们继续回到RegistryProtocol.refer这个方法中</p><p>这里我们暂且关注directory.subscribe这个方法，它是实现服务目标服务订阅的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doRefer</span><span class="params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">        RegistryDirectory&lt;T&gt; directory = <span class="keyword">new</span> RegistryDirectory&lt;T&gt;(type, url);</span><br><span class="line">        directory.setRegistry(registry);</span><br><span class="line">        directory.setProtocol(protocol);</span><br><span class="line">        <span class="comment">// all attributes of REFER_KEY</span></span><br><span class="line">        Map&lt;String, String&gt; parameters = <span class="keyword">new</span> HashMap&lt;String, String&gt;(directory.getUrl().getParameters());</span><br><span class="line">        URL subscribeUrl = <span class="keyword">new</span> URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), <span class="number">0</span>, type.getName(), parameters);</span><br><span class="line">        <span class="keyword">if</span> (!ANY_VALUE.equals(url.getServiceInterface()) &amp;&amp; url.getParameter(REGISTER_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            directory.setRegisteredConsumerUrl(getRegisteredConsumerUrl(subscribeUrl, url));</span><br><span class="line">            registry.register(directory.getRegisteredConsumerUrl());</span><br><span class="line">        &#125;</span><br><span class="line">        directory.buildRouterChain(subscribeUrl);</span><br><span class="line">        directory.subscribe(subscribeUrl.addParameter(CATEGORY_KEY,</span><br><span class="line">                PROVIDERS_CATEGORY + <span class="string">","</span> + CONFIGURATORS_CATEGORY + <span class="string">","</span> + ROUTERS_CATEGORY));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*省略部分代码*/</span></span><br><span class="line">        <span class="keyword">return</span> invoker;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="RegistryDirectory-subscribe"><a href="#RegistryDirectory-subscribe" class="headerlink" title="RegistryDirectory.subscribe"></a>RegistryDirectory.subscribe</h2><p>订阅注册中心指定节点的变化，如果发生变化，则通知到RegistryDirectory。Directory其实和服务的注册以及服务的发现有非常大的关联.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        setConsumerUrl(url); <span class="comment">//设置consumerUrl</span></span><br><span class="line">        <span class="comment">//把当前RegistryDirectory作为listener，去监听zk上节点的变化</span></span><br><span class="line">        consumerConfigurationListener.addNotifyListener(<span class="keyword">this</span>); </span><br><span class="line">        serviceConfigurationListener = <span class="keyword">new</span> ReferenceConfigurationListener(<span class="keyword">this</span>, url);</span><br><span class="line">        registry.subscribe(url, <span class="keyword">this</span>);<span class="comment">//订阅 -&gt; 这里的registry是zookeeperRegsitry</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里的registry 是ZookeeperRegistry ，会去监听并获取路径下面的节点。监听的路径是： </p><p><code>/dubbo/org.apache.dubbo.demo.DemoService/providers 、/dubbo/org.apache.dubbo.demo.DemoService/configurators、/dubbo/org.apache.dubbo.demo.DemoService/routers</code>节点下面的子节点变动</p><h2 id="FailbackRegistry-subscribe"><a href="#FailbackRegistry-subscribe" class="headerlink" title="FailbackRegistry.subscribe"></a>FailbackRegistry.subscribe</h2><p>listener为RegistryDirectory，后续要用到</p><p>移除失效的listener，调用doSubscribe进行订阅</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(URL url, NotifyListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.subscribe(url, listener);</span><br><span class="line">        removeFailedSubscribed(url, listener);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Sending a subscription request to the server side</span></span><br><span class="line">            doSubscribe(url, listener);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Throwable t = e;</span><br><span class="line"></span><br><span class="line">            List&lt;URL&gt; urls = getCacheUrls(url);</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(urls)) &#123;</span><br><span class="line">                notify(url, listener, urls);</span><br><span class="line">                logger.error(<span class="string">"Failed to subscribe "</span> + url + <span class="string">", Using cached list: "</span> + urls + <span class="string">" from cache file: "</span> + getUrl().getParameter(Constants.FILE_KEY, System.getProperty(<span class="string">"user.home"</span>) + <span class="string">"/dubbo-registry-"</span> + url.getHost() + <span class="string">".cache"</span>) + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// If the startup detection is opened, the Exception is thrown directly.</span></span><br><span class="line">                <span class="keyword">boolean</span> check = getUrl().getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)</span><br><span class="line">                        &amp;&amp; url.getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">boolean</span> skipFailback = t <span class="keyword">instanceof</span> SkipFailbackWrapperException;</span><br><span class="line">                <span class="keyword">if</span> (check || skipFailback) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (skipFailback) &#123;</span><br><span class="line">                        t = t.getCause();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to subscribe "</span> + url + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logger.error(<span class="string">"Failed to subscribe "</span> + url + <span class="string">", waiting for retry, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Record a failed registration request to a failed list, retry regularly</span></span><br><span class="line">            addFailedSubscribed(url, listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="ZookeeperRegistry-doSubscribe"><a href="#ZookeeperRegistry-doSubscribe" class="headerlink" title="ZookeeperRegistry.doSubscribe"></a>ZookeeperRegistry.doSubscribe</h2><p>这个方法是订阅，逻辑实现比较多，可以分两段来看，这里的实现把所有Service层发起的订阅以及指定的Service层发起的订阅分开处理。所有Service层类似于监控中心发起的订阅。指定的Service层发起的订阅可以看作是服务消费者的订阅。我们只需要关心指定service层发起的订阅即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSubscribe</span><span class="params">(<span class="keyword">final</span> URL url, <span class="keyword">final</span> NotifyListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (Constants.ANY_VALUE.equals(url.getServiceInterface())) &#123;</span><br><span class="line">                <span class="comment">//省略部分代码</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (String path : toCategoriesPath(url)) &#123;</span><br><span class="line">                    ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners = zkListeners.get(url);</span><br><span class="line">                    <span class="comment">// 如果之前该路径没有添加过listener，则创建一个map来放置listener</span></span><br><span class="line">                    <span class="keyword">if</span> (listeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        zkListeners.putIfAbsent(url, <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">                        listeners = zkListeners.get(url);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ChildListener zkListener = listeners.get(listener);</span><br><span class="line">                    <span class="keyword">if</span> (zkListener == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">// 如果没有添加过对于子节点的listener，则创建,通知服务变化 回调NotifyListener</span></span><br><span class="line">                        listeners.putIfAbsent(listener, (parentPath, currentChilds) -&gt; ZookeeperRegistry.<span class="keyword">this</span>.notify(url, listener, toUrlsWithEmpty(url, parentPath, currentChilds)));</span><br><span class="line">                        </span><br><span class="line">                        zkListener = listeners.get(listener);</span><br><span class="line">                    &#125;</span><br><span class="line">                    zkClient.create(path, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">//添加path节点的当前节点及子节点监听，并且获取子节点信息</span></span><br><span class="line">                    <span class="comment">//也就是dubbo://ip:port/...</span></span><br><span class="line">                    List&lt;String&gt; children = zkClient.addChildListener(path, zkListener);</span><br><span class="line">                    <span class="keyword">if</span> (children != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        urls.addAll(toUrlsWithEmpty(url, path, children));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//调用notify进行通知，对已经可用的列表进行通知</span></span><br><span class="line">                notify(url, listener, urls);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to subscribe "</span> + url + <span class="string">" to zookeeper "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="FailbackRegistry-notify"><a href="#FailbackRegistry-notify" class="headerlink" title="FailbackRegistry.notify"></a>FailbackRegistry.notify</h2><p>调用FailbackRegistry.notify， 对参数进行判断。 然后调用AbstractRegistry.notify方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(URL url, NotifyListener listener, List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"notify url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (listener == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"notify listener == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doNotify(url, listener, urls);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception t) &#123;</span><br><span class="line">            <span class="comment">// Record a failed registration request to a failed list, retry regularly</span></span><br><span class="line">            addFailedNotified(url, listener, urls);</span><br><span class="line">            logger.error(<span class="string">"Failed to notify for subscribe "</span> + url + <span class="string">", waiting for retry, cause: "</span> + t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="AbstractRegistry-notify"><a href="#AbstractRegistry-notify" class="headerlink" title="AbstractRegistry.notify"></a>AbstractRegistry.notify</h2><p>这里面会针对每一个category，调用listener.notify进行通知，然后更新本地的缓存文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(URL url, NotifyListener listener, List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略部分代码</span></span><br><span class="line">        <span class="comment">// keep every provider's category.</span></span><br><span class="line">        Map&lt;String, List&lt;URL&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (URL u : urls) &#123;</span><br><span class="line">            <span class="keyword">if</span> (UrlUtils.isMatch(url, u)) &#123;</span><br><span class="line">                String category = u.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);</span><br><span class="line">                List&lt;URL&gt; categoryList = result.computeIfAbsent(category, k -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">                categoryList.add(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, List&lt;URL&gt;&gt; categoryNotified = notified.computeIfAbsent(url, u -&gt; <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;URL&gt;&gt; entry : result.entrySet()) &#123;</span><br><span class="line">            String category = entry.getKey();</span><br><span class="line">            List&lt;URL&gt; categoryList = entry.getValue();</span><br><span class="line">            categoryNotified.put(category, categoryList);</span><br><span class="line">            listener.notify(categoryList);</span><br><span class="line">            <span class="comment">// We will update our cache file after each notification.</span></span><br><span class="line">            <span class="comment">// When our Registry has a subscribe failure due to network jitter, we can return at least the existing cache URL.</span></span><br><span class="line">            saveProperties(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>消费端的listener是最开始传递过来的RegistryDirectory，所以这里会触发RegistryDirectory.notify</p><h2 id="RegistryDirectory-notify"><a href="#RegistryDirectory-notify" class="headerlink" title="RegistryDirectory.notify"></a>RegistryDirectory.notify</h2><p>Invoker的网络连接以及后续的配置变更，都会调用这个notify方法</p><p>urls:  zk的path数据，这里表示的是dubbo://</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对url列表进行校验、过滤，然后分成 config、router、provider 3个分组map</span></span><br><span class="line">        Map&lt;String, List&lt;URL&gt;&gt; categoryUrls = urls.stream()</span><br><span class="line">                .filter(Objects::nonNull)</span><br><span class="line">                .filter(<span class="keyword">this</span>::isValidCategory)</span><br><span class="line">                .filter(<span class="keyword">this</span>::isNotCompatibleFor26x)</span><br><span class="line">                .collect(Collectors.groupingBy(url -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (UrlUtils.isConfigurator(url)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> CONFIGURATORS_CATEGORY;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (UrlUtils.isRoute(url)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> ROUTERS_CATEGORY;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (UrlUtils.isProvider(url)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> PROVIDERS_CATEGORY;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">                &#125;));</span><br><span class="line"></span><br><span class="line">        List&lt;URL&gt; configuratorURLs = categoryUrls.getOrDefault(CONFIGURATORS_CATEGORY, Collections.emptyList());</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">this</span>.configurators = Configurator.toConfigurators(configuratorURLs).orElse(<span class="keyword">this</span>.configurators);</span><br><span class="line"><span class="comment">// 如果router 路由节点有变化，则从新将router 下的数据生成router</span></span><br><span class="line">        List&lt;URL&gt; routerURLs = categoryUrls.getOrDefault(ROUTERS_CATEGORY, Collections.emptyList());</span><br><span class="line">        toRouters(routerURLs).ifPresent(<span class="keyword">this</span>::addRouters);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得provider URL，然后调用refreshOverrideAndInvoker进行刷新</span></span><br><span class="line">        List&lt;URL&gt; providerURLs = categoryUrls.getOrDefault(PROVIDERS_CATEGORY, Collections.emptyList());</span><br><span class="line">        refreshOverrideAndInvoker(providerURLs);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="refreshOverrideAndInvoker"><a href="#refreshOverrideAndInvoker" class="headerlink" title="refreshOverrideAndInvoker"></a>refreshOverrideAndInvoker</h2><ul><li>逐个调用注册中心里面的配置，覆盖原来的url，组成最新的url 放入overrideDirectoryUrl 存储</li><li>根据 provider urls，重新刷新Invoker </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshOverrideAndInvoker</span><span class="params">(List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mock zookeeper://xxx?mock=return null</span></span><br><span class="line">    overrideDirectoryUrl();</span><br><span class="line">    refreshInvoker(urls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="refreshInvoker"><a href="#refreshInvoker" class="headerlink" title="refreshInvoker"></a>refreshInvoker</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshInvoker</span><span class="params">(List&lt;URL&gt; invokerUrls)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(invokerUrls, <span class="string">"invokerUrls should not be null"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (invokerUrls.size() == <span class="number">1</span></span><br><span class="line">                &amp;&amp; invokerUrls.get(<span class="number">0</span>) != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; Constants.EMPTY_PROTOCOL.equals(invokerUrls.get(<span class="number">0</span>).getProtocol())) &#123;</span><br><span class="line">           <span class="comment">//省略部分代码，如果是空协议，则直接返回不允许访问</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.forbidden = <span class="keyword">false</span>; <span class="comment">// Allow to access</span></span><br><span class="line">            </span><br><span class="line">            Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap = <span class="keyword">this</span>.urlInvokerMap; <span class="comment">// local reference</span></span><br><span class="line">            <span class="keyword">if</span> (invokerUrls.isEmpty()) &#123;<span class="comment">//如果url为空，则直接返回</span></span><br><span class="line">                <span class="keyword">return</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据provider url，生成新的invoker</span></span><br><span class="line">            Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = toInvokers(invokerUrls);<span class="comment">// </span></span><br><span class="line">           <span class="comment">//转化为list</span></span><br><span class="line">            List&lt;Invoker&lt;T&gt;&gt; newInvokers = Collections.unmodifiableList(<span class="keyword">new</span> ArrayList&lt;&gt;(newUrlInvokerMap.values()));</span><br><span class="line">            </span><br><span class="line">            routerChain.setInvokers(newInvokers);</span><br><span class="line">            <span class="comment">//如果服务配置了分组，则把分组下的provider包装成StaticDirectory,组成一个invoker</span></span><br><span class="line">            <span class="comment">//实际上就是按照group进行合并</span></span><br><span class="line">            <span class="keyword">this</span>.invokers = multiGroup ? toMergeInvokerList(newInvokers) : newInvokers;</span><br><span class="line">            <span class="keyword">this</span>.urlInvokerMap = newUrlInvokerMap;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//旧的url 是否在新map里面存在，不存在，就是销毁url对应的Invoker</span></span><br><span class="line">                destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap); <span class="comment">// Close the unused Invoker</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.warn(<span class="string">"destroyUnusedInvokers error. "</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="toInvokers"><a href="#toInvokers" class="headerlink" title="toInvokers"></a>toInvokers</h2><p>这个方法中有比较长的判断和处理逻辑，我们只需要关心invoker是什么时候初始化的就行。</p><p>这里用到了protocol.refer来构建了一个invoker</p><p><code>invoker = new InvokerDelegate&lt;&gt;(protocol.refer(serviceType, url), url, providerUrl);</code></p><p>构建完成之后，会保存在<code>Map&lt;String, Invoker&lt;T&gt;&gt; urlInvokerMap</code> 这个集合中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Invoker&lt;T&gt;&gt; toInvokers(List&lt;URL&gt; urls) &#123;</span><br><span class="line">        Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            Map&lt;String, Invoker&lt;T&gt;&gt; localUrlInvokerMap = <span class="keyword">this</span>.urlInvokerMap; <span class="comment">// local reference</span></span><br><span class="line">            Invoker&lt;T&gt; invoker = localUrlInvokerMap == <span class="keyword">null</span> ? <span class="keyword">null</span> : localUrlInvokerMap.get(key);</span><br><span class="line">            <span class="keyword">if</span> (invoker == <span class="keyword">null</span>) &#123; <span class="comment">// Not in the cache, refer again</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> enabled = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (url.hasParameter(Constants.DISABLED_KEY)) &#123;</span><br><span class="line">                        enabled = !url.getParameter(Constants.DISABLED_KEY, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        enabled = url.getParameter(Constants.ENABLED_KEY, <span class="keyword">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">                        invoker = <span class="keyword">new</span> InvokerDelegate&lt;&gt;(protocol.refer(serviceType, url), url, providerUrl);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.error(<span class="string">"Failed to refer invoker for interface:"</span> + serviceType + <span class="string">",url:("</span> + url + <span class="string">")"</span> + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (invoker != <span class="keyword">null</span>) &#123; <span class="comment">// Put new invoker in cache</span></span><br><span class="line">                    newUrlInvokerMap.put(key, invoker);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newUrlInvokerMap.put(key, invoker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        keys.clear();</span><br><span class="line">        <span class="keyword">return</span> newUrlInvokerMap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="protocol-refer-1"><a href="#protocol-refer-1" class="headerlink" title="protocol.refer"></a>protocol.refer</h1><p>调用指定的协议来进行远程引用。protocol是一个Protocol$Adaptive类</p><p>而真正的实现应该是： ProtocolListenerWrapper(ProtocolFilterWrapper(QosProtocolWrapper(DubboProtocol.refer)</p><p>前面的包装过程，在服务发布的时候已经分析过了，我们直接进入DubboProtocol.refer方法</p><h2 id="DubboProtocol-refer"><a href="#DubboProtocol-refer" class="headerlink" title="DubboProtocol.refer"></a>DubboProtocol.refer</h2><ul><li>优化序列化</li><li>构建DubboInvoker</li></ul><p>在构建DubboInvoker时，会构建一个ExchangeClient，通过getClients(url)方法，这里基本可以猜到到是服务的通信建立</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; serviceType, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        optimizeSerialization(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create rpc invoker.</span></span><br><span class="line">        DubboInvoker&lt;T&gt; invoker = <span class="keyword">new</span> DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);</span><br><span class="line">        invokers.add(invoker);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invoker;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="getClients"><a href="#getClients" class="headerlink" title="getClients"></a>getClients</h2><p>这里面是获得客户端连接的方法</p><ul><li>判断是否为共享连接，默认是共享同一个连接进行通信</li><li>是否配置了多个连接通道 connections，默认只有一个</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ExchangeClient[] getClients(URL url) &#123;</span><br><span class="line">        <span class="comment">// whether to share connection</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> useShareConnect = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> connections = url.getParameter(Constants.CONNECTIONS_KEY, <span class="number">0</span>);</span><br><span class="line">        List&lt;ReferenceCountExchangeClient&gt; shareClients = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果没有配置连接数，则默认为共享连接</span></span><br><span class="line">        <span class="keyword">if</span> (connections == <span class="number">0</span>) &#123;</span><br><span class="line">            useShareConnect = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * The xml configuration should have a higher priority than properties.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            String shareConnectionsStr = url.getParameter(Constants.SHARE_CONNECTIONS_KEY, (String) <span class="keyword">null</span>);</span><br><span class="line">            connections = Integer.parseInt(StringUtils.isBlank(shareConnectionsStr) ? ConfigUtils.getProperty(Constants.SHARE_CONNECTIONS_KEY,</span><br><span class="line">                    Constants.DEFAULT_SHARE_CONNECTIONS) : shareConnectionsStr);</span><br><span class="line">            shareClients = getSharedClient(url, connections);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ExchangeClient[] clients = <span class="keyword">new</span> ExchangeClient[connections];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clients.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (useShareConnect) &#123;</span><br><span class="line">                clients[i] = shareClients.get(i);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                clients[i] = initClient(url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clients;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="getSharedClient"><a href="#getSharedClient" class="headerlink" title="getSharedClient"></a>getSharedClient</h2><p>获得一个共享连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;ReferenceCountExchangeClient&gt; <span class="title">getSharedClient</span><span class="params">(URL url, <span class="keyword">int</span> connectNum)</span> </span>&#123;</span><br><span class="line">        String key = url.getAddress();</span><br><span class="line">        List&lt;ReferenceCountExchangeClient&gt; clients = referenceClientMap.get(key);</span><br><span class="line">       <span class="comment">//检查当前的key检查连接是否已经创建过并且可用，如果是，则直接返回并且增加连接的个数的统计</span></span><br><span class="line">        <span class="keyword">if</span> (checkClientCanUse(clients)) &#123;</span><br><span class="line">            batchClientRefIncr(clients);</span><br><span class="line">            <span class="keyword">return</span> clients;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//如果连接已经关闭或者连接没有创建过</span></span><br><span class="line">        locks.putIfAbsent(key, <span class="keyword">new</span> Object());</span><br><span class="line">        <span class="keyword">synchronized</span> (locks.get(key)) &#123;</span><br><span class="line">            clients = referenceClientMap.get(key);</span><br><span class="line">            <span class="comment">// 在创建连接之前，在做一次检查，防止连接并发创建</span></span><br><span class="line">            <span class="keyword">if</span> (checkClientCanUse(clients)) &#123;</span><br><span class="line">                batchClientRefIncr(clients);</span><br><span class="line">                <span class="keyword">return</span> clients;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 连接数必须大于等于1</span></span><br><span class="line">            connectNum = Math.max(connectNum, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果当前消费者还没有和服务端产生连接，则初始化</span></span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isEmpty(clients)) &#123;</span><br><span class="line">                clients = buildReferenceCountExchangeClientList(url, connectNum);</span><br><span class="line">                <span class="comment">//创建clients之后，保存到map中</span></span><br><span class="line">                referenceClientMap.put(key, clients);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果clients不为空，则从clients数组中进行遍历</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clients.size(); i++) &#123;</span><br><span class="line">                    ReferenceCountExchangeClient referenceCountExchangeClient = clients.get(i);</span><br><span class="line">                    <span class="comment">// 如果在集合中存在一个连接但是这个连接处于closed状态，则重新构建一个进行替换</span></span><br><span class="line">                    <span class="keyword">if</span> (referenceCountExchangeClient == <span class="keyword">null</span> || referenceCountExchangeClient.isClosed()) &#123;</span><br><span class="line">                        clients.set(i, buildReferenceCountExchangeClient(url));</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//增加个数</span></span><br><span class="line">                    referenceCountExchangeClient.incrementAndGetCount();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * I understand that the purpose of the remove operation here is to avoid the expired url key</span></span><br><span class="line"><span class="comment">             * always occupying this memory space.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            locks.remove(key);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> clients;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="buildReferenceCountExchangeClientList"><a href="#buildReferenceCountExchangeClientList" class="headerlink" title="buildReferenceCountExchangeClientList"></a>buildReferenceCountExchangeClientList</h2><p>根据连接数配置，来构建指定个数的链接。默认为1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;ReferenceCountExchangeClient&gt; <span class="title">buildReferenceCountExchangeClientList</span><span class="params">(URL url, <span class="keyword">int</span> connectNum)</span> </span>&#123;</span><br><span class="line">        List&lt;ReferenceCountExchangeClient&gt; clients = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; connectNum; i++) &#123;</span><br><span class="line">            clients.add(buildReferenceCountExchangeClient(url));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clients;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ReferenceCountExchangeClient <span class="title">buildReferenceCountExchangeClient</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        ExchangeClient exchangeClient = initClient(url);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReferenceCountExchangeClient(exchangeClient);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="initClient"><a href="#initClient" class="headerlink" title="initClient"></a>initClient</h2><p>终于进入到初始化客户端连接的方法了，猜测应该是根据url中配置的参数进行远程通信的构建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ExchangeClient <span class="title">initClient</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得连接类型</span></span><br><span class="line">        String str = url.getParameter(Constants.CLIENT_KEY, url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_CLIENT));</span><br><span class="line">        <span class="comment">//添加默认序列化方恨死</span></span><br><span class="line">        url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);</span><br><span class="line">        <span class="comment">// enable heartbeat by default</span></span><br><span class="line">    <span class="comment">//设置心跳时间</span></span><br><span class="line">        url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断str是否存在于扩展点中，如果不存在则直接报错</span></span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span> &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Unsupported client type: "</span> + str + <span class="string">","</span> +</span><br><span class="line">                    <span class="string">" supported client type is "</span> + StringUtils.join(ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions(), <span class="string">" "</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ExchangeClient client;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 是否需要延迟创建连接，注意哦，这里的requestHandler是一个适配器</span></span><br><span class="line">            <span class="keyword">if</span> (url.getParameter(Constants.LAZY_CONNECT_KEY, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                client = <span class="keyword">new</span> LazyConnectExchangeClient(url, requestHandler);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                client = Exchangers.connect(url, requestHandler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Fail to create remoting client for service("</span> + url + <span class="string">"): "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Exchangers-connect"><a href="#Exchangers-connect" class="headerlink" title="Exchangers.connect"></a>Exchangers.connect</h2><p>创建一个客户端连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExchangeClient <span class="title">connect</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handler == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        url = url.addParameterIfAbsent(Constants.CODEC_KEY, <span class="string">"exchange"</span>);</span><br><span class="line">        <span class="keyword">return</span> getExchanger(url).connect(url, handler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="HeaderExchange-connect"><a href="#HeaderExchange-connect" class="headerlink" title="HeaderExchange.connect"></a>HeaderExchange.connect</h2><p>主要关注transporters.connect</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExchangeClient <span class="title">connect</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeaderExchangeClient(Transporters.connect(url, <span class="keyword">new</span> DecodeHandler(<span class="keyword">new</span> HeaderExchangeHandler(handler))), <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="NettyTransport-connect"><a href="#NettyTransport-connect" class="headerlink" title="NettyTransport.connect"></a>NettyTransport.connect</h2><p>使用netty构建了一个客户端连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Client <span class="title">connect</span><span class="params">(URL url, ChannelHandler listener)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NettyClient(url, listener);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们讲到了<code>RegistryProtocol.refer</code>过程中有一个关键步骤，即在监听到服务提供者url时触发<code>RegistryDirectory.notify()</code>方法。</p><p> <code>RegistryDirectory.notify()</code>方法调用<code>refreshInvoker()</code>方法将服务提供者urls转换为对应的<code>远程invoker</code>，最终调用到<code>DubboProtocol.refer()</code>方法生成对应的<code>DubboInvoker</code>。</p><p> <code>DubboInvoker</code>的构造方法中有一项入参<code>ExchangeClient[] clients</code>，即对应本文要讲的网络客户端<code>Client</code>。DubboInvoker就是通过调用<code>client.request()</code>方法完成网络通信的请求发送和响应接收功能。</p><p> <code>Client</code>的具体生成过程就是通过<code>DubboProtocol</code>的<code>initClient(URL url)</code>方法创建了一个<code>HeaderExchangeClient</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分析服务发布过程中所构建的Invoker，以及服务注册的流程&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="https://istio.tech/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="源码分析" scheme="https://istio.tech/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="Dubbo" scheme="https://istio.tech/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析系列之服务的发布</title>
    <link href="https://istio.tech/2019/07/28/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8F%91%E5%B8%83/"/>
    <id>https://istio.tech/2019/07/28/Dubbo源码分析系列之服务的发布/</id>
    <published>2019-07-28T15:04:00.000Z</published>
    <updated>2019-08-05T03:16:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>按照前面课程对于dubbo的理解，如果要实现服务发布和注册，需要做哪些事情？</p><ol><li>配置文件解析或者注解解析</li><li>服务注册</li><li>启动netty服务实现远程监听<a id="more"></a></li></ol><h1 id="Dubbo对于sping的扩展"><a href="#Dubbo对于sping的扩展" class="headerlink" title="Dubbo对于sping的扩展"></a>Dubbo对于sping的扩展</h1><p>最早我们使用Spring的配置，来实现dubbo服务的发布，方便大家的同时，也意味着Dubbo里面和Spring肯定有那种说不清的关系</p><h2 id="Spring的标签扩展"><a href="#Spring的标签扩展" class="headerlink" title="Spring的标签扩展"></a>Spring的标签扩展</h2><p>在spring中定义了两个接口</p><p>NamespaceHandler: 注册一堆BeanDefinitionParser，利用他们来进行解析</p><p>BeanDefinitionParser:用于解析每个element的内容</p><p>Spring默认会加载jar包下的META-INF/spring.handlers文件寻找对应的NamespaceHandler。 Dubbo-config模块下的dubbo-config-spring<br>slt4.png<br><img src="/images/1564193496124.png" alt="1564193496124"></p><h2 id="Dubbo的接入实现"><a href="#Dubbo的接入实现" class="headerlink" title="Dubbo的接入实现"></a>Dubbo的接入实现</h2><p>Dubbo中spring扩展就是使用spring的自定义类型，所以同样也有NamespaceHandler、BeanDefinitionParser。而NamespaceHandler是DubboNamespaceHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      Version.checkDuplicate(DubboNamespaceHandler.class);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"application"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ApplicationConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"module"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ModuleConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"registry"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(RegistryConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"monitor"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(MonitorConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"provider"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ProviderConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"consumer"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ConsumerConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"protocol"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ProtocolConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"service"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ServiceBean.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"reference"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ReferenceBean.class, <span class="keyword">false</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"annotation"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(AnnotationBean.class, <span class="keyword">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanDefinitionParser全部都使用了DubboBeanDefinitionParser，如果我们想看<a href="dubbo:service" target="_blank" rel="noopener">dubbo:service</a>的配置，就直接看<code>DubboBeanDefinitionParser(ServiceBean.class,true)</code></p><p>这个里面主要做了一件事，把不同的配置分别转化成spring容器中的bean对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">application对应ApplicationConfig</span><br><span class="line"></span><br><span class="line">registry对应RegistryConfig</span><br><span class="line"></span><br><span class="line">monitor对应MonitorConfig</span><br><span class="line"></span><br><span class="line">provider对应ProviderConfig</span><br><span class="line"></span><br><span class="line">consumer对应ConsumerConfig</span><br></pre></td></tr></table></figure><p>我们仔细看，发现涉及到服务发布和服务调用的两个配置的解析，试用的是ServiceBean和referenceBean。并不是config结尾的，这两个类稍微特殊些，当然他同时也继承了ServiceConfig和ReferenceConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">registerBeanDefinitionParser(<span class="string">"service"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ServiceBean.class, <span class="keyword">true</span>));</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"reference"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ReferenceBean.class, <span class="keyword">false</span>));</span><br></pre></td></tr></table></figure><h2 id="DubboBeanDefinitionParser"><a href="#DubboBeanDefinitionParser" class="headerlink" title="DubboBeanDefinitionParser"></a>DubboBeanDefinitionParser</h2><p>这里面是实现具体配置文件解析的入口，它重写了parse方法，对spring的配置进行解析。我们关注一下ServiceBean的解析. 实际就是解析<a href="dubbo:service" target="_blank" rel="noopener">dubbo:service</a>这个标签中对应的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ServiceBean.class.equals(beanClass)) &#123;</span><br><span class="line">           String className = element.getAttribute(<span class="string">"class"</span>);</span><br><span class="line">           <span class="keyword">if</span> (className != <span class="keyword">null</span> &amp;&amp; className.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               RootBeanDefinition classDefinition = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">               classDefinition.setBeanClass(ReflectUtils.forName(className));</span><br><span class="line">               classDefinition.setLazyInit(<span class="keyword">false</span>);</span><br><span class="line">               parseProperties(element.getChildNodes(), classDefinition);</span><br><span class="line">               beanDefinition.getPropertyValues().addPropertyValue(<span class="string">"ref"</span>, <span class="keyword">new</span> BeanDefinitionHolder(classDefinition, id + <span class="string">"Impl"</span>));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h2 id="ServiceBean的实现"><a href="#ServiceBean的实现" class="headerlink" title="ServiceBean的实现"></a>ServiceBean的实现</h2><p>ServiceBean这个类，分别实现了InitializingBean, DisposableBean,        ApplicationContextAware, ApplicationListener<contextrefreshedevent>, BeanNameAware,        ApplicationEventPublisherAware</contextrefreshedevent></p><p><strong>InitializingBean</strong></p><p>接口为bean提供了初始化方法的方式，它只包括afterPropertiesSet方法，凡是继承该接口的类，在初始化bean的时候会执行该方法。被重写的方法为<code>afterPropertiesSet</code></p><p><strong>DisposableBean</strong> </p><p>被重写的方法为<code>destroy</code>,bean被销毁的时候，spring容器会自动执行destory方法，比如释放资源</p><p><strong>ApplicationContextAware</strong> </p><p>实现了这个接口的bean，当spring容器初始化的时候，会自动的将ApplicationContext注入进来</p><p><strong>ApplicationListener</strong>  </p><p>ApplicationEvent事件监听，spring容器启动后会发一个事件通知。被重写的方法为:<code>onApplicationEvent</code>,onApplicationEvent方法传入的对象是ContextRefreshedEvent。这个对象是当Spring的上下文被刷新或者加载完毕的时候触发的。因此服务就是在Spring的上下文刷新后进行导出操作的</p><p><strong>BeanNameAware</strong> </p><p>获得自身初始化时，本身的bean的id属性，被重写的方法为<code>setBeanName</code></p><p><strong>ApplicationEventPublisherAware</strong></p><p>这个是一个异步事件发送器。被重写的方法为<code>setApplicationEventPublisher</code>,简单来说，在spring里面提供了类似于消息队列的异步事件解耦功能。（典型的观察者模式的应用）</p><blockquote><p><strong>spring事件发送监听由3个部分组成</strong></p></blockquote><blockquote><p>1.ApplicationEvent：表示事件本身，自定义事件需要继承该类</p></blockquote><blockquote><p>2.ApplicationEventPublisherAware：事件发送器，需要实现该接口</p></blockquote><blockquote><p>3.ApplicationListener<t>：事件监听器接口</t></p></blockquote><p><img src="/images/1564194283964.png" alt="1564194283964"></p><h1 id="ServiceBean中服务暴露过程"><a href="#ServiceBean中服务暴露过程" class="headerlink" title="ServiceBean中服务暴露过程"></a>ServiceBean中服务暴露过程</h1><p>在ServiceBean中，我们暂且只需要关注两个方法，分别是:</p><p>在初始化bean的时候会执行该方法<code>afterPropertiesSet</code>,</p><p>spring容器启动后会发一个事件通知<code>onApplicationEvent</code></p><h2 id="afterPropertiesSet"><a href="#afterPropertiesSet" class="headerlink" title="afterPropertiesSet"></a>afterPropertiesSet</h2><p>我们发现这个方法里面，就是把dubbo中配置的<code>application</code>、<code>registry</code>、<code>service</code>、<code>protocol</code>等信息，加载到对应的config实体中，便于后续的使用</p><h2 id="onApplicationEvent"><a href="#onApplicationEvent" class="headerlink" title="onApplicationEvent"></a>onApplicationEvent</h2><p>spring容器启动之后，会收到一个这样的事件通知，这里面做了两个事情</p><ul><li>判断服务是否已经发布过</li><li>如果没有发布，则调用调用export进行服务发布的流程（<strong>这里就是入口</strong>）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isExported() &amp;&amp; !isUnexported()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"The service ready on spring started. service: "</span> + getInterface());</span><br><span class="line">            &#125;</span><br><span class="line">            export();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="export"><a href="#export" class="headerlink" title="export"></a>export</h2><p>serviceBean中，重写了export方法，实现了 一个事件的发布。并且调用了super.export() ，也就是会调用父类的export方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.export();</span><br><span class="line">        <span class="comment">// Publish ServiceBeanExportedEvent</span></span><br><span class="line">        publishExportEvent();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="ServiceConfig配置类"><a href="#ServiceConfig配置类" class="headerlink" title="ServiceConfig配置类"></a>ServiceConfig配置类</h1><p>先整体来看一下这个类的作用，从名字来看，它应该和其他所有config类一样去实现对配置文件中service的配置信息的存储。实际上这个类并不单纯，所有的配置它都放在了一个<code>AbstractServiceConfig</code>的抽象类，自己实现了很多对于服务发布之前要做的操作逻辑</p><h2 id="export-1"><a href="#export-1" class="headerlink" title="export"></a>export</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkAndUpdateSubConfigs(); <span class="comment">//检查并且更新配置信息</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!shouldExport()) &#123;<span class="comment">//当前的服务是否需要发布, 通过配置实现：@Service(export = false)</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shouldDelay()) &#123;<span class="comment">//检查是否需要延时发布，通过配置@Service(delay = 1000)实现，单位毫秒</span></span><br><span class="line">            <span class="comment">//这里的延时是通过定时器来实现</span></span><br><span class="line">            delayExportExecutor.schedule(<span class="keyword">this</span>::doExport, getDelay(), TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            doExport(); <span class="comment">//如果没有配置delay，则直接调用export进行发布</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="doExport"><a href="#doExport" class="headerlink" title="doExport"></a>doExport</h2><p>这里仍然还是在实现发布前的各种判断，比如判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doExport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (unexported) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The service "</span> + interfaceClass.getName() + <span class="string">" has already unexported!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exported) &#123; <span class="comment">//服务是否已经发布过了</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        exported = <span class="keyword">true</span>; <span class="comment">//设置发布状态</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(path)) &#123;<span class="comment">//path表示服务路径，默认使用interfaceName</span></span><br><span class="line">            path = interfaceName;</span><br><span class="line">        &#125;</span><br><span class="line">        doExportUrls();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="doExportUrls"><a href="#doExportUrls" class="headerlink" title="doExportUrls"></a>doExportUrls</h2><ol><li>记载所有配置的注册中心地址</li><li>遍历所有配置的协议，protocols</li><li>针对每种协议发布一个对应协议的服务</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//加载所有配置的注册中心的地址，组装成一个URL</span></span><br><span class="line">    <span class="comment">//(registry://ip:port/org.apache.dubbo.registry.RegistryService的东西)</span></span><br><span class="line">        List&lt;URL&gt; registryURLs = loadRegistries(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">for</span> (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line">            <span class="comment">//group跟version组成一个pathKey(serviceName)</span></span><br><span class="line">            String pathKey = URL.buildKey(getContextPath(protocolConfig).map(p -&gt; p + <span class="string">"/"</span> + path).orElse(path), group, version);</span><br><span class="line">            <span class="comment">//applicationModel用来存储ProviderModel，发布的服务的元数据，后续会用到</span></span><br><span class="line">            ProviderModel providerModel = <span class="keyword">new</span> ProviderModel(pathKey, ref, interfaceClass);</span><br><span class="line">            ApplicationModel.initProviderModel(pathKey, providerModel);</span><br><span class="line">            doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="doExportUrlsFor1Protocol"><a href="#doExportUrlsFor1Protocol" class="headerlink" title="doExportUrlsFor1Protocol"></a>doExportUrlsFor1Protocol</h2><p>发布指定协议的服务，我们以Dubbo服务为例，由于代码太多，就不全部贴出来</p><ol><li>前面的一大串if else代码，是为了把当前服务下所配置的<code>&lt;dubbo:method&gt;</code>参数进行解析，保存到map集合中</li><li>获得当前服务需要暴露的ip和端口</li><li>把解析到的所有数据，组装成一个URL,大概应该是：<code>dubbo://192.168.13.1:20881/com.gupaoedu.dubbo.practice.ISayHelloService</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrlsFor1Protocol</span><span class="params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略一大串ifelse代码，用于解析&lt;dubbo:method&gt; 配置</span></span><br><span class="line">    <span class="comment">//省略解析&lt;dubbo:service&gt;中配置参数的代码，比如token、比如service中的method名称等存储在map中</span></span><br><span class="line">    <span class="comment">//获得当前服务要发布的目标ip和port</span></span><br><span class="line">   String host = <span class="keyword">this</span>.findConfigedHosts(protocolConfig, registryURLs, map);</span><br><span class="line">   Integer port = <span class="keyword">this</span>.findConfigedPorts(protocolConfig, name, map);   </span><br><span class="line">    <span class="comment">//组装URL</span></span><br><span class="line">    URL url = <span class="keyword">new</span> URL(name, host, port, getContextPath(protocolConfig).map(p -&gt; p + <span class="string">"/"</span> + path).orElse(path), map);</span><br><span class="line"><span class="comment">//这里是通过ConfiguratorFactory去实现动态改变配置的功能，这里暂时不涉及后续再分析</span></span><br><span class="line">        <span class="keyword">if</span> (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">                .hasExtension(url.getProtocol())) &#123;</span><br><span class="line">            url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">                    .getExtension(url.getProtocol()).getConfigurator(url).configure(url);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>如果scope!=”none”则发布服务，默认scope为null。如果scope不为none，判断是否为local或remote，从而发布Local服务或Remote服务，默认两个都会发布</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> String scope = url.getParameter(SCOPE_KEY);</span><br><span class="line"><span class="keyword">if</span> (!SCOPE_NONE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">            <span class="comment">//injvm发布到本地</span></span><br><span class="line">            <span class="keyword">if</span> (!SCOPE_REMOTE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">                exportLocal(url);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//发布远程服务</span></span><br><span class="line">            <span class="keyword">if</span> (!SCOPE_LOCAL.equalsIgnoreCase(scope)) &#123;</span><br></pre></td></tr></table></figure><p><strong>Local</strong></p><p>服务只是injvm的服务，提供一种消费者和提供者都在一个jvm内的调用方式。使用了Injvm协议，是一个伪协议，它不开启端口，不发起远程调用，只在JVM内直接关联，(通过集合的方式保存了发布的服务信息)，但执行Dubbo的Filter链。简单来说，就是你本地的dubbo服务调用，都依托于dubbo的标准来进行。这样可以享受到dubbo的一些配置服务</p><p><strong>remote</strong></p><p>表示根据根据配置的注册中心进行远程发布。  遍历多个注册中心，进行协议的发布</p><ol><li>Invoker是一个代理类，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。<strong>（后续单独分析）</strong></li><li>DelegateProviderMetaDataInvoker，因为2.7引入了元数据，所以这里对invoker做了委托，把invoker交给DelegateProviderMetaDataInvoker来处理</li><li>调用protocol.export(invoker)来发布这个代理</li><li>添加到exporters集合</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (URL registryURL : registryURLs) &#123;</span><br><span class="line">   <span class="comment">//省略部分代码...</span></span><br><span class="line">  Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(EXPORT_KEY, url.toFullString()));</span><br><span class="line">  DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line">  exporters.add(exporter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="protocol-export"><a href="#protocol-export" class="headerlink" title="protocol.export"></a>protocol.export</h2><p>protocol.export，这个protocol是什么呢？找到定义处发现它是一个自适应扩展点，打开Protocol这个扩展点，又可以看到它是一个在方法层面上的自适应扩展，意味着它实现了对于export这个方法的适配。也就意味着这个Protocol是一个动态代理类，Protocol$Adaptive</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</span><br></pre></td></tr></table></figure><p>这个动态代理类，会根据url中配置的protocol name来实现对应协议的适配</p><h2 id="Protocol-Adaptive"><a href="#Protocol-Adaptive" class="headerlink" title="Protocol$Adaptive"></a>Protocol$Adaptive</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Protocol</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">dubbo</span>.<span class="title">rpc</span>.<span class="title">Protocol</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"The method public abstract void org.apache.dubbo.rpc.Protocol.destroy() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"The method public abstract int org.apache.dubbo.rpc.Protocol.getDefaultPort() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.<span class="function">Exporter <span class="title">export</span><span class="params">(org.apache.dubbo.rpc.Invoker arg0)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.Invoker argument == null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg0.getUrl() == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.Invoker argument getUrl() == null"</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class="line">        String extName = ( url.getProtocol() == <span class="keyword">null</span> ? <span class="string">"dubbo"</span> : url.getProtocol() );</span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url ("</span> + url.toString() + <span class="string">") use keys([protocol])"</span>);</span><br><span class="line">        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.export(arg0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.<span class="function">Invoker <span class="title">refer</span><span class="params">(java.lang.Class arg0, org.apache.dubbo.common.URL arg1)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg1 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg1;</span><br><span class="line">        String extName = ( url.getProtocol() == <span class="keyword">null</span> ? <span class="string">"dubbo"</span> : url.getProtocol() );</span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url ("</span> + url.toString() + <span class="string">") use keys([protocol])"</span>);</span><br><span class="line">        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.refer(arg0, arg1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在当前的场景中，protocol会是调用谁呢？目前发布的invoker(URL)，实际上是一个registry://协议，所以Protocol$Adaptive，会通过getExtension(extName)得到一个RegistryProtocol</p><h1 id="RegistryProtocol-export"><a href="#RegistryProtocol-export" class="headerlink" title="RegistryProtocol.export"></a>RegistryProtocol.export</h1><p>很明显，这个RegistryProtocol是用来实现服务注册的</p><p>这里面会有很多处理逻辑</p><ul><li>实现对应协议的服务发布</li><li>实现服务注册</li><li>订阅服务重写</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">//这里获得的是zookeeper注册中心的url: zookeeper://ip:port</span></span><br><span class="line">        URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class="line">    <span class="comment">//这里是获得服务提供者的url, dubbo://ip:port...</span></span><br><span class="line">        URL providerUrl = getProviderUrl(originInvoker);</span><br><span class="line">    <span class="comment">/***************************************************************************/</span></span><br><span class="line">    <span class="comment">//订阅override数据。在admin控制台可以针对服务进行治理，比如修改权重，修改路由机制等，当注册中心有此服务的覆盖配置注册进来时，推送消息给提供者，重新暴露服务</span></span><br><span class="line">        <span class="keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(providerUrl);</span><br><span class="line">        <span class="keyword">final</span> OverrideListener overrideSubscribeListener = <span class="keyword">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class="line">        overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">        providerUrl = overrideUrlWithConfig(providerUrl, overrideSubscribeListener);</span><br><span class="line">    <span class="comment">/*****************************************************************************/</span></span><br><span class="line">        <span class="comment">//这里就交给了具体的协议去暴露服务（很重要）</span></span><br><span class="line">        <span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker, providerUrl);</span><br><span class="line">        <span class="comment">// 根据invoker中的url获取Registry实例: zookeeperRegistry</span></span><br><span class="line">        <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line">    <span class="comment">//获取要注册到注册中心的URL: dubbo://ip:port</span></span><br><span class="line">        <span class="keyword">final</span> URL registeredProviderUrl = getRegisteredProviderUrl(providerUrl, registryUrl);</span><br><span class="line">        ProviderInvokerWrapper&lt;T&gt; providerInvokerWrapper = ProviderConsumerRegTable.registerProvider(originInvoker,</span><br><span class="line">                registryUrl, registeredProviderUrl);</span><br><span class="line">        <span class="comment">//to judge if we need to delay publish</span></span><br><span class="line">        <span class="keyword">boolean</span> register = registeredProviderUrl.getParameter(<span class="string">"register"</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (register) &#123;<span class="comment">//是否配置了注册中心，如果是， 则需要注册</span></span><br><span class="line">            <span class="comment">//注册到注册中心的URL</span></span><br><span class="line">            register(registryUrl, registeredProviderUrl);</span><br><span class="line">            providerInvokerWrapper.setReg(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//设置注册中心的订阅</span></span><br><span class="line">        <span class="comment">// Deprecated! Subscribe to override rules in 2.6.x or before.</span></span><br><span class="line">        registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line"></span><br><span class="line">        exporter.setRegisterUrl(registeredProviderUrl);</span><br><span class="line">        exporter.setSubscribeUrl(overrideSubscribeUrl);</span><br><span class="line">        <span class="comment">//保证每次export都返回一个新的exporter实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DestroyableExporter&lt;&gt;(exporter);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="doLocalExport"><a href="#doLocalExport" class="headerlink" title="doLocalExport"></a>doLocalExport</h2><p>先通过doLocalExport来暴露一个服务，本质上应该是启动一个通信服务,主要的步骤是将本地ip和20880端口打开，进行监听</p><p>originInvoker: 应该是registry://ip:port/com.alibaba.dubbo.registry.RegistryService</p><p>key: 从originInvoker中获得发布协议的url: dubbo://ip:port/…</p><p>bounds: 一个prviderUrl服务export之后，缓存到 bounds中，所以一个providerUrl只会对应一个exporter</p><blockquote><p>computeIfAbsent就相当于, java8的语法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(bounds.get(key)==<span class="keyword">null</span>)&#123;</span><br><span class="line">    bounds.put(key,s-&gt;&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">ExporterChangeableWrapper&lt;T&gt; <span class="title">doLocalExport</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker, URL providerUrl)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        String key = getCacheKey(originInvoker);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (ExporterChangeableWrapper&lt;T&gt;) bounds.computeIfAbsent(key, s -&gt; &#123;</span><br><span class="line">            <span class="comment">//对原有的invoker,委托给了InvokerDelegate</span></span><br><span class="line">            Invoker&lt;?&gt; invokerDelegate = <span class="keyword">new</span> InvokerDelegate&lt;&gt;(originInvoker, providerUrl);</span><br><span class="line">            <span class="comment">//将invoker转换为exporter并启动netty服务</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ExporterChangeableWrapper&lt;&gt;((Exporter&lt;T&gt;) protocol.export(invokerDelegate), originInvoker);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>InvokerDelegete</strong>: 是RegistryProtocol的一个静态内部类，该类是一个originInvoker的委托类，该类存储了originInvoker，其父类InvokerWrapper还会存储providerUrl，InvokerWrapper会调用originInvoker的invoke方法，也会销毁invoker。可以管理invoker的生命周期</p><h1 id="DubboProtocol-export"><a href="#DubboProtocol-export" class="headerlink" title="DubboProtocol.export"></a>DubboProtocol.export</h1><p>基于动态代理的适配，很自然的就过渡到了DubboProtocol这个协议类中，但是实际上是DubboProtocol吗？</p><p>这里并不是获得一个单纯的DubboProtocol扩展点，而是会通过Wrapper对Protocol进行装饰，装饰器分别为: <code>QosProtocolWrapper/ProtocolListenerWrapper/ProtocolFilterWrapper/DubboProtocol</code></p><p>为什么是这样？我们再来看看spi的代码</p><h2 id="Wrapper包装"><a href="#Wrapper包装" class="headerlink" title="Wrapper包装"></a>Wrapper包装</h2><p>在ExtensionLoader.loadClass这个方法中，有一段这样的判断，如果当前这个类是一个wrapper包装类，也就是这个wrapper中有构造方法，参数是当前被加载的扩展点的类型，则把这个wrapper类加入到cacheWrapperClass缓存中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (isWrapperClass(clazz)) &#123;</span><br><span class="line">            cacheWrapperClass(clazz);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isWrapperClass</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz.getConstructor(type);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们可以在dubbo的配置文件中找到三个Wrapper</p><p><strong>QosprotocolWrapper</strong>， 如果当前配置了注册中心，则会启动一个Qos server.qos是dubbo的在线运维命令，dubbo2.5.8新版本重构了telnet模块，提供了新的telnet命令支持，新版本的telnet端口与dubbo协议的端口是不同的端口，默认为22222</p><p><strong>ProtocolFilterWrapper</strong>，对invoker进行filter的包装，实现请求的过滤</p><p><strong>ProtocolListenerWrapper</strong>， 用于服务export时候插入监听机制，<strong>暂未实现</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">qos=org.apache.dubbo.qos.protocol.QosProtocolWrapper </span><br><span class="line">filter=org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper</span><br><span class="line">listener=org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper</span><br></pre></td></tr></table></figure><p>接着，在getExtension-&gt;createExtension方法中，会对cacheWrapperClass集合进行判断，如果集合不为空，则进行包装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(wrapperClasses)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class="line">                    instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h2 id="ProtocolFilterWrapper"><a href="#ProtocolFilterWrapper" class="headerlink" title="ProtocolFilterWrapper"></a>ProtocolFilterWrapper</h2><p>这个是一个过滤器的包装，使用责任链模式，对invoker进行了包装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">            <span class="keyword">return</span> protocol.export(invoker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//构建责任链，基于激活扩展点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">buildInvokerChain</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; invoker, String key, String group)</span> </span>&#123;</span><br><span class="line">        Invoker&lt;T&gt; last = invoker;</span><br><span class="line">        List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);</span><br></pre></td></tr></table></figure><p>我们看如下文件：</p><p> <code>/dubbo-rpc-api/src/main/resources/META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Filter</code> </p><p>默认提供了非常多的过滤器。 然后基于条件激活扩展点，来对invoker进行包装，从而在实现远程调用的时候，会经过这些filter进行过滤。</p><h2 id="export-2"><a href="#export-2" class="headerlink" title="export"></a>export</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        URL url = invoker.getUrl();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取服务标识，理解成服务坐标也行。由服务组名，服务名，服务版本号以及端口组成。比如</span></span><br><span class="line">        <span class="comment">//$&#123;group&#125;/copm.gupaoedu.practice.dubbo.ISayHelloService:$&#123;version&#125;:20880</span></span><br><span class="line">        String key = serviceKey(url);</span><br><span class="line">    <span class="comment">//创建DubboExporter</span></span><br><span class="line">        DubboExporter&lt;T&gt; exporter = <span class="keyword">new</span> DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">    <span class="comment">// 将 &lt;key, exporter&gt; 键值对放入缓存中</span></span><br><span class="line">        exporterMap.put(key, exporter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//export an stub service for dispatching event</span></span><br><span class="line">        Boolean isStubSupportEvent = url.getParameter(STUB_EVENT_KEY, DEFAULT_STUB_EVENT);</span><br><span class="line">        Boolean isCallbackservice = url.getParameter(IS_CALLBACK_SERVICE, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123;</span><br><span class="line">            String stubServiceMethods = url.getParameter(STUB_EVENT_METHODS_KEY);</span><br><span class="line">            <span class="keyword">if</span> (stubServiceMethods == <span class="keyword">null</span> || stubServiceMethods.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="keyword">new</span> IllegalStateException(<span class="string">"consumer ["</span> + url.getParameter(INTERFACE_KEY) +</span><br><span class="line">                            <span class="string">"], has set stubproxy support event ,but no stub methods founded."</span>));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//启动服务</span></span><br><span class="line">        openServer(url);</span><br><span class="line">    <span class="comment">//优化序列化</span></span><br><span class="line">        optimizeSerialization(url);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> exporter;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="openServer"><a href="#openServer" class="headerlink" title="openServer"></a>openServer</h2><p>去开启一个服务，并且放入到缓存中-&gt;在同一台机器上（单网卡），同一个端口上仅允许启动一个服务器实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openServer</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取 host:port，并将其作为服务器实例的 key，用于标识当前的服务器实例</span></span><br><span class="line">        String key = url.getAddress(); </span><br><span class="line">        <span class="comment">////client 也可以暴露一个只有server可以调用的服务</span></span><br><span class="line">        <span class="keyword">boolean</span> isServer = url.getParameter(Constants.IS_SERVER_KEY, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (isServer) &#123;</span><br><span class="line">            <span class="comment">//是否在serverMap中缓存了</span></span><br><span class="line">            ExchangeServer server = serverMap.get(key);</span><br><span class="line">            <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    server = serverMap.get(key);</span><br><span class="line">                    <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 创建服务器实例</span></span><br><span class="line">                        serverMap.put(key, createServer(url));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 服务器已创建，则根据 url 中的配置重置服务器</span></span><br><span class="line">                server.reset(url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="createServer"><a href="#createServer" class="headerlink" title="createServer"></a>createServer</h2><p>创建服务,开启心跳检测，默认使用netty。组装url</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ExchangeServer <span class="title">createServer</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//组装url，在url中添加心跳时间、编解码参数</span></span><br><span class="line">        url = URLBuilder.from(url)</span><br><span class="line">                <span class="comment">// 当服务关闭以后，发送一个只读的事件，默认是开启状态</span></span><br><span class="line">                .addParameterIfAbsent(Constants.CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString())</span><br><span class="line">                <span class="comment">// 启动心跳配置</span></span><br><span class="line">                .addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT))</span><br><span class="line">                .addParameter(Constants.CODEC_KEY, DubboCodec.NAME)</span><br><span class="line">                .build();</span><br><span class="line">        String str = url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_SERVER);</span><br><span class="line"><span class="comment">//通过 SPI 检测是否存在 server 参数所代表的 Transporter 拓展，不存在则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span> &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Unsupported server type: "</span> + str + <span class="string">", url: "</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//创建ExchangeServer.</span></span><br><span class="line">        ExchangeServer server;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server = Exchangers.bind(url, requestHandler);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Fail to start server(url: "</span> + url + <span class="string">") "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        str = url.getParameter(Constants.CLIENT_KEY);</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Set&lt;String&gt; supportedTypes = ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();</span><br><span class="line">            <span class="keyword">if</span> (!supportedTypes.contains(str)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Unsupported client type: "</span> + str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Exchangers-bind"><a href="#Exchangers-bind" class="headerlink" title="Exchangers.bind"></a>Exchangers.bind</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handler == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//获取 Exchanger，默认为 HeaderExchanger。</span></span><br><span class="line">    <span class="comment">//调用 HeaderExchanger 的 bind 方法创建 ExchangeServer 实例</span></span><br><span class="line">        url = url.addParameterIfAbsent(Constants.CODEC_KEY, <span class="string">"exchange"</span>);</span><br><span class="line">        <span class="keyword">return</span> getExchanger(url).bind(url, handler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="headerExchanger-bind"><a href="#headerExchanger-bind" class="headerlink" title="headerExchanger.bind"></a>headerExchanger.bind</h2><p>这里面包含多个逻辑</p><ul><li>new DecodeHandler(new HeaderExchangeHandler(handler))</li><li>Transporters.bind</li><li>new HeaderExchangeServer</li></ul><p>目前我们只需要关心transporters.bind方法即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeaderExchangeServer(Transporters.bind(url, <span class="keyword">new</span> DecodeHandler(<span class="keyword">new</span> HeaderExchangeHandler(handler))));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Transporters-bind"><a href="#Transporters-bind" class="headerlink" title="Transporters.bind"></a>Transporters.bind</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Server <span class="title">bind</span><span class="params">(URL url, ChannelHandler... handlers)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handlers == <span class="keyword">null</span> || handlers.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handlers == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ChannelHandler handler;</span><br><span class="line">        <span class="keyword">if</span> (handlers.length == <span class="number">1</span>) &#123;</span><br><span class="line">            handler = handlers[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 handlers 元素数量大于1，则创建 ChannelHandler 分发器</span></span><br><span class="line">            handler = <span class="keyword">new</span> ChannelHandlerDispatcher(handlers);</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">// 获取自适应 Transporter 实例，并调用实例方法</span></span><br><span class="line">        <span class="keyword">return</span> getTransporter().bind(url, handler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="getTransporter"><a href="#getTransporter" class="headerlink" title="getTransporter"></a>getTransporter</h2><p>getTransporter是一个自适应扩展点，它针对bind方法添加了自适应注解，意味着，bing方法的具体实现，会基于Transporter$Adaptive方法进行适配，那么在这里面默认的通信协议是netty，所以它会采用netty4的实现，也就是<code>org.apache.dubbo.remoting.transport.netty4.NettyTransporter</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static Transporter getTransporter() &#123;    return ExtensionLoader.getExtensionLoader(Transporter.class).getAdaptiveExtension();&#125;</span><br></pre></td></tr></table></figure><h2 id="NettyTransporter-bind"><a href="#NettyTransporter-bind" class="headerlink" title="NettyTransporter.bind"></a>NettyTransporter.bind</h2><p>创建一个nettyserver</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">bind</span><span class="params">(URL url, ChannelHandler listener)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NettyServer(url, listener);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="NettyServer"><a href="#NettyServer" class="headerlink" title="NettyServer"></a>NettyServer</h1><p>初始化一个nettyserver，并且从url中获得相应的ip/ port。然后调用<code>doOpen();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractServer</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(url, handler);</span><br><span class="line">        localAddress = getUrl().toInetSocketAddress();</span><br><span class="line">        <span class="comment">// 获取 ip 和端口</span></span><br><span class="line">        String bindIp = getUrl().getParameter(Constants.BIND_IP_KEY, getUrl().getHost());</span><br><span class="line">        <span class="keyword">int</span> bindPort = getUrl().getParameter(Constants.BIND_PORT_KEY, getUrl().getPort());</span><br><span class="line">        <span class="keyword">if</span> (url.getParameter(Constants.ANYHOST_KEY, <span class="keyword">false</span>) || NetUtils.isInvalidLocalHost(bindIp)) &#123;</span><br><span class="line">            bindIp = Constants.ANYHOST_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        bindAddress = <span class="keyword">new</span> InetSocketAddress(bindIp, bindPort);</span><br><span class="line">        <span class="keyword">this</span>.accepts = url.getParameter(Constants.ACCEPTS_KEY, Constants.DEFAULT_ACCEPTS);</span><br><span class="line">        <span class="keyword">this</span>.idleTimeout = url.getParameter(Constants.IDLE_TIMEOUT_KEY, Constants.DEFAULT_IDLE_TIMEOUT);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doOpen();<span class="comment">// 调用模板方法 doOpen 启动服务器</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"Start "</span> + getClass().getSimpleName() + <span class="string">" bind "</span> + getBindAddress() + <span class="string">", export "</span> + getLocalAddress());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(url.toInetSocketAddress(), <span class="keyword">null</span>, <span class="string">"Failed to bind "</span> + getClass().getSimpleName()</span><br><span class="line">                    + <span class="string">" on "</span> + getLocalAddress() + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//fixme replace this with better method</span></span><br><span class="line">        DataStore dataStore = ExtensionLoader.getExtensionLoader(DataStore.class).getDefaultExtension();</span><br><span class="line">        executor = (ExecutorService) dataStore.get(Constants.EXECUTOR_SERVICE_COMPONENT_KEY, Integer.toString(url.getPort()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="doOpen"><a href="#doOpen" class="headerlink" title="doOpen"></a>doOpen</h2><p>开启netty服务,这个又是大家熟悉的内容了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">        bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>, <span class="keyword">new</span> DefaultThreadFactory(<span class="string">"NettyServerBoss"</span>, <span class="keyword">true</span>));</span><br><span class="line">        workerGroup = <span class="keyword">new</span> NioEventLoopGroup(getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS),</span><br><span class="line">                <span class="keyword">new</span> DefaultThreadFactory(<span class="string">"NettyServerWorker"</span>, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> NettyServerHandler nettyServerHandler = <span class="keyword">new</span> NettyServerHandler(getUrl(), <span class="keyword">this</span>);</span><br><span class="line">        channels = nettyServerHandler.getChannels();</span><br><span class="line"></span><br><span class="line">        bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childOption(ChannelOption.TCP_NODELAY, Boolean.TRUE)</span><br><span class="line">                .childOption(ChannelOption.SO_REUSEADDR, Boolean.TRUE)</span><br><span class="line">                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">// <span class="doctag">FIXME:</span> should we use getTimeout()?</span></span><br><span class="line">                        <span class="keyword">int</span> idleTimeout = UrlUtils.getIdleTimeout(getUrl());</span><br><span class="line">                        NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyServer.<span class="keyword">this</span>);</span><br><span class="line">                        ch.pipeline()<span class="comment">//.addLast("logging",new LoggingHandler(LogLevel.INFO))//for debug</span></span><br><span class="line">                                .addLast(<span class="string">"decoder"</span>, adapter.getDecoder())</span><br><span class="line">                                .addLast(<span class="string">"encoder"</span>, adapter.getEncoder())</span><br><span class="line">                                .addLast(<span class="string">"server-idle-handler"</span>, <span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">0</span>, idleTimeout, MILLISECONDS))</span><br><span class="line">                                .addLast(<span class="string">"handler"</span>, nettyServerHandler);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// bind</span></span><br><span class="line">        ChannelFuture channelFuture = bootstrap.bind(getBindAddress());</span><br><span class="line">        channelFuture.syncUninterruptibly();</span><br><span class="line">        channel = channelFuture.channel();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后大家要注意的是，它这里用到了一个handler来处理客户端传递过来的请求:</p><p>nettyServerHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NettyServerHandler nettyServerHandler = <span class="keyword">new</span> NettyServerHandler(getUrl(), <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>这个handler是一个链路，它的正确组成应该是</p><p>MultiMessageHandler(heartbeatHandler(AllChannelHandler(DecodeHandler(HeaderExchangeHeadler(dubboProtocol</p><p>后续接收到的请求，会一层一层的处理。比较繁琐</p><h1 id="Invoker是什么"><a href="#Invoker是什么" class="headerlink" title="Invoker是什么"></a>Invoker是什么</h1><p>从前面的分析来看，服务的发布分三个阶段</p><p>第一个阶段会创造一个invoker</p><p>第二个阶段会把经历过一系列处理的invoker（各种包装），在DubboProtocol中保存到exporterMap中</p><p>第三个阶段把dubbo协议的url地址注册到注册中心上</p><p>前面没有分析Invoker，我们来简单看看Invoker到底是一个啥东西。</p><p>Invoker是Dubbo领域模型中非常重要的一个概念, 和ExtensionLoader的重要性是一样的，如果Invoker没有搞懂，那么不算是看懂了Dubbo的源码。我们继续回到ServiceConfig中export的代码，这段代码是还没有分析过的。以这个作为入口来分析我们前面export出去的invoker到底是啥东西</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));</span><br></pre></td></tr></table></figure><h2 id="ProxyFacotory-getInvoker"><a href="#ProxyFacotory-getInvoker" class="headerlink" title="ProxyFacotory.getInvoker"></a>ProxyFacotory.getInvoker</h2><p>这个是一个代理工程，用来生成invoker，从它的定义来看，它是一个自适应扩展点，看到这样的扩展点，我们几乎可以不假思索的想到它会存在一个动态适配器类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();</span><br></pre></td></tr></table></figure><h2 id="ProxyFactory"><a href="#ProxyFactory" class="headerlink" title="ProxyFactory"></a>ProxyFactory</h2><p>这个方法的简单解读为： 它是一个spi扩展点，并且默认的扩展实现是javassit, 这个接口中有三个方法，并且都是加了@Adaptive的自适应扩展点。所以如果调用getInvoker方法，应该会返回一个ProxyFactory$Adaptive</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"javassist"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, <span class="keyword">boolean</span> generic)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException</span>;</span><br></pre></td></tr></table></figure><h2 id="ProxyFactory-Adaptive"><a href="#ProxyFactory-Adaptive" class="headerlink" title="ProxyFactory$Adaptive"></a>ProxyFactory$Adaptive</h2><p>这个自适应扩展点，做了两件事情</p><ul><li>通过ExtensionLoader.getExtensionLoader(ProxyFactory.class).getExtension(extName)获取了一个指定名称的扩展点,</li><li>在dubbo-rpc-api/resources/META-INF/com.alibaba.dubbo.rpc.ProxyFactory中，定义了javassis=JavassisProxyFactory</li><li>调用JavassisProxyFactory的getInvoker方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">dubbo</span>.<span class="title">rpc</span>.<span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">getProxy</span><span class="params">(org.apache.dubbo.rpc.Invoker arg0)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.Invoker argument == null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg0.getUrl() == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.Invoker argument getUrl() == null"</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class="line">        String extName = url.getParameter(<span class="string">"proxy"</span>, <span class="string">"javassist"</span>);</span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.rpc.ProxyFactory) name from url ("</span> + url.toString() + <span class="string">") use keys([proxy])"</span>);</span><br><span class="line">        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.getProxy(arg0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">getProxy</span><span class="params">(org.apache.dubbo.rpc.Invoker arg0, <span class="keyword">boolean</span> arg1)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.Invoker argument == null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg0.getUrl() == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.Invoker argument getUrl() == null"</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class="line">        String extName = url.getParameter(<span class="string">"proxy"</span>, <span class="string">"javassist"</span>);</span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.rpc.ProxyFactory) name from url ("</span> + url.toString() + <span class="string">") use keys([proxy])"</span>);</span><br><span class="line">        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.getProxy(arg0, arg1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.<span class="function">Invoker <span class="title">getInvoker</span><span class="params">(java.lang.Object arg0, java.lang.Class arg1, org.apache.dubbo.common.URL arg2)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg2 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg2;</span><br><span class="line">        String extName = url.getParameter(<span class="string">"proxy"</span>, <span class="string">"javassist"</span>);</span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.rpc.ProxyFactory) name from url ("</span> + url.toString() + <span class="string">") use keys([proxy])"</span>);</span><br><span class="line">        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.getInvoker(arg0, arg1, arg2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavassistProxyFactory-getInvoker"><a href="#JavassistProxyFactory-getInvoker" class="headerlink" title="JavassistProxyFactory.getInvoker"></a>JavassistProxyFactory.getInvoker</h2><p>javassist是一个动态类库，用来实现动态代理的。</p><p>proxy:接口的实现: com.gupaoedu.practice.dubbo.SayHelloServiceImpl</p><p>type:接口全称 com.gupaoedu.dubbo.ISayHelloService</p><p>url:协议地址：registry://…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Wrapper cannot handle this scenario correctly: the classname contains '$'</span></span><br><span class="line">        <span class="keyword">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class="string">'$'</span>) &lt; <span class="number">0</span> ? proxy.getClass() : type);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Object[] arguments)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="javassist生成的动态代理代码"><a href="#javassist生成的动态代理代码" class="headerlink" title="javassist生成的动态代理代码"></a>javassist生成的动态代理代码</h2><p>通过断点的方式（Wrapper258行），在Wrapper.getWrapper中的makeWrapper，会创建一个动态代理，核心的方法invokeMethod代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invokeMethod</span><span class="params">(Object o, String n, Class[] p, Object[] v)</span> <span class="keyword">throws</span> java.lang.reflect.InvocationTargetException </span>&#123;</span><br><span class="line">        com.gupaoedu.dubbo.practice.ISayHelloService w;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            w = ((com.gupaoedu.dubbo.practice.ISayHelloService) $<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"sayHello"</span>.equals($<span class="number">2</span>) &amp;&amp; $<span class="number">3</span>.length == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ($w) w.sayHello((java.lang.String) $<span class="number">4</span>[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.lang.reflect.InvocationTargetException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> org.apache.dubbo.common.bytecode.NoSuchMethodException(<span class="string">"Not found method \""</span> + $<span class="number">2</span> + <span class="string">"\" in class com.gupaoedu.dubbo.practice.ISayHelloService."</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>构建好了代理类之后，返回一个AbstractproxyInvoker,并且它实现了doInvoke方法，这个地方似乎看到了dubbo消费者调用过来的时候触发的影子，因为wrapper.invokeMethod本质上就是触发上面动态代理类的方法invokeMethod.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Object[] arguments)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>所以，简单总结一下Invoke本质上应该是一个代理，经过层层包装最终进行了发布。当消费者发起请求的时候，会获得这个invoker进行调用。</p><p>最终发布出去的invoker, 也不是单纯的一个代理，也是经过多层包装</p><p>InvokerDelegate(DelegateProviderMetaDataInvoker(AbstractProxyInvoker()))</p><h1 id="服务注册流程"><a href="#服务注册流程" class="headerlink" title="服务注册流程"></a>服务注册流程</h1><p>关于服务发布这一条线分析完成之后，再来了解一下服务注册的过程，希望大家还记得我们之所以走到这一步，是因为我们在RegistryProtocol这个类中，看到了服务发布的流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class="line">        <span class="comment">// url to export locally</span></span><br><span class="line">        URL providerUrl = getProviderUrl(originInvoker);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Subscribe the override data</span></span><br><span class="line">        <span class="comment">// FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call</span></span><br><span class="line">        <span class="comment">//  the same service. Because the subscribed is cached key with the name of the service, it causes the</span></span><br><span class="line">        <span class="comment">//  subscription information to cover.</span></span><br><span class="line">        <span class="keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(providerUrl);</span><br><span class="line">        <span class="keyword">final</span> OverrideListener overrideSubscribeListener = <span class="keyword">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class="line">        overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line"></span><br><span class="line">        providerUrl = overrideUrlWithConfig(providerUrl, overrideSubscribeListener);</span><br><span class="line">        <span class="comment">//export invoker</span></span><br><span class="line">        <span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker, providerUrl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// url to registry</span></span><br><span class="line">        <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line">        <span class="keyword">final</span> URL registeredProviderUrl = getRegisteredProviderUrl(providerUrl, registryUrl);</span><br><span class="line">        ProviderInvokerWrapper&lt;T&gt; providerInvokerWrapper = ProviderConsumerRegTable.registerProvider(originInvoker,</span><br><span class="line">                registryUrl, registeredProviderUrl);</span><br><span class="line">        <span class="comment">//to judge if we need to delay publish</span></span><br><span class="line">        <span class="keyword">boolean</span> register = registeredProviderUrl.getParameter(<span class="string">"register"</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (register) &#123;</span><br><span class="line">            register(registryUrl, registeredProviderUrl);</span><br><span class="line">            providerInvokerWrapper.setReg(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Deprecated! Subscribe to override rules in 2.6.x or before.</span></span><br><span class="line">        registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line"></span><br><span class="line">        exporter.setRegisterUrl(registeredProviderUrl);</span><br><span class="line">        exporter.setSubscribeUrl(overrideSubscribeUrl);</span><br><span class="line">        <span class="comment">//Ensure that a new exporter instance is returned every time export</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DestroyableExporter&lt;&gt;(exporter);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="服务注册核心代码"><a href="#服务注册核心代码" class="headerlink" title="服务注册核心代码"></a>服务注册核心代码</h2><p>从export方法中抽离出来的部分代码，就是服务注册的流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// url to registry</span></span><br><span class="line">        <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line">        <span class="keyword">final</span> URL registeredProviderUrl = getRegisteredProviderUrl(providerUrl, registryUrl);</span><br><span class="line">        ProviderInvokerWrapper&lt;T&gt; providerInvokerWrapper = ProviderConsumerRegTable.registerProvider(originInvoker,</span><br><span class="line">                registryUrl, registeredProviderUrl);</span><br><span class="line">        <span class="comment">//to judge if we need to delay publish</span></span><br><span class="line">        <span class="keyword">boolean</span> register = registeredProviderUrl.getParameter(<span class="string">"register"</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (register) &#123;</span><br><span class="line">            register(registryUrl, registeredProviderUrl);</span><br><span class="line">            providerInvokerWrapper.setReg(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="getRegistry"><a href="#getRegistry" class="headerlink" title="getRegistry"></a>getRegistry</h2><ol><li>把url转化为对应配置的注册中心的具体协议</li><li>根据具体协议，从registryFactory中获得指定的注册中心实现</li></ol><p>那么这个registryFactory具体是怎么赋值的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Registry <span class="title">getRegistry</span><span class="params">(<span class="keyword">final</span> Invoker&lt;?&gt; originInvoker)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把url转化为配置的具体协议，比如zookeeper://ip:port. 这样后续获得的注册中心就会是基于zk的实现</span></span><br><span class="line">        URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class="line">        <span class="keyword">return</span> registryFactory.getRegistry(registryUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在RegistryProtocol中存在一段这样的代码，很明显这是通过依赖注入来实现的扩展点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RegistryFactory registryFactory; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRegistryFactory</span><span class="params">(RegistryFactory registryFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.registryFactory = registryFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照扩展点的加载规则，我们可以先看看/META-INF/dubbo/internal路径下找到RegistryFactory的配置文件.这个factory有多个扩展点的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dubbo=org.apache.dubbo.registry.dubbo.DubboRegistryFactory</span><br><span class="line">multicast=org.apache.dubbo.registry.multicast.MulticastRegistryFactory</span><br><span class="line">zookeeper=org.apache.dubbo.registry.zookeeper.ZookeeperRegistryFactory</span><br><span class="line">redis=org.apache.dubbo.registry.redis.RedisRegistryFactory</span><br><span class="line">consul=org.apache.dubbo.registry.consul.ConsulRegistryFactory</span><br><span class="line"></span><br><span class="line">etcd3=org.apache.dubbo.registry.etcd.EtcdRegistryFactory</span><br></pre></td></tr></table></figure><p>接着，找到RegistryFactory的实现, 发现它里面有一个自适应的方法，根据url中protocol传入的值进行适配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"dubbo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RegistryFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;<span class="string">"protocol"</span>&#125;)</span><br><span class="line">    <span class="function">Registry <span class="title">getRegistry</span><span class="params">(URL url)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="RegistryFactory-Adaptive"><a href="#RegistryFactory-Adaptive" class="headerlink" title="RegistryFactory$Adaptive"></a>RegistryFactory$Adaptive</h2><p>由于在前面的代码中，url中的protocol已经改成了zookeeper，那么这个时候根据zookeeper获得的spi扩展点应该是ZookeeperRegistryFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegistryFactory</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">dubbo</span>.<span class="title">registry</span>.<span class="title">RegistryFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.registry.<span class="function">Registry <span class="title">getRegistry</span><span class="params">(org.apache.dubbo.common.URL arg0)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg0;</span><br><span class="line">        String extName = ( url.getProtocol() == <span class="keyword">null</span> ? <span class="string">"dubbo"</span> : url.getProtocol() );</span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.registry.RegistryFactory) name from url ("</span> + url.toString() + <span class="string">") use keys([protocol])"</span>);</span><br><span class="line">        org.apache.dubbo.registry.RegistryFactory extension = (org.apache.dubbo.registry.RegistryFactory)ExtensionLoader.getExtensionLoader(org.apache.dubbo.registry.RegistryFactory.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.getRegistry(arg0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ZookeeperRegistryFactory"><a href="#ZookeeperRegistryFactory" class="headerlink" title="ZookeeperRegistryFactory"></a>ZookeeperRegistryFactory</h2><p>这个方法中并没有getRegistry方法，而是在父类AbstractRegistryFactory</p><ul><li>从缓存REGISTRIES中，根据key获得对应的Registry</li><li>如果不存在，则创建Registry</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Registry <span class="title">getRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        url = URLBuilder.from(url)</span><br><span class="line">                .setPath(RegistryService.class.getName())</span><br><span class="line">                .addParameter(Constants.INTERFACE_KEY, RegistryService.class.getName())</span><br><span class="line">                .removeParameters(Constants.EXPORT_KEY, Constants.REFER_KEY)</span><br><span class="line">                .build();</span><br><span class="line">        String key = url.toServiceStringWithoutResolving();</span><br><span class="line">        <span class="comment">// Lock the registry access process to ensure a single instance of the registry</span></span><br><span class="line">        LOCK.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Registry registry = REGISTRIES.get(key);</span><br><span class="line">            <span class="keyword">if</span> (registry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> registry;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//创建注册中心</span></span><br><span class="line">            registry = createRegistry(url);</span><br><span class="line">            <span class="keyword">if</span> (registry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Can not create registry "</span> + url);</span><br><span class="line">            &#125;</span><br><span class="line">            REGISTRIES.put(key, registry);</span><br><span class="line">            <span class="keyword">return</span> registry;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Release the lock</span></span><br><span class="line">            LOCK.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="createRegistry"><a href="#createRegistry" class="headerlink" title="createRegistry"></a>createRegistry</h2><p>创建一个zookeeperRegistry，把url和zookeepertransporter作为参数传入。</p><p>zookeeperTransporter 这个属性也是基于依赖注入来赋值的，具体的流程就不再分析了，这个的值应该是</p><p><code>CuratorZookeeperTransporter</code> 表示具体使用什么框架来和zk产生连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Registry <span class="title">createRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ZookeeperRegistry(url, zookeeperTransporter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ZookeeperRegistry"><a href="#ZookeeperRegistry" class="headerlink" title="ZookeeperRegistry"></a>ZookeeperRegistry</h2><p>这个方法中使用了CuratorZookeeperTransport来实现zk的连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZookeeperRegistry</span><span class="params">(URL url, ZookeeperTransporter zookeeperTransporter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(url);</span><br><span class="line">        <span class="keyword">if</span> (url.isAnyHost()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"registry address == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//获得group名称</span></span><br><span class="line">        String group = url.getParameter(Constants.GROUP_KEY, DEFAULT_ROOT);</span><br><span class="line">        <span class="keyword">if</span> (!group.startsWith(Constants.PATH_SEPARATOR)) &#123;</span><br><span class="line">            group = Constants.PATH_SEPARATOR + group;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.root = group;</span><br><span class="line">    <span class="comment">//产生一个zookeeper连接</span></span><br><span class="line">        zkClient = zookeeperTransporter.connect(url);</span><br><span class="line">    <span class="comment">//添加zookeeper状态变化事件</span></span><br><span class="line">        zkClient.addStateListener(state -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (state == StateListener.RECONNECTED) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    recover();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    logger.error(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="registry-register-registedProviderUrl"><a href="#registry-register-registedProviderUrl" class="headerlink" title="registry.register(registedProviderUrl);"></a>registry.register(registedProviderUrl);</h2><p>继续往下分析，会调用registry.register去讲dubbo://的协议地址注册到zookeeper上</p><p>这个方法会调用FailbackRegistry类中的register. 为什么呢？因为ZookeeperRegistry这个类中并没有register这个方法，但是他的父类FailbackRegistry中存在register方法，而这个类又重写了AbstractRegistry类中的register方法。所以我们可以直接定位大FailbackRegistry这个类中的register方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">register(registryUrl, registeredProviderUrl);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL registryUrl, URL registeredProviderUrl)</span> </span>&#123;</span><br><span class="line">        Registry registry = registryFactory.getRegistry(registryUrl);</span><br><span class="line">        registry.register(registeredProviderUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FailbackRegistry-register"><a href="#FailbackRegistry-register" class="headerlink" title="FailbackRegistry.register"></a>FailbackRegistry.register</h2><ul><li>FailbackRegistry，从名字上来看，是一个失败重试机制</li><li>调用父类的register方法，讲当前url添加到缓存集合中</li></ul><p>调用doRegister方法，这个方法很明显，是一个抽象方法，会由ZookeeperRegistry子类实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.register(url);</span><br><span class="line">        removeFailedRegistered(url);</span><br><span class="line">        removeFailedUnregistered(url);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用子类实现真正的服务注册，把url注册到zk上</span></span><br><span class="line">            doRegister(url);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Throwable t = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果开启了启动时检测，则直接抛出异常</span></span><br><span class="line">            <span class="keyword">boolean</span> check = getUrl().getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)</span><br><span class="line">                    &amp;&amp; url.getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)</span><br><span class="line">                    &amp;&amp; !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol());</span><br><span class="line">            <span class="keyword">boolean</span> skipFailback = t <span class="keyword">instanceof</span> SkipFailbackWrapperException;</span><br><span class="line">            <span class="keyword">if</span> (check || skipFailback) &#123;</span><br><span class="line">                <span class="keyword">if</span> (skipFailback) &#123;</span><br><span class="line">                    t = t.getCause();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to register "</span> + url + <span class="string">" to registry "</span> + getUrl().getAddress() + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.error(<span class="string">"Failed to register "</span> + url + <span class="string">", waiting for retry, cause: "</span> + t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将失败的注册请求记录到失败列表，定时重试</span></span><br><span class="line">            addFailedRegistered(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="ZookeeperRegistry-doRegister"><a href="#ZookeeperRegistry-doRegister" class="headerlink" title="ZookeeperRegistry.doRegister"></a>ZookeeperRegistry.doRegister</h2><p>最终调用curator的客户端把服务地址注册到zk</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, <span class="keyword">true</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to register "</span> + url + <span class="string">" to zookeeper "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;按照前面课程对于dubbo的理解，如果要实现服务发布和注册，需要做哪些事情？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;配置文件解析或者注解解析&lt;/li&gt;
&lt;li&gt;服务注册&lt;/li&gt;
&lt;li&gt;启动netty服务实现远程监听
    
    </summary>
    
      <category term="源码分析" scheme="https://istio.tech/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="源码分析" scheme="https://istio.tech/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="Dubbo" scheme="https://istio.tech/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析系列之SPI机制</title>
    <link href="https://istio.tech/2019/07/25/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BSPI%E6%9C%BA%E5%88%B6/"/>
    <id>https://istio.tech/2019/07/25/Dubbo源码分析系列之SPI机制/</id>
    <published>2019-07-25T05:12:00.000Z</published>
    <updated>2019-07-25T05:19:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文的源码是基于Dubbo2.7.2版本进行的分析，请大家注意一下代码的变化</p><p>另外，源码这块的量比较多，而且处理过程比较复杂，为了让大家更好的理解呢？ 我打算分几个步骤来讲。</p><p>首先，把Dubbo里面用得比较多的SPI机制做一个详细的分析</p><a id="more"></a><h1 id="Dubbo中的SPI机制"><a href="#Dubbo中的SPI机制" class="headerlink" title="Dubbo中的SPI机制"></a>Dubbo中的SPI机制</h1><p>在Dubbo中，SPI贯穿在整个Dubbo的核心。所以有必要对spi做一个想尽的讲解，这个知识点必须理解。</p><p>之前咱们讲过SpringFactoriesLoader, 它也是一种spi机制。大家在学习的时候，一定要把学到的工具好好好好保存在脑子里，以后自己在创造一些东西时，可以拿出来用。</p><p>SPI机制在很多地方都有用到。</p><h2 id="关于Java-SPI"><a href="#关于Java-SPI" class="headerlink" title="关于Java SPI"></a>关于Java SPI</h2><p>了解Dubbo里面的SPI机制之前，我们先了解下Java提供的SPI（service provider interface）机制，SPI是JDK内置的一种服务提供发现机制。目前市面上有很多框架都是用它来做服务的扩展发现。简单来说，它是一种动态替换发现的机制。举个简单的例子，我们想在运行时动态给它添加实现，你只需要添加一个实现，然后把新的实现描述给JDK知道就行了。大家耳熟能详的如JDBC、日志框架都有用到</p><p><img src="/images/1564029268124.png" alt="1564029268124"></p><h3 id="实现SPI需要遵循的标准"><a href="#实现SPI需要遵循的标准" class="headerlink" title="实现SPI需要遵循的标准"></a>实现SPI需要遵循的标准</h3><p>我们如何去实现一个标准的SPI发现机制呢？其实很简单，只需要满足以下提交就行了</p><p>\1.  需要在classpath下创建一个目录，该目录命名必须是：META-INF/service</p><p>\2.  在该目录下创建一个properties文件，该文件需要满足以下几个条件 </p><p>2.1 文件名必须是扩展的接口的全路径名称 </p><p>2.2 文件内部描述的是该扩展接口的所有实现类 </p><p>2.3 文件的编码格式是UTF-8</p><p>\3.  通过java.util.ServiceLoader的加载机制来发现</p><p><img src="/images/1564029281905.png" alt="1564029281905"></p><h3 id="SPI的实际应用"><a href="#SPI的实际应用" class="headerlink" title="SPI的实际应用"></a>SPI的实际应用</h3><p>SPI在很多地方有应用，可能大家都没有关注，最常用的就是JDBC驱动，我们来看看是怎么应用的 </p><p>JDK本身提供了数据访问的api。在java.sql这个包里面 </p><p>我们在连接数据库的时候，一定需要用到java.sql.Driver这个接口对吧。然后我好奇的去看了下java.sql.Driver的源码，发现Driver并没有实现，而是提供了一套标准的api接口。大家有兴趣可以去看看 </p><p>因为我们在实际应用中用的比较多的是mysql，所以我去mysql的包里面看到一个如下的目录结构</p><p><img src="/images/1564029334118.png" alt="1564029334118"></p><p>这个文件里面写的就是mysql的驱动实现。我恍然大悟，原来通过SPI机制把java.sql.Driver和mysql的驱动做了集成。这样就达到了各个数据库厂商自己去实现数据库连接，jdk本身不关心你怎么实现。</p><h3 id="SPI的缺点"><a href="#SPI的缺点" class="headerlink" title="SPI的缺点"></a>SPI的缺点</h3><p>\1.  JDK标准的SPI会一次性加载实例化扩展点的所有实现，什么意思呢？就是如果你在META-INF/service下的文件里面加了N个实现类，那么JDK启动的时候都会一次性全部加载。那么如果有的扩展点实现初始化很耗时或者如果有些实现类并没有用到，那么会很浪费资源</p><p>\2.  如果扩展点加载失败，会导致调用方报错，而且这个错误很难定位到是这个原因</p><h2 id="Dubbo优化后的SPI机制"><a href="#Dubbo优化后的SPI机制" class="headerlink" title="Dubbo优化后的SPI机制"></a>Dubbo优化后的SPI机制</h2><h3 id="基于Dubbo-SPI的实现自己的扩展"><a href="#基于Dubbo-SPI的实现自己的扩展" class="headerlink" title="基于Dubbo SPI的实现自己的扩展"></a>基于Dubbo SPI的实现自己的扩展</h3><p>Dubbo的SPI扩展机制，有两个规则</p><p>\1.    需要在resource目录下配置META-INF/dubbo或者META-INF/dubbo/internal或者META-INF/services，并基于SPI接口去创建一个文件</p><p>\2.  文件名称和接口名称保持一致，文件内容和SPI有差异，内容是KEY对应Value</p><p>Dubbo针对的扩展点非常多，可以针对协议、拦截、集群、路由、负载均衡、序列化、容器… 几乎里面用到的所有功能，都可以实现自己的扩展，我觉得这个是dubbo比较强大的一点。</p><p><img src="/images/1564029365865.png" alt="1564029365865"></p><p>比如我们可以针对协议做一个扩展</p><h3 id="扩展协议扩展点"><a href="#扩展协议扩展点" class="headerlink" title="扩展协议扩展点"></a>扩展协议扩展点</h3><p>\1.    创建如下结构，添加META-INF.dubbo文件。类名和Dubbo提供的协议扩展点接口保持一致</p><p><img src="/images/1564029371563.png" alt="1564029371563"></p><p>\2.  创建MyProtocol协议类</p><p>可以实现自己的协议，我们为了模拟协议产生了作用，修改一个端口</p><p><img src="/images/1564029376290.png" alt="1564029376290"></p><p>\3.  在调用处执行如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Protocol protocol=ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(<span class="string">"myProtocol"</span>);</span><br><span class="line">System.out.print(protocol.getDefaultPort)</span><br></pre></td></tr></table></figure><p>\4.  输出结果，可以看到运行结果，是执行的自定义的协议扩展点。</p><p>总结：总的来说，思路和SPI是差不多。都是基于约定的路径下制定配置文件。目的，通过配置的方式轻松实现功能的扩展。</p><p>我们的猜想是，一定有一个地方通过读取指定路径下的所有文件进行load。然后讲对应的结果保存到一个map中，key对应为名称，value对应为实现类。那么这个实现，一定就在ExtensionLoader中了。接下来我们就可以基于这个猜想去看看代码的实现。</p><h2 id="Dubbo的扩展点原理实现"><a href="#Dubbo的扩展点原理实现" class="headerlink" title="Dubbo的扩展点原理实现"></a>Dubbo的扩展点原理实现</h2><p>在看它的实现代码之前，大家要思考一个问题，所谓的扩展点，就是通过指定目录下配置一个对应接口的实现类，然后程序会进行查找和解析，找到对应的扩展点。那么这里就涉及到两个问题</p><ol><li>怎么解析</li><li>被加载的类如何存储和使用？</li></ol><h3 id="ExtensionLoader-getExtensionLoader-getExtension"><a href="#ExtensionLoader-getExtensionLoader-getExtension" class="headerlink" title="ExtensionLoader.getExtensionLoader.getExtension"></a>ExtensionLoader.getExtensionLoader.getExtension</h3><p>我们从这段代码着手，去看看到底做了什么事情，能够通过这样一段代码实现扩展协议的查找和加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ExtensionLoader&lt;T&gt; <span class="title">getExtensionLoader</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension type == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!type.isInterface()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension type ("</span> + type + <span class="string">") is not an interface!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!withExtensionAnnotation(type)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension type ("</span> + type +</span><br><span class="line">                    <span class="string">") is not an extension, because it is NOT annotated with @"</span> + SPI.class.getSimpleName() + <span class="string">"!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//初始化ExtensionLoader</span></span><br><span class="line">        ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">        <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            EXTENSION_LOADERS.putIfAbsent(type, <span class="keyword">new</span> ExtensionLoader&lt;T&gt;(type));</span><br><span class="line">            loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> loader;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="实例化ExtensionLoader"><a href="#实例化ExtensionLoader" class="headerlink" title="实例化ExtensionLoader"></a>实例化ExtensionLoader</h3><p>如果当前的type=ExtensionFactory,type，那么objectFactory=null, 否则会创建一个自适应扩展点给到objectFacotry,目前来说具体做什么咱们先不关心</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ExtensionLoader</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">    objectFactory = (type == ExtensionFactory.class ? <span class="keyword">null</span> : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>objectFactory在这里赋值了，并且是返回一个AdaptiveExtension(). 这个暂时不展开，后面再分析</strong></p><h3 id="getExtension"><a href="#getExtension" class="headerlink" title="getExtension"></a>getExtension</h3><p>这个方法就是根据一个名字来获得一个对应类的实例，所以我们来猜想一下，回想一下前面咱们配置的自定义协议，name实际上就是myprotocol，而返回的实现类应该就是MyProtocol。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension name == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"true"</span>.equals(name)) &#123; <span class="comment">//如果name=true，表示返回一个默认的扩展点，思考一下什么是默认的？</span></span><br><span class="line">        <span class="keyword">return</span> getDefaultExtension();</span><br><span class="line">    &#125;</span><br><span class="line">    Holder&lt;Object&gt; holder = getOrCreateHolder(name);</span><br><span class="line">    Object instance = holder.get(); <span class="comment">//缓存一下,如果实例已经加载过了，直接从缓存读取</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (holder) &#123;</span><br><span class="line">            instance = holder.get();</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                instance = createExtension(name); <span class="comment">//根据名称创建实例</span></span><br><span class="line">                holder.set(instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="createExtension"><a href="#createExtension" class="headerlink" title="createExtension"></a>createExtension</h3><p> 仍然是根据名称创建扩展:getExtensionClasses() 加载指定路径下的所有文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123; <span class="comment">//如果没有找到，则抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> findException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//这里用一个chm来保存实例，做缓存</span></span><br><span class="line">        T instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());</span><br><span class="line">            instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//实例注入，可以猜到，这里应该是对这个实例中的成员属性来实现依赖注入的功能</span></span><br><span class="line">        injectExtension(instance);</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(wrapperClasses)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class="line">                instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Extension instance (name: "</span> + name + <span class="string">", class: "</span> +</span><br><span class="line">                type + <span class="string">") couldn't be instantiated: "</span> + t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getExtensionClasses"><a href="#getExtensionClasses" class="headerlink" title="getExtensionClasses"></a>getExtensionClasses</h3><p> 这个方法，会查找指定目录<br>/META-INF/dubbo || /META-INF/services 下对应的type-&gt;也就是本次演示案例的Protocol的properties文件，然后扫描这个文件下的所有配置信息。然后保存到一个HashMap中（classes），key=name(对应protocol文件中配置的myprotocol), value=对应配置的类的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();</span><br><span class="line">    <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (cachedClasses) &#123;</span><br><span class="line">            classes = cachedClasses.get();</span><br><span class="line">            <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                classes = loadExtensionClasses(); <span class="comment">//这里的代码就是加载的过程</span></span><br><span class="line">                cachedClasses.set(classes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="injectExtension"><a href="#injectExtension" class="headerlink" title="injectExtension"></a>injectExtension</h3><p>这个方法是用来实现依赖注入的，如果被加载的实例中，有成员属性本身也是一个扩展点，则会通过set方法进行注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">injectExtension</span><span class="params">(T instance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (objectFactory != <span class="keyword">null</span>) &#123; <span class="comment">//objectFactory在这里用到了</span></span><br><span class="line">            <span class="comment">//获得实例对应的方法，判断方法是否是一个set方法</span></span><br><span class="line">            <span class="keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isSetter(method)) &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * Check &#123;<span class="doctag">@link</span> DisableInject&#125; to see if we need auto injection for this property</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="comment">//可以选择禁用依赖注入</span></span><br><span class="line">                    <span class="keyword">if</span> (method.getAnnotation(DisableInject.class) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//获得方法的参数，这个参数必须是一个对象类型并且是一个扩展点</span></span><br><span class="line">                    Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">if</span> (ReflectUtils.isPrimitives(pt)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//获得set方法中的属性名字，根据属性名字进行加载</span></span><br><span class="line">                        String property = getSetterProperty(method);</span><br><span class="line">                        Object object = objectFactory.getExtension(pt, property);</span><br><span class="line">                        <span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//调用set方法进行赋值</span></span><br><span class="line">                            method.invoke(instance, object);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.error(<span class="string">"Failed to inject via method "</span> + method.getName()</span><br><span class="line">                                + <span class="string">" of interface "</span> + type.getName() + <span class="string">": "</span> + e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析到这里我们发现，所谓的扩展点，套路都一样，不管是springfactorieyLoader，还是Dubbo的spi。实际上，Dubbo的功能会更加强大，比如自适应扩展点，比如依赖注入</p><h1 id="Adaptive自适应扩展点"><a href="#Adaptive自适应扩展点" class="headerlink" title="Adaptive自适应扩展点"></a>Adaptive自适应扩展点</h1><p> 什么叫自适应扩展点呢？我们先演示一个例子，在下面这个例子中，我们传入一个Compiler接口，它会返回一个AdaptiveCompiler。这个就叫自适应。<br>Compiler compiler=ExtensionLoader.getExtensionLoader(Compiler.class).getAdaptiveExtension();<br>System.out.println(compiler.getClass());<br>它是怎么实现的呢？  我们根据返回的AdaptiveCompiler这个类，看到这个类上面有一个注解@Adaptive。 这个就是一个自适应扩展点的标识。它可以修饰在类上，也可以修饰在方法上面。这两者有什么区别呢？<br>简单来说，放在类上，说明当前类是一个确定的自适应扩展点的类。如果是放在方法级别，那么需要生成一个动态字节码，来进行转发。<br>比如拿Protocol这个接口来说，它里面定义了export和refer两个抽象方法，这两个方法分别带有@Adaptive的标识，标识是一个自适应方法。<br>我们知道Protocol是一个通信协议的接口，具体有多种实现，那么这个时候选择哪一种呢？ 取决于我们在使用dubbo的时候所配置的协议名称。而这里的方法层面的Adaptive就决定了当前这个方法会采用何种协议来发布服务。</p><h2 id="getAdaptiveExtension"><a href="#getAdaptiveExtension" class="headerlink" title="getAdaptiveExtension"></a>getAdaptiveExtension</h2><p>这个方法主要就是要根据传入的接口返回一个自适应的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getAdaptiveExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//cacheAdaptiveInstance， 是一个缓存，在dubbo中大量用到这种内存缓存</span></span><br><span class="line">    Object instance = cachedAdaptiveInstance.get();</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (createAdaptiveInstanceError == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (cachedAdaptiveInstance) &#123;</span><br><span class="line">                instance = cachedAdaptiveInstance.get();</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//很明显，这里是创建一个自适应扩展点的实现</span></span><br><span class="line">                        instance = createAdaptiveExtension();</span><br><span class="line">                        cachedAdaptiveInstance.set(instance);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        createAdaptiveInstanceError = t;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to create adaptive instance: "</span> + t.toString(), t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to create adaptive instance: "</span> + createAdaptiveInstanceError.toString(), createAdaptiveInstanceError);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="createAdaptiveExtension"><a href="#createAdaptiveExtension" class="headerlink" title="createAdaptiveExtension"></a>createAdaptiveExtension</h2><p>这个方法中做两个事情</p><ol><li>获得一个自适应扩展点实例</li><li>实现依赖注入</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createAdaptiveExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> injectExtension((T) getAdaptiveExtensionClass().newInstance());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Can't create adaptive extension "</span> + type + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getExtensionClasses()这个方法在前面讲过了，会加载当前传入的类型的所有扩展点，保存在一个hashmap中<br>这里有一个判断逻辑，如果 cachedApdaptiveClas!=null ,直接返回这个cachedAdaptiveClass，这里大家可以猜一下，这个cachedAdaptiveClass是一个什么？</p><blockquote><p>cachedAdaptiveClass， 还记得前面讲过Adaptive可以方在两个位置，一个是类级别，一个是方法级别。那么这个cachedAdaptiveClass很显然，就是放在类级别的Adaptive，表示告诉dubbo spi loader，“我是一个自适应扩展点，你来加载我吧”</p><p>cachedAdaptiveClass应该是在 加载解析/META-INF/dubbo下的扩展点的时候加载进来的。在加载完之后如果这个类有@Adaptive标识，则会赋值赋值而给cachedAdaptiveClass</p></blockquote><p>如果cachedAdaptiveClass不存在，dubbo会动态生成一个代理类Protocol$Adaptive. 前面的名字<code>protocol</code>是根据当前ExtensionLoader所加载的扩展点来定义的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class="line">    getExtensionClasses();</span><br><span class="line">    <span class="keyword">if</span> (cachedAdaptiveClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cachedAdaptiveClass;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cachedAdaptiveClass = createAdaptiveExtensionClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="createAdaptiveExtensionClass"><a href="#createAdaptiveExtensionClass" class="headerlink" title="createAdaptiveExtensionClass"></a>createAdaptiveExtensionClass</h3><p>动态生成字节码，然后进行动态加载。那么这个时候锁返回的class,如果加载的是Protocol.class，应该是Protocol$Adaptive<br>这个cachedDefaultName实际上就是扩展点接口的@SPI注解对应的名字，如果此时加载的是Protocol.class，那么cachedDefaultName=dubbo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() &#123;</span><br><span class="line">    String code = <span class="keyword">new</span> AdaptiveClassCodeGenerator(type, cachedDefaultName).generate();</span><br><span class="line">    ClassLoader classLoader = findClassLoader();</span><br><span class="line">    org.apache.dubbo.common.compiler.Compiler compiler =   ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();</span><br><span class="line">    <span class="keyword">return</span> compiler.compile(code, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Protocol-Adaptive"><a href="#Protocol-Adaptive" class="headerlink" title="Protocol$Adaptive"></a>Protocol$Adaptive</h3><p>动态生成的代理类，以下是我通过debug拿到的代理类</p><p>前面传入进来的cachedDefaultName，在这个动态生成的类中，会体现在下面标红的部分，也就是它的默认实现是DubboProtocol</p><p>String extName = ( url.getProtocol() == null ? <strong>dubbo</strong> : url.getProtocol() );</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Protocol</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">dubbo</span>.<span class="title">rpc</span>.<span class="title">Protocol</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="function">Unsup <span class="title">tion</span><span class="params">(<span class="string">"The method public abstract void org.apache.dubbo.rpc.Protocol.destroy() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!"</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"The method public abstract int org.apache.dubbo.rpc.Protocol.getDefaultPort() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.<span class="function">Invoker <span class="title">refer</span><span class="params">(java.lang.Class arg0, org.apache.dubbo.common.URL arg1)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg1 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg1;</span><br><span class="line">        String extName = ( url.getProtocol() == <span class="keyword">null</span> ? <span class="string">"dubbo"</span> : url.getProtocol() );</span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url ("</span> + url.toString() + <span class="string">") use keys([protocol])"</span>);</span><br><span class="line">        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.refer(arg0, arg1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.<span class="function">Exporter <span class="title">export</span><span class="params">(org.apache.dubbo.rpc.Invoker arg0)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.Invoker argument == null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg0.getUrl() == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.Invoker argument getUrl() == null"</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class="line">        String extName = ( url.getProtocol() == <span class="keyword">null</span> ? <span class="string">"dubbo"</span> : url.getProtocol() );</span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url ("</span> + url.toString() + <span class="string">") use keys([protocol])"</span>);</span><br><span class="line">        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.export(arg0);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="图形理解"><a href="#图形理解" class="headerlink" title="图形理解"></a>图形理解</h3><p>简单来说，上面的基于方法层面的@Adaptive，基本实现原理的图形大概是这样</p><p><img src="C:%5CUsers%5Cmic%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1563980036930.png" alt="1563980036930"></p><h3 id="injectExtension-1"><a href="#injectExtension-1" class="headerlink" title="injectExtension"></a>injectExtension</h3><p>对于扩展点进行依赖注入，简单来说就是如果当前加载的扩展点中存在一个成员属性（对象），并且提供了set方法，那么这个方法就会执行依赖注入.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">injectExtension</span><span class="params">(T instance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (objectFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isSetter(method)) &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * Check &#123;<span class="doctag">@link</span> DisableInject&#125; to see if we need auto injection for this property</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (method.getAnnotation(DisableInject.class) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];<span class="comment">//获得这个方法的参数参数类型</span></span><br><span class="line">                    <span class="keyword">if</span> (ReflectUtils.isPrimitives(pt)) &#123;<span class="comment">//如果不是对象类型，则跳过</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        String property = getSetterProperty(method);<span class="comment">//获得这个方法的属性名称</span></span><br><span class="line"><span class="comment">//根据class以及name，使用自适应扩展点进行加载并且赋值到当前的set方法中</span></span><br><span class="line">                        Object object = objectFactory.getExtension(pt, property);</span><br><span class="line">                        <span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            method.invoke(instance, object);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.error(<span class="string">"Failed to inject via method "</span> + method.getName()</span><br><span class="line">                                + <span class="string">" of interface "</span> + type.getName() + <span class="string">": "</span> + e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于objectFactory"><a href="#关于objectFactory" class="headerlink" title="关于objectFactory"></a>关于objectFactory</h3><p>在injectExtension这个方法中，我们发现入口出的代码首先判断了objectFactory这个对象是否为空。这个是在哪里初始化的呢？实际上我们在获得ExtensionLoader的时候，就对objectFactory进行了初始化。</p><p><img src="/images/1564030215520.png" alt="1564030215520"></p><p>然后通过ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension()去获得一个自适应的扩展点，进入ExtensionFactory这个接口中，可以看到它是一个扩展点，并且有一个自己实现的自适应扩展点AdaptiveExtensionFactory; 注意：@Adaptive加载到类上表示这是一个自定义的适配器类，表示我们再调用getAdaptiveExtension方法的时候，不需要走上面这么复杂的过程。会直接加载到AdaptiveExtensionFactory。然后在getAdaptiveExtensionClass（）方法处有判断</p><p><img src="/images/1564030226616.png" alt="1564030226616"></p><p><img src="/images/1564030231391.png" alt="1564030231391"></p><p>我们可以看到除了自定义的自适应适配器类以外，还有两个实现类，一个是SPI，一个是Spring，AdaptiveExtensionFactory</p><p>AdaptiveExtensionFactory轮询这2个，从一个中获取到就返回。</p><p> <img src="/images/1564030244077.png" alt="1564030244077"></p><h1 id="Activate自动激活扩展点"><a href="#Activate自动激活扩展点" class="headerlink" title="Activate自动激活扩展点"></a>Activate自动激活扩展点</h1><p>自动激活扩展点，有点类似我们讲springboot的时候用到的conditional，根据条件进行自动激活。但是这里设计的初衷是，对于一个类会加载多个扩展点的实现，这个时候可以通过自动激活扩展点进行动态加载， 从而简化配置我们的配置工作</p><p>@Activate提供了一些配置来允许我们配置加载条件，比如group过滤，比如key过滤。</p><p>举个例子，我们可以看看org.apache.dubbo.Filter这个类，它有非常多的实现，比如说CacheFilter，这个缓存过滤器，配置信息如下</p><p>group表示客户端和和服务端都会加载，value表示url中有cache_key的时候</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate</span>(group = &#123;CONSUMER, PROVIDER&#125;, value = CACHE_KEY)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>通过下面这段代码，演示关于Filter的自动激活扩展点的效果。没有添加“红色部分的代码”时，list的结果是10，添加之后list的结果是11. 会自动把cacheFilter加载进来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExtensionLoader&lt;Filter&gt; loader=ExtensionLoader.getExtensionLoader(Filter.class);</span><br><span class="line">        URL url=<span class="keyword">new</span> URL(<span class="string">""</span>,<span class="string">""</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//        url=url.addParameter("cache","cache"); 有和没有的区别</span></span><br><span class="line">        List&lt;Filter&gt; filters=loader.getActivateExtension(url,<span class="string">"cache"</span>);</span><br><span class="line">        System.out.println(filters.size());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文的源码是基于Dubbo2.7.2版本进行的分析，请大家注意一下代码的变化&lt;/p&gt;
&lt;p&gt;另外，源码这块的量比较多，而且处理过程比较复杂，为了让大家更好的理解呢？ 我打算分几个步骤来讲。&lt;/p&gt;
&lt;p&gt;首先，把Dubbo里面用得比较多的SPI机制做一个详细的分析&lt;/p&gt;
    
    </summary>
    
      <category term="技术博文" scheme="https://istio.tech/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/"/>
    
    
      <category term="源码分析" scheme="https://istio.tech/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="Dubbo" scheme="https://istio.tech/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>IntelliJ IDEA导入Zookeeper源码</title>
    <link href="https://istio.tech/2019/07/14/IntelliJ-IDEA%E5%AF%BC%E5%85%A5Zookeeper%E6%BA%90%E7%A0%81/"/>
    <id>https://istio.tech/2019/07/14/IntelliJ-IDEA导入Zookeeper源码/</id>
    <published>2019-07-14T15:09:14.000Z</published>
    <updated>2019-07-18T01:55:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>我在使用IDEA导入zookeeper并且尝试运行时，遇到了很多的问题， 如果大家也遇到类似的需求，可以参考这篇文章来做</p><a id="more"></a><p>我会基于ant和maven两种形式来构建zookeeper的源码</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="下载zookeeper源码"><a href="#下载zookeeper源码" class="headerlink" title="下载zookeeper源码"></a>下载zookeeper源码</h2><p>在github上搜索<code>zookeeper</code>, 一般来说，第一个结果就是zookeeper的源码<br>也可以通过<a href="https://github.com/apache/zookeeper" target="_blank" rel="noopener">直达通道</a>快速进去<br>我们下载源码，一定不要直接clone他的正在维护的分支，而是要进入<code>release</code>菜单，下载对外发布的版本。</p><p><img src="/images/pasted-7.png" alt="upload successful"></p><blockquote><p>本次操作我们使用zookeeper-3.5.5版本。</p></blockquote><p>下载<code>zip</code>或者<code>tar.gz</code>都可以。也可以通过<a href="https://github.com/apache/zookeeper/archive/release-3.5.5.zip" target="_blank" rel="noopener">直达通道</a>直接下载</p><h1 id="配置ant"><a href="#配置ant" class="headerlink" title="配置ant"></a>配置ant</h1><p>zookeeper默认是基于ant来构建，如果有同学不了解ant，也没必要学习了，毕竟现在使用ant来构建项目的已经很少了。</p><p>ant的下载地址<a href="https://ant.apache.org/bindownload.cgi" target="_blank" rel="noopener">https://ant.apache.org/bindownload.cgi</a></p><p>下载好之后，在环境变量里面配置几个东西</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ANT_HOMT=$&#123;ant_home&#125;  //ant_home为自己本地安装的目录</span><br><span class="line">PATH=%ANT_HOME%/bin</span><br><span class="line">CLASSPATH=%ANT_HOME%/lib</span><br></pre></td></tr></table></figure><p>配置好之后，就可以在cmd中执行ant -version. 会得到下面这段信息，说明安装成功</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Apache Ant(TM) version <span class="number">1</span>.<span class="number">9</span>.<span class="number">14</span> compiled on March <span class="number">12</span> <span class="number">2019</span></span><br></pre></td></tr></table></figure><h1 id="配置maven"><a href="#配置maven" class="headerlink" title="配置maven"></a>配置maven</h1><p>由于我们会用两种形式来构建，所以也需要把maven的环境配置好。</p><p>maven的下载地址<a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">http://maven.apache.org/download.cgi</a></p><p>我下载的是<code>apache-maven-3.6.1-bin.tar.gz</code><br>只需要解压到指定目录就行</p><p>配置环境变量</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">M2_HOME=$&#123;maven_home&#125; //替换成自己解压出来的目录</span><br><span class="line"><span class="built_in">PATH</span>=<span class="variable">%M2_HOME%</span>/bin</span><br></pre></td></tr></table></figure><p>同样，输入<code>mvn -version</code>命令，如果得到下面的信息，说明安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Apache Maven 3.5.0 (ff8f5e7444045639af65f6095c62210b5713f426; 2017-04-04T03:39:06+08:00)</span><br><span class="line">Maven home: /Users/xxx/Documents/software/apache-maven-3.5.0</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，如果要用到maven来构建，会要从远程私服上下载jar包，默认会从中央仓库上下载，速度很慢。可以把maven的远程私服改成阿里的仓库，具体的教程我就不再这里说明，大家可以搜索下关键字【maven 阿里】就会有相应的教程来指导</p></blockquote><h1 id="基于ant构建zookeeper源码"><a href="#基于ant构建zookeeper源码" class="headerlink" title="基于ant构建zookeeper源码"></a>基于ant构建zookeeper源码</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>进入到zookeeper解压的根目录下，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ant eclipse</span><br></pre></td></tr></table></figure><p>显示如下结果，表示编译成功</p><p><img src="/images/pasted-11.png" alt="upload successful"></p><h2 id="导入到IDEA中"><a href="#导入到IDEA中" class="headerlink" title="导入到IDEA中"></a>导入到IDEA中</h2><p>选择<code>import project</code></p><blockquote><p><img src="/images/pasted-12.png" alt="upload successful"></p></blockquote><p>接着，选择eclipse,然后一直下一步就行</p><blockquote><p><img src="/images/pasted-13.png" alt="upload successful"></p></blockquote><h2 id="启动zookeeper"><a href="#启动zookeeper" class="headerlink" title="启动zookeeper"></a>启动zookeeper</h2><p>针对单机版本和集群版本，分别对应两个启动类</p><p>单机：ZooKeeperServerMain</p><p>集群：QuorumPeerMain</p><p>源码调试，不需要搭建集群，所以直接基于单机环境来启动即可</p><h3 id="配置run-configuration"><a href="#配置run-configuration" class="headerlink" title="配置run configuration"></a>配置run configuration</h3><p>按照下面这个位置进行配置<br><img src="/images/pasted-14.png" alt="upload successful"></p><p>添加application<br><img src="/images/pasted-15.png" alt="upload successful"></p><p>红色标注部分，分别是ZookeeperServerMain这个类的位置。以及main方法的启动参数zoo.cfg</p><blockquote><p>zoo.cfg默认是不存在的,但是在源码根目录有一个conf目录，里面提供了zoo_sample.cfg。 我们只需要复制一份改一个名字即可</p></blockquote><p><img src="/images/pasted-16.png" alt="upload successful"></p><p>配置好之后，直接启动即可</p><p><img src="/images/pasted-17.png" alt="upload successful"></p><h3 id="配置日志输出"><a href="#配置日志输出" class="headerlink" title="配置日志输出"></a>配置日志输出</h3><p>默认情况下，控制台没有把日志打印出来，应该是没有找到log4j.properties。 </p><p>配置如下jvm启动参数，指定log4j.properties路径即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dlog4j.configuration=file:/Users/mic/Documents/software/opensource/zookeeper-release-3.5.5/conf/log4j.properties</span><br></pre></td></tr></table></figure><p>启动之后，会输出如下日志,表示启动成功， 默认使用<code>2181</code>的端口号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-07-18 09:49:28,391 [myid:] - INFO  [main:JettyAdminServer@112] - Started AdminServer on address 0.0.0.0, port 8080 and command URL /commands</span><br><span class="line">2019-07-18 09:49:28,401 [myid:] - INFO  [main:ServerCnxnFactory@135] - Using org.apache.zookeeper.server.NIOServerCnxnFactory as server connection factory</span><br><span class="line">2019-07-18 09:49:28,407 [myid:] - INFO  [main:NIOServerCnxnFactory@673] - Configuring NIO connection handler with 10s sessionless connection timeout, 1 selector thread(s), 8 worker threads, and 64 kB direct buffers.</span><br><span class="line">2019-07-18 09:49:28,410 [myid:] - INFO  [main:NIOServerCnxnFactory@686] - binding to port 0.0.0.0/0.0.0.0:2181</span><br></pre></td></tr></table></figure><h2 id="连接测试"><a href="#连接测试" class="headerlink" title="连接测试"></a>连接测试</h2><h3 id="zkCli"><a href="#zkCli" class="headerlink" title="zkCli"></a>zkCli</h3><p>用zkCli工具来连接。<br>执行：./zkCli.sh -server 服务器ip:2181</p><h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h3><p>使用telent 命令， 可以测试<br><code>telnet ip 2181</code></p><h1 id="maven形式的导入"><a href="#maven形式的导入" class="headerlink" title="maven形式的导入"></a>maven形式的导入</h1><p>zookeeper源码没有使用maven来构建，如果一定要用maven，可以自己创建一个maven工程。把zookeeper-server的代码全部拷贝过来即可。</p><p>其实本质上就是，自己把它改造成一个maven项目</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我在使用IDEA导入zookeeper并且尝试运行时，遇到了很多的问题， 如果大家也遇到类似的需求，可以参考这篇文章来做&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[弗洛伊德]精神分析学的发展史</title>
    <link href="https://istio.tech/2019/07/11/%E5%AF%BB%E6%89%BE%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7/"/>
    <id>https://istio.tech/2019/07/11/寻找弗洛伊德/</id>
    <published>2019-07-11T14:17:00.000Z</published>
    <updated>2019-07-12T12:54:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>精神分析学是研究人类无意识心理学的一门学科<br>精神分析学说认为，精神疾病的发生是由无意识的冲突造成的。比如焦虑症、抑郁症、精神分裂症的发病都隐藏在无意识里。</p><a id="more"></a><p>待人接物拘谨刻板以及酿成人生不幸的乖戾性格，也可以从无意识里找到原因，这些无意识的原因，使得有些人生性谨慎，不善于沟通；有的人一想到要见人就心慌意乱；有的人很善于和人交往；有的人过分自恋；有的人喜欢支配和利用他人；</p><p>而精神分析学的核心思想就是从无意识中找出造成这些人异常人格的来龙去脉。因此精神分析疗法首先是把无意识里隐藏的冲突外化，再进行治疗</p><h2 id="由无意识产生的疾病案例"><a href="#由无意识产生的疾病案例" class="headerlink" title="由无意识产生的疾病案例"></a>由无意识产生的疾病案例</h2><p>被禁锢的情感（这种情感是不道德的，神经症患者无法接受），会在无意识中造成精神上的创伤记忆引起躯体疾病</p><h3 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h3><p>安娜.欧 ， 患上了“水恐惧症”，她的症状无法从躯体找出病因。在催眠状态下，她说出了一件事：又一次她看到佣人养的狗正在舔食玻璃杯里的水。她感到很恶心，但是出于礼貌她什么话都没有说。在催眠状态下尽情的发泄对于佣人的厌恶情绪。在发泄完以后竟然喝了很多水。从此她”水恐惧症“再也没发生过</p><h3 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h3><p>有一个女孩得了”癫痫症“，通过催眠发现：她曾经被一只口吐白沫扑上来的狗吓得半死。而这个下女孩的症状也是在被狗惊吓之后产生的。通过对这段记忆的消除，这个女孩的症状再也没有复发</p><h1 id="精神分析学的发展历程"><a href="#精神分析学的发展历程" class="headerlink" title="精神分析学的发展历程"></a>精神分析学的发展历程</h1><p>精神分析学的发展历程分为四个阶段</p><h2 id="情感创伤阶段"><a href="#情感创伤阶段" class="headerlink" title="情感创伤阶段"></a>情感创伤阶段</h2><p>弗洛伊德通过观察到夏科博士通过催眠术将原本肢体瘫痪的患者治愈好引发了对于神经学的高度关注。并且他从夏科博士那里获得了两个启发</p><ol><li>精神疾病患者是由心里原因导致</li><li>心理功能具有两个不同的层面，意识和无意识。</li></ol><p>后来，弗洛伊德开了一个诊所专收重症精神疾病患者。他通过催眠治疗法，从很多患者身上发现，癔症症状的发生都伴随着曾经的创伤体验的记忆。这些记忆都异常在无意识中，只要找到它就可以消除病症</p><p>通过多许多病例的研究，他创作了《癔症研究》，这本书的观点认为，绝大部分的精神疾病患者都是由精神上的创伤体验引发的。并且认为，将内心隐藏的创伤记忆说出来就能治愈病症。也就是说，只需要患者把心中压抑的创伤情感发泄出来就能祛除病根，从而治愈疾病。</p><p>并且在这个过程中，弗洛伊德发现了无意识的存在，并且开始探索通过说出遗忘的记忆来达到治愈病症的方法。</p><h2 id="分域论阶段"><a href="#分域论阶段" class="headerlink" title="分域论阶段"></a>分域论阶段</h2><p>这个阶段是精神分析的理论和治疗快速发展的时期。是精神分析分域理论占支配地位的时期，也可以称为本我心理学。<br>通过第一阶段的总结，弗洛伊德认为幼年时期的创伤经验，会通过猛或者精神症状的形式表现出来。精神创伤是实际存在的，关键是造成创伤的内容。而且他还发现，大部分患者的创伤经历都和性有关</p><p>但是，在后续的患者案例分析中，以及弗洛伊德对于自身的分析体检中发现，精神世界的冲突不只来自于现实的创伤，更多的是来自于幻想。引发病症的原因是内心的冲突，而冲突的产生并不是来自于现实的创伤，而是人的内在欲望和幻想。当弗洛伊德理解了这些事实之后，他随后提出了一个新的主张</p><blockquote><p>神经症的起因是患者的内部活动以及与冲动有关的幻想。</p></blockquote><p>弗洛伊德认识到，对梦境的解析非常有助于理解人的内心冲突，他随后对很多患者采用这种方法进行治疗，并且在积累和很多梦的经验之后，他出版了《梦的解析》，在这本书中，大概描绘了“分域模式“的理论框架。也就是说：以地理空间和地理术语来构建心理模型。简单来说就是无意识和意识的分域</p><p>随着理论的不断完善，弗洛伊德的治疗方法也随着完善。让患者说出无意识里隐藏的记忆有两种方法</p><ol><li>使用催眠术并且给一些有意的暗示</li><li>让患者随意想象</li></ol><p>弗洛伊德倾向于后者，让患者在没有任何压力的环境中自由联想，更多的展示他的内心世界。</p><h2 id="结构论阶段"><a href="#结构论阶段" class="headerlink" title="结构论阶段"></a>结构论阶段</h2><p>这一个阶段可以认为是对于分域论的进一步完善，在这个阶段，弗洛伊德主要以自我，本我，超我的人格结构来说明人的精神现象</p><blockquote><p>本我：原始和本能的欲望属于本我，本我是先天性和体质性的</p></blockquote><blockquote><p>自我：自我是从本我中产生出来，自我的基本职责是保存自身，通过延迟满足本能欲望的方法，调节本我的压力和现实要求两者之间的矛盾</p></blockquote><blockquote><p>超我：代表道德和良心，是自我的理想化。超我大部分隐藏在无意识中。</p></blockquote><p>这个阶段的理论认为，意识是”自我感觉器官“自我必须应付3位主人：本我，超我以及外部的现实需求。这3位主人中任何一方吓唬自我，自我都会因焦虑而发抖。</p><p>在这个阶段，弗洛伊德的精神分析法也有了变化，他更加关心自我对现实的认识。</p><h2 id="精神分析学的发展"><a href="#精神分析学的发展" class="headerlink" title="精神分析学的发展"></a>精神分析学的发展</h2><p>在这一阶段，结构论被人们所关注，得到了快速的发展</p><ul><li>弗洛伊德的小女儿安娜出版了《自我和防御机制》和《自我心理学和适应问题》</li><li>英国客体关系理论在精神分析的发展中做出了很大的贡献</li><li>分析家科胡特创立”自我心理学“，在治疗自恋人格障碍方面取得非常好的成绩</li></ul><p>克莱因学派和科胡特学派是精神分析第四阶段最有影响力的学派。克莱因学派以伦敦为中心，后来以南美为中心，形成了很大的影响范围。科胡特学派也积极扩大自己的影响力</p><p>以美国精神分析学会为中心研发者发展了自我心理学，以英国为中心的研发者发展了客体关系的理论，以南美为中心发展的克莱因学派侧重于攻击本能和幻想理论</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;精神分析学是研究人类无意识心理学的一门学科&lt;br&gt;精神分析学说认为，精神疾病的发生是由无意识的冲突造成的。比如焦虑症、抑郁症、精神分裂症的发病都隐藏在无意识里。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://istio.tech/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="心理学" scheme="https://istio.tech/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
      <category term="寻找弗罗伊德" scheme="https://istio.tech/tags/%E5%AF%BB%E6%89%BE%E5%BC%97%E7%BD%97%E4%BC%8A%E5%BE%B7/"/>
    
  </entry>
  
  <entry>
    <title>使用Hexo快速构建个人博客</title>
    <link href="https://istio.tech/2019/07/09/%E4%BD%BF%E7%94%A8Hexo%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://istio.tech/2019/07/09/使用Hexo快速构建个人博客/</id>
    <published>2019-07-09T07:15:00.000Z</published>
    <updated>2019-07-11T14:46:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用github搭建个人博客后，一个不懂前端开发的人如何去写各种前端页面呢？好在，有了hexo，这些都可以轻松搞定.</p><a id="more"></a><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页</p></blockquote><p>这篇文章我会写如何使用hexo快速构建一个漂亮的个人博客。如果想获得更多的素材，可以在<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方文档</a>中查看</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="node环境安装"><a href="#node环境安装" class="headerlink" title="node环境安装"></a>node环境安装</h2><p>下载Node.js 官方地址：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></p><p><strong>选择一个适合系统的版本</strong><br><img src="/images/pasted-5.png" alt="upload successful"></p><p>安装的过程比较简单，直接一直<code>下一步</code>即可。安装成功后，在<code>cmd</code>中输入</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v 查看 node 版本</span><br><span class="line">npm -v 查看 npm 版本</span><br></pre></td></tr></table></figure><h2 id="使用node安装hexo"><a href="#使用node安装hexo" class="headerlink" title="使用node安装hexo"></a>使用node安装hexo</h2><p>node安装好之后，可以使用npm来安装hexo</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog(生成的博客文件夹的名字，自定义,会在对应执行该语句的路径生成对应的文件)</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br><span class="line">hexo server（启动hexo）</span><br></pre></td></tr></table></figure><p>输入: <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a><br>就可以看到默认的博客页面了</p><h1 id="hexo配置"><a href="#hexo配置" class="headerlink" title="hexo配置"></a>hexo配置</h1><h2 id="hexo基本命令"><a href="#hexo基本命令" class="headerlink" title="hexo基本命令"></a>hexo基本命令</h2><p>这些命令，大部分都要在上一步创建好的<code>blog</code>目录下来执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure><h2 id="如何把博客发布到github"><a href="#如何把博客发布到github" class="headerlink" title="如何把博客发布到github"></a>如何把博客发布到github</h2><p>前面我们在本地通过<code>http://localhost:4000</code>可以访问到默认的博客站点，如果需要发布到外网访问，需要把代码上传到github对应站点的repository中。<br>通过<code>hexo deploy</code> 把生成好的静态页面发布到git，但是在此之前，需要配置目标github的地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd blog</span><br><span class="line">vim _config.xml</span><br></pre></td></tr></table></figure><p>找到<code>deploy</code>的配置项，增加如下配置。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repository:</span> <span class="string">git@github.com:2227324689/2227324689.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>接着执行<code>hexo deploy</code>，就能把页面提交到github。</p><blockquote><p>如果出现下面这个错误，说明还需要安装一个插件，在根目录下执行<code>npm install hexo-deployer-git --save</code> 安装插件</p></blockquote><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deployer <span class="keyword">not</span> found: github 或者 Deployer <span class="keyword">not</span> found: git</span><br></pre></td></tr></table></figure><h2 id="如何更新文章呢？"><a href="#如何更新文章呢？" class="headerlink" title="如何更新文章呢？"></a>如何更新文章呢？</h2><p>博客搭建好之后，最重要的就是要更新博客了。有两种方式来更新</p><h3 id="使用命令来创建"><a href="#使用命令来创建" class="headerlink" title="使用命令来创建"></a>使用命令来创建</h3><p>进入到<code>blog</code>目录，执行<code>hexo new &#39;blog-name&#39;</code> 来创建一个页面，在blog\source_post目录下就会生成一个blog-name.md文件</p><p>然后我们使用markdown的语法来写文章即可</p><h3 id="使用hexo-admin更新博客"><a href="#使用hexo-admin更新博客" class="headerlink" title="使用hexo-admin更新博客"></a>使用hexo-admin更新博客</h3><p>hexo提供了一个admin页面，来基于可视化窗口更新博客.<br>执行下面两个命令，安装hexo-admin以及启动hexo server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-admin</span><br><span class="line">hexo server -d(开启hexo操作)</span><br></pre></td></tr></table></figure><p>打开<a href="http://IP:4000/admin" target="_blank" rel="noopener">http://IP:4000/admin</a> 就可以进入控制台。</p><ul><li>posts 新建博客</li><li>pages 页面</li><li>deploy 将更新的博客发布到github</li></ul><h2 id="更新主题"><a href="#更新主题" class="headerlink" title="更新主题"></a>更新主题</h2><p>默认的博客界面比较丑，想要更换主题怎么办呢？</p><p>hexo官方提供了非常多的主题：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a><br>选择自己喜欢的主题，并且下载到本地。<br>把主题拷贝到 <code>blog/themes</code>目录下</p><p>修改_config.yml中的theme: landscape改为theme: yilia，然后执行hexo g来重新基于新的主题生成静态页面</p><h2 id="更多的hexo操作"><a href="#更多的hexo操作" class="headerlink" title="更多的hexo操作"></a>更多的hexo操作</h2><p>由于每个人对于hexo的使用需求不一样，所以大家可以自己去<br><a href="https://hexo.io/zh-cn/docs/plugins" target="_blank" rel="noopener">这个网站</a>查看更多的hexo说明。</p><p><img src="/images/pasted-6.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用github搭建个人博客后，一个不懂前端开发的人如何去写各种前端页面呢？好在，有了hexo，这些都可以轻松搞定.&lt;/p&gt;
    
    </summary>
    
      <category term="备忘录" scheme="https://istio.tech/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
      <category term="Hexo" scheme="https://istio.tech/tags/Hexo/"/>
    
      <category term="Node" scheme="https://istio.tech/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>如何使用Github搭建个人博客</title>
    <link href="https://istio.tech/2019/07/09/hello-world/"/>
    <id>https://istio.tech/2019/07/09/hello-world/</id>
    <published>2019-07-09T05:39:00.000Z</published>
    <updated>2019-07-11T14:40:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作为程序员，我们把大部分写代码的能力交给了搜索引擎，把大部分时间交给了业务逻辑的开发。却很少停下来对自己的工作和学习做一些总结和思考。我认为写博客是一种很好的习惯，不是为了给别人看自己写的东西有多🐂🍺，而是阶段性的给自己做一些总结。长期的积累，能够给自己带来很大的变化！</p></blockquote><a id="more"></a><p>我以前比较喜欢用gitbook来整理一些东西，后来因为github用得多，就干脆基于github来构建一个个人博客，闲暇之余可以把一些东西沉淀下来。</p><h1 id="github配置"><a href="#github配置" class="headerlink" title="github配置"></a>github配置</h1><h2 id="账号注册"><a href="#账号注册" class="headerlink" title="账号注册"></a>账号注册</h2><p>打开这个网址，注册一个github的账号<br><a href="https://github.com/join?source=header-home" target="_blank" rel="noopener">https://github.com/join?source=header-home</a></p><h2 id="创建repository"><a href="#创建repository" class="headerlink" title="创建repository"></a>创建repository</h2><p>创建一个repository，repository name设置的注意事项</p><p>[username].github.io , <code>username</code> 必须是github注册的用户名，否则无法访问</p><p><img src="/images/pasted-0.png" alt="upload successful"></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>创建好repository之后，提交一个基本的index.html。然后使用<br><code>[username].github.io</code> 来访问到index.html页面</p><blockquote><p>在本地的终端上，按照下面的命令，来提交一个index.html文件到github对应刚刚创建的repository中</p></blockquote><p><strong>index.html自己提前创建好，内容没有要求</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add index.html</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git remote add origin https://github.com/2227324689/2227324689.github.io.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>如果本地没有安装git客户端，是无法使用这些命令的。</p><h2 id="git客户端（window"><a href="#git客户端（window" class="headerlink" title="git客户端（window)"></a>git客户端（window)</h2><p>首先下载git for window 客户端<br><a href="https://github.com/git-for-windows/git/releases/tag/v2.22.0.windows.1" target="_blank" rel="noopener">https://github.com/git-for-windows/git/releases/tag/v2.22.0.windows.1</a></p><p>根据自己的操作系统版本来选择对应的下载文件。<br><img src="/images/pasted-1.png" alt="upload successful"></p><p>安装过程就不再赘述，一直<code>下一步</code>即可，安装结束之后，可以在<code>cmd</code>命令中输入<code>git -v</code> ，如果能够返回当前git的版本号，说明git安装成功了。</p><h2 id="git配置ssh"><a href="#git配置ssh" class="headerlink" title="git配置ssh"></a>git配置ssh</h2><p>github提供了两种方式来pull/push 文件，一种是基于https，一种是基于ssh。两种方式都可以用，但是为了方便起见（不用每次都输入密码），可以配置ssh</p><p><img src="/images/pasted-2.png" alt="upload successful"></p><h3 id="在本地生成ssh-公私钥"><a href="#在本地生成ssh-公私钥" class="headerlink" title="在本地生成ssh 公私钥"></a>在本地生成ssh 公私钥</h3><blockquote><p>检查本机是否有ssh key设置</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.ssh 或cd .ssh</span><br><span class="line"></span><br><span class="line">如果没有则提示： No such file or directory</span><br><span class="line"></span><br><span class="line">如果有则进入~/.ssh路径下（ls查看当前路径文件，rm * 删除所有文件）</span><br><span class="line">$ cd ~/.ssh 或cd .ssh</span><br><span class="line"></span><br><span class="line">**如果.ssh文件夹不存在，则创建一个**</span><br></pre></td></tr></table></figure><blockquote><p>使用ssh-keygen生成公私钥</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在.ssh目录下，执行`ssh-keygen -t rsa -C &quot;xxxxxx@yy.com&quot;`</span><br><span class="line">邮箱地址没有限制，建议填有效邮箱</span><br><span class="line">代码参数含义：</span><br><span class="line">-t 指定密钥类型，默认是 rsa ，可以省略。</span><br><span class="line">-C 设置注释文字，比如邮箱。</span><br><span class="line">-f 指定密钥文件存储文件名。</span><br></pre></td></tr></table></figure><p>这个命令执行过程中，会要求你输入文件名和密码，如果不需要改，则直接默认回车就行<br>这里的密码可以不用设，如果设置了，后续每次提交文件到github都需要输入密码验证</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> which to save the key (/Users/mic/.ssh/id_rsa):</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br></pre></td></tr></table></figure><p><strong>命令执行结束后，会在.ssh目录下生成两个文件，<code>id_rsa</code>,<code>id_rsa.pub</code></strong></p><p>id_rsa.pub是公钥，这个公钥可以直接用可以打开，里面就是一段公钥的代码，这段代码需要复制下来。后续需要配置到github上</p><h3 id="github上配置公钥"><a href="#github上配置公钥" class="headerlink" title="github上配置公钥"></a>github上配置公钥</h3><p>进入 &gt; profile -&gt; settings -&gt;ssh and GPG keys。<br>或者直接<a href="https://github.com/settings/keys" target="_blank" rel="noopener">点击这里</a>直接跳转到ssh key配置的页面</p><p><img src="/images/pasted-3.png" alt="upload successful"></p><p>点击<code>New SSH key</code>.</p><p>title  自己定义一个名称，一般来说用来区分当前是哪个机器的key，后续方便管理</p><p>key   把前面生成的<code>id_rsa.pub</code>文件中的内容全部复制粘贴在这里即可。点击<code>Add SSH key</code> 保存</p><p><img src="/images/pasted-4.png" alt="upload successful"></p><blockquote><p>在本地的客户端进行测试</p></blockquote><p>输入下面命令，所有内容都不用改。 </p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line">--如果返回下面这个信息，说明ssh配置成功了</span><br><span class="line">Hi <span class="number">2227324689</span>! You've successfully authenticated, but GitHub does <span class="keyword">not</span> provide shell access.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作为程序员，我们把大部分写代码的能力交给了搜索引擎，把大部分时间交给了业务逻辑的开发。却很少停下来对自己的工作和学习做一些总结和思考。我认为写博客是一种很好的习惯，不是为了给别人看自己写的东西有多🐂🍺，而是阶段性的给自己做一些总结。长期的积累，能够给自己带来很大的变化！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="备忘录" scheme="https://istio.tech/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
      <category term="Hexo" scheme="https://istio.tech/tags/Hexo/"/>
    
      <category term="github" scheme="https://istio.tech/tags/github/"/>
    
      <category term="博客" scheme="https://istio.tech/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风骚的Mic</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://istio.tech/"/>
  <updated>2019-07-25T05:18:08.000Z</updated>
  <id>https://istio.tech/</id>
  
  <author>
    <name>Mic</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dubbo源码分析系列之SPI机制</title>
    <link href="https://istio.tech/2019/07/25/Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8BSPI%E6%9C%BA%E5%88%B6/"/>
    <id>https://istio.tech/2019/07/25/Dubbo源码分析系列之SPI机制/</id>
    <published>2019-07-25T05:12:20.000Z</published>
    <updated>2019-07-25T05:18:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文的源码是基于Dubbo2.7.2版本进行的分析，请大家注意一下代码的变化</p><p>另外，源码这块的量比较多，而且处理过程比较复杂，为了让大家更好的理解呢？ 我打算分几个步骤来讲。</p><p>首先，把Dubbo里面用得比较多的SPI机制做一个详细的分析</p><a id="more"></a><h1 id="Dubbo中的SPI机制"><a href="#Dubbo中的SPI机制" class="headerlink" title="Dubbo中的SPI机制"></a>Dubbo中的SPI机制</h1><p>在Dubbo中，SPI贯穿在整个Dubbo的核心。所以有必要对spi做一个想尽的讲解，这个知识点必须理解。</p><p>之前咱们讲过SpringFactoriesLoader, 它也是一种spi机制。大家在学习的时候，一定要把学到的工具好好好好保存在脑子里，以后自己在创造一些东西时，可以拿出来用。</p><p>SPI机制在很多地方都有用到。</p><h2 id="关于Java-SPI"><a href="#关于Java-SPI" class="headerlink" title="关于Java SPI"></a>关于Java SPI</h2><p>了解Dubbo里面的SPI机制之前，我们先了解下Java提供的SPI（service provider interface）机制，SPI是JDK内置的一种服务提供发现机制。目前市面上有很多框架都是用它来做服务的扩展发现。简单来说，它是一种动态替换发现的机制。举个简单的例子，我们想在运行时动态给它添加实现，你只需要添加一个实现，然后把新的实现描述给JDK知道就行了。大家耳熟能详的如JDBC、日志框架都有用到</p><p><img src="/images/1564029268124.png" alt="1564029268124"></p><h3 id="实现SPI需要遵循的标准"><a href="#实现SPI需要遵循的标准" class="headerlink" title="实现SPI需要遵循的标准"></a>实现SPI需要遵循的标准</h3><p>我们如何去实现一个标准的SPI发现机制呢？其实很简单，只需要满足以下提交就行了</p><p>\1.  需要在classpath下创建一个目录，该目录命名必须是：META-INF/service</p><p>\2.  在该目录下创建一个properties文件，该文件需要满足以下几个条件 </p><p>2.1 文件名必须是扩展的接口的全路径名称 </p><p>2.2 文件内部描述的是该扩展接口的所有实现类 </p><p>2.3 文件的编码格式是UTF-8</p><p>\3.  通过java.util.ServiceLoader的加载机制来发现</p><p><img src="/images/1564029281905.png" alt="1564029281905"></p><h3 id="SPI的实际应用"><a href="#SPI的实际应用" class="headerlink" title="SPI的实际应用"></a>SPI的实际应用</h3><p>SPI在很多地方有应用，可能大家都没有关注，最常用的就是JDBC驱动，我们来看看是怎么应用的 </p><p>JDK本身提供了数据访问的api。在java.sql这个包里面 </p><p>我们在连接数据库的时候，一定需要用到java.sql.Driver这个接口对吧。然后我好奇的去看了下java.sql.Driver的源码，发现Driver并没有实现，而是提供了一套标准的api接口。大家有兴趣可以去看看 </p><p>因为我们在实际应用中用的比较多的是mysql，所以我去mysql的包里面看到一个如下的目录结构</p><p><img src="/images/1564029334118.png" alt="1564029334118"></p><p>这个文件里面写的就是mysql的驱动实现。我恍然大悟，原来通过SPI机制把java.sql.Driver和mysql的驱动做了集成。这样就达到了各个数据库厂商自己去实现数据库连接，jdk本身不关心你怎么实现。</p><h3 id="SPI的缺点"><a href="#SPI的缺点" class="headerlink" title="SPI的缺点"></a>SPI的缺点</h3><p>\1.  JDK标准的SPI会一次性加载实例化扩展点的所有实现，什么意思呢？就是如果你在META-INF/service下的文件里面加了N个实现类，那么JDK启动的时候都会一次性全部加载。那么如果有的扩展点实现初始化很耗时或者如果有些实现类并没有用到，那么会很浪费资源</p><p>\2.  如果扩展点加载失败，会导致调用方报错，而且这个错误很难定位到是这个原因</p><h2 id="Dubbo优化后的SPI机制"><a href="#Dubbo优化后的SPI机制" class="headerlink" title="Dubbo优化后的SPI机制"></a>Dubbo优化后的SPI机制</h2><h3 id="基于Dubbo-SPI的实现自己的扩展"><a href="#基于Dubbo-SPI的实现自己的扩展" class="headerlink" title="基于Dubbo SPI的实现自己的扩展"></a>基于Dubbo SPI的实现自己的扩展</h3><p>Dubbo的SPI扩展机制，有两个规则</p><p>\1.    需要在resource目录下配置META-INF/dubbo或者META-INF/dubbo/internal或者META-INF/services，并基于SPI接口去创建一个文件</p><p>\2.  文件名称和接口名称保持一致，文件内容和SPI有差异，内容是KEY对应Value</p><p>Dubbo针对的扩展点非常多，可以针对协议、拦截、集群、路由、负载均衡、序列化、容器… 几乎里面用到的所有功能，都可以实现自己的扩展，我觉得这个是dubbo比较强大的一点。</p><p><img src="/images/1564029365865.png" alt="1564029365865"></p><p>比如我们可以针对协议做一个扩展</p><h3 id="扩展协议扩展点"><a href="#扩展协议扩展点" class="headerlink" title="扩展协议扩展点"></a>扩展协议扩展点</h3><p>\1.    创建如下结构，添加META-INF.dubbo文件。类名和Dubbo提供的协议扩展点接口保持一致</p><p><img src="/images/1564029371563.png" alt="1564029371563"></p><p>\2.  创建MyProtocol协议类</p><p>可以实现自己的协议，我们为了模拟协议产生了作用，修改一个端口</p><p><img src="/images/1564029376290.png" alt="1564029376290"></p><p>\3.  在调用处执行如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Protocol protocol=ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(<span class="string">"myProtocol"</span>);</span><br><span class="line">System.out.print(protocol.getDefaultPort)</span><br></pre></td></tr></table></figure><p>\4.  输出结果，可以看到运行结果，是执行的自定义的协议扩展点。</p><p>总结：总的来说，思路和SPI是差不多。都是基于约定的路径下制定配置文件。目的，通过配置的方式轻松实现功能的扩展。</p><p>我们的猜想是，一定有一个地方通过读取指定路径下的所有文件进行load。然后讲对应的结果保存到一个map中，key对应为名称，value对应为实现类。那么这个实现，一定就在ExtensionLoader中了。接下来我们就可以基于这个猜想去看看代码的实现。</p><h2 id="Dubbo的扩展点原理实现"><a href="#Dubbo的扩展点原理实现" class="headerlink" title="Dubbo的扩展点原理实现"></a>Dubbo的扩展点原理实现</h2><p>在看它的实现代码之前，大家要思考一个问题，所谓的扩展点，就是通过指定目录下配置一个对应接口的实现类，然后程序会进行查找和解析，找到对应的扩展点。那么这里就涉及到两个问题</p><ol><li>怎么解析</li><li>被加载的类如何存储和使用？</li></ol><h3 id="ExtensionLoader-getExtensionLoader-getExtension"><a href="#ExtensionLoader-getExtensionLoader-getExtension" class="headerlink" title="ExtensionLoader.getExtensionLoader.getExtension"></a>ExtensionLoader.getExtensionLoader.getExtension</h3><p>我们从这段代码着手，去看看到底做了什么事情，能够通过这样一段代码实现扩展协议的查找和加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ExtensionLoader&lt;T&gt; <span class="title">getExtensionLoader</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension type == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!type.isInterface()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension type ("</span> + type + <span class="string">") is not an interface!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!withExtensionAnnotation(type)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension type ("</span> + type +</span><br><span class="line">                    <span class="string">") is not an extension, because it is NOT annotated with @"</span> + SPI.class.getSimpleName() + <span class="string">"!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//初始化ExtensionLoader</span></span><br><span class="line">        ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">        <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            EXTENSION_LOADERS.putIfAbsent(type, <span class="keyword">new</span> ExtensionLoader&lt;T&gt;(type));</span><br><span class="line">            loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> loader;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="实例化ExtensionLoader"><a href="#实例化ExtensionLoader" class="headerlink" title="实例化ExtensionLoader"></a>实例化ExtensionLoader</h3><p>如果当前的type=ExtensionFactory,type，那么objectFactory=null, 否则会创建一个自适应扩展点给到objectFacotry,目前来说具体做什么咱们先不关心</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ExtensionLoader</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">    objectFactory = (type == ExtensionFactory.class ? <span class="keyword">null</span> : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>objectFactory在这里赋值了，并且是返回一个AdaptiveExtension(). 这个暂时不展开，后面再分析</strong></p><h3 id="getExtension"><a href="#getExtension" class="headerlink" title="getExtension"></a>getExtension</h3><p>这个方法就是根据一个名字来获得一个对应类的实例，所以我们来猜想一下，回想一下前面咱们配置的自定义协议，name实际上就是myprotocol，而返回的实现类应该就是MyProtocol。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension name == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"true"</span>.equals(name)) &#123; <span class="comment">//如果name=true，表示返回一个默认的扩展点，思考一下什么是默认的？</span></span><br><span class="line">        <span class="keyword">return</span> getDefaultExtension();</span><br><span class="line">    &#125;</span><br><span class="line">    Holder&lt;Object&gt; holder = getOrCreateHolder(name);</span><br><span class="line">    Object instance = holder.get(); <span class="comment">//缓存一下,如果实例已经加载过了，直接从缓存读取</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (holder) &#123;</span><br><span class="line">            instance = holder.get();</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                instance = createExtension(name); <span class="comment">//根据名称创建实例</span></span><br><span class="line">                holder.set(instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="createExtension"><a href="#createExtension" class="headerlink" title="createExtension"></a>createExtension</h3><p> 仍然是根据名称创建扩展:getExtensionClasses() 加载指定路径下的所有文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123; <span class="comment">//如果没有找到，则抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> findException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//这里用一个chm来保存实例，做缓存</span></span><br><span class="line">        T instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());</span><br><span class="line">            instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//实例注入，可以猜到，这里应该是对这个实例中的成员属性来实现依赖注入的功能</span></span><br><span class="line">        injectExtension(instance);</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(wrapperClasses)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class="line">                instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Extension instance (name: "</span> + name + <span class="string">", class: "</span> +</span><br><span class="line">                type + <span class="string">") couldn't be instantiated: "</span> + t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getExtensionClasses"><a href="#getExtensionClasses" class="headerlink" title="getExtensionClasses"></a>getExtensionClasses</h3><p> 这个方法，会查找指定目录<br>/META-INF/dubbo || /META-INF/services 下对应的type-&gt;也就是本次演示案例的Protocol的properties文件，然后扫描这个文件下的所有配置信息。然后保存到一个HashMap中（classes），key=name(对应protocol文件中配置的myprotocol), value=对应配置的类的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();</span><br><span class="line">    <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (cachedClasses) &#123;</span><br><span class="line">            classes = cachedClasses.get();</span><br><span class="line">            <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                classes = loadExtensionClasses(); <span class="comment">//这里的代码就是加载的过程</span></span><br><span class="line">                cachedClasses.set(classes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="injectExtension"><a href="#injectExtension" class="headerlink" title="injectExtension"></a>injectExtension</h3><p>这个方法是用来实现依赖注入的，如果被加载的实例中，有成员属性本身也是一个扩展点，则会通过set方法进行注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">injectExtension</span><span class="params">(T instance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (objectFactory != <span class="keyword">null</span>) &#123; <span class="comment">//objectFactory在这里用到了</span></span><br><span class="line">            <span class="comment">//获得实例对应的方法，判断方法是否是一个set方法</span></span><br><span class="line">            <span class="keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isSetter(method)) &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * Check &#123;<span class="doctag">@link</span> DisableInject&#125; to see if we need auto injection for this property</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="comment">//可以选择禁用依赖注入</span></span><br><span class="line">                    <span class="keyword">if</span> (method.getAnnotation(DisableInject.class) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//获得方法的参数，这个参数必须是一个对象类型并且是一个扩展点</span></span><br><span class="line">                    Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">if</span> (ReflectUtils.isPrimitives(pt)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//获得set方法中的属性名字，根据属性名字进行加载</span></span><br><span class="line">                        String property = getSetterProperty(method);</span><br><span class="line">                        Object object = objectFactory.getExtension(pt, property);</span><br><span class="line">                        <span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//调用set方法进行赋值</span></span><br><span class="line">                            method.invoke(instance, object);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.error(<span class="string">"Failed to inject via method "</span> + method.getName()</span><br><span class="line">                                + <span class="string">" of interface "</span> + type.getName() + <span class="string">": "</span> + e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析到这里我们发现，所谓的扩展点，套路都一样，不管是springfactorieyLoader，还是Dubbo的spi。实际上，Dubbo的功能会更加强大，比如自适应扩展点，比如依赖注入</p><h1 id="Adaptive自适应扩展点"><a href="#Adaptive自适应扩展点" class="headerlink" title="Adaptive自适应扩展点"></a>Adaptive自适应扩展点</h1><p> 什么叫自适应扩展点呢？我们先演示一个例子，在下面这个例子中，我们传入一个Compiler接口，它会返回一个AdaptiveCompiler。这个就叫自适应。<br>Compiler compiler=ExtensionLoader.getExtensionLoader(Compiler.class).getAdaptiveExtension();<br>System.out.println(compiler.getClass());<br>它是怎么实现的呢？  我们根据返回的AdaptiveCompiler这个类，看到这个类上面有一个注解@Adaptive。 这个就是一个自适应扩展点的标识。它可以修饰在类上，也可以修饰在方法上面。这两者有什么区别呢？<br>简单来说，放在类上，说明当前类是一个确定的自适应扩展点的类。如果是放在方法级别，那么需要生成一个动态字节码，来进行转发。<br>比如拿Protocol这个接口来说，它里面定义了export和refer两个抽象方法，这两个方法分别带有@Adaptive的标识，标识是一个自适应方法。<br>我们知道Protocol是一个通信协议的接口，具体有多种实现，那么这个时候选择哪一种呢？ 取决于我们在使用dubbo的时候所配置的协议名称。而这里的方法层面的Adaptive就决定了当前这个方法会采用何种协议来发布服务。</p><h2 id="getAdaptiveExtension"><a href="#getAdaptiveExtension" class="headerlink" title="getAdaptiveExtension"></a>getAdaptiveExtension</h2><p>这个方法主要就是要根据传入的接口返回一个自适应的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getAdaptiveExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//cacheAdaptiveInstance， 是一个缓存，在dubbo中大量用到这种内存缓存</span></span><br><span class="line">    Object instance = cachedAdaptiveInstance.get();</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (createAdaptiveInstanceError == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (cachedAdaptiveInstance) &#123;</span><br><span class="line">                instance = cachedAdaptiveInstance.get();</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//很明显，这里是创建一个自适应扩展点的实现</span></span><br><span class="line">                        instance = createAdaptiveExtension();</span><br><span class="line">                        cachedAdaptiveInstance.set(instance);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        createAdaptiveInstanceError = t;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to create adaptive instance: "</span> + t.toString(), t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to create adaptive instance: "</span> + createAdaptiveInstanceError.toString(), createAdaptiveInstanceError);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="createAdaptiveExtension"><a href="#createAdaptiveExtension" class="headerlink" title="createAdaptiveExtension"></a>createAdaptiveExtension</h2><p>这个方法中做两个事情</p><ol><li>获得一个自适应扩展点实例</li><li>实现依赖注入</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createAdaptiveExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> injectExtension((T) getAdaptiveExtensionClass().newInstance());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Can't create adaptive extension "</span> + type + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getExtensionClasses()这个方法在前面讲过了，会加载当前传入的类型的所有扩展点，保存在一个hashmap中<br>这里有一个判断逻辑，如果 cachedApdaptiveClas!=null ,直接返回这个cachedAdaptiveClass，这里大家可以猜一下，这个cachedAdaptiveClass是一个什么？</p><blockquote><p>cachedAdaptiveClass， 还记得前面讲过Adaptive可以方在两个位置，一个是类级别，一个是方法级别。那么这个cachedAdaptiveClass很显然，就是放在类级别的Adaptive，表示告诉dubbo spi loader，“我是一个自适应扩展点，你来加载我吧”</p><p>cachedAdaptiveClass应该是在 加载解析/META-INF/dubbo下的扩展点的时候加载进来的。在加载完之后如果这个类有@Adaptive标识，则会赋值赋值而给cachedAdaptiveClass</p></blockquote><p>如果cachedAdaptiveClass不存在，dubbo会动态生成一个代理类Protocol$Adaptive. 前面的名字<code>protocol</code>是根据当前ExtensionLoader所加载的扩展点来定义的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class="line">    getExtensionClasses();</span><br><span class="line">    <span class="keyword">if</span> (cachedAdaptiveClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cachedAdaptiveClass;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cachedAdaptiveClass = createAdaptiveExtensionClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="createAdaptiveExtensionClass"><a href="#createAdaptiveExtensionClass" class="headerlink" title="createAdaptiveExtensionClass"></a>createAdaptiveExtensionClass</h3><p>动态生成字节码，然后进行动态加载。那么这个时候锁返回的class,如果加载的是Protocol.class，应该是Protocol$Adaptive<br>这个cachedDefaultName实际上就是扩展点接口的@SPI注解对应的名字，如果此时加载的是Protocol.class，那么cachedDefaultName=dubbo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() &#123;</span><br><span class="line">    String code = <span class="keyword">new</span> AdaptiveClassCodeGenerator(type, cachedDefaultName).generate();</span><br><span class="line">    ClassLoader classLoader = findClassLoader();</span><br><span class="line">    org.apache.dubbo.common.compiler.Compiler compiler =   ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();</span><br><span class="line">    <span class="keyword">return</span> compiler.compile(code, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Protocol-Adaptive"><a href="#Protocol-Adaptive" class="headerlink" title="Protocol$Adaptive"></a>Protocol$Adaptive</h3><p>动态生成的代理类，以下是我通过debug拿到的代理类</p><p>前面传入进来的cachedDefaultName，在这个动态生成的类中，会体现在下面标红的部分，也就是它的默认实现是DubboProtocol</p><p>String extName = ( url.getProtocol() == null ? <strong>dubbo</strong> : url.getProtocol() );</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Protocol</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">dubbo</span>.<span class="title">rpc</span>.<span class="title">Protocol</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="function">Unsup <span class="title">tion</span><span class="params">(<span class="string">"The method public abstract void org.apache.dubbo.rpc.Protocol.destroy() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!"</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"The method public abstract int org.apache.dubbo.rpc.Protocol.getDefaultPort() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.<span class="function">Invoker <span class="title">refer</span><span class="params">(java.lang.Class arg0, org.apache.dubbo.common.URL arg1)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg1 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg1;</span><br><span class="line">        String extName = ( url.getProtocol() == <span class="keyword">null</span> ? <span class="string">"dubbo"</span> : url.getProtocol() );</span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url ("</span> + url.toString() + <span class="string">") use keys([protocol])"</span>);</span><br><span class="line">        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.refer(arg0, arg1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.<span class="function">Exporter <span class="title">export</span><span class="params">(org.apache.dubbo.rpc.Invoker arg0)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.Invoker argument == null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg0.getUrl() == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.Invoker argument getUrl() == null"</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class="line">        String extName = ( url.getProtocol() == <span class="keyword">null</span> ? <span class="string">"dubbo"</span> : url.getProtocol() );</span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url ("</span> + url.toString() + <span class="string">") use keys([protocol])"</span>);</span><br><span class="line">        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.export(arg0);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="图形理解"><a href="#图形理解" class="headerlink" title="图形理解"></a>图形理解</h3><p>简单来说，上面的基于方法层面的@Adaptive，基本实现原理的图形大概是这样</p><p><img src="C:%5CUsers%5Cmic%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1563980036930.png" alt="1563980036930"></p><h3 id="injectExtension-1"><a href="#injectExtension-1" class="headerlink" title="injectExtension"></a>injectExtension</h3><p>对于扩展点进行依赖注入，简单来说就是如果当前加载的扩展点中存在一个成员属性（对象），并且提供了set方法，那么这个方法就会执行依赖注入.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">injectExtension</span><span class="params">(T instance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (objectFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isSetter(method)) &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * Check &#123;<span class="doctag">@link</span> DisableInject&#125; to see if we need auto injection for this property</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (method.getAnnotation(DisableInject.class) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];<span class="comment">//获得这个方法的参数参数类型</span></span><br><span class="line">                    <span class="keyword">if</span> (ReflectUtils.isPrimitives(pt)) &#123;<span class="comment">//如果不是对象类型，则跳过</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        String property = getSetterProperty(method);<span class="comment">//获得这个方法的属性名称</span></span><br><span class="line"><span class="comment">//根据class以及name，使用自适应扩展点进行加载并且赋值到当前的set方法中</span></span><br><span class="line">                        Object object = objectFactory.getExtension(pt, property);</span><br><span class="line">                        <span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            method.invoke(instance, object);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.error(<span class="string">"Failed to inject via method "</span> + method.getName()</span><br><span class="line">                                + <span class="string">" of interface "</span> + type.getName() + <span class="string">": "</span> + e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于objectFactory"><a href="#关于objectFactory" class="headerlink" title="关于objectFactory"></a>关于objectFactory</h3><p>在injectExtension这个方法中，我们发现入口出的代码首先判断了objectFactory这个对象是否为空。这个是在哪里初始化的呢？实际上我们在获得ExtensionLoader的时候，就对objectFactory进行了初始化。</p><p><img src="/images/1564030215520.png" alt="1564030215520"></p><p>然后通过ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension()去获得一个自适应的扩展点，进入ExtensionFactory这个接口中，可以看到它是一个扩展点，并且有一个自己实现的自适应扩展点AdaptiveExtensionFactory; 注意：@Adaptive加载到类上表示这是一个自定义的适配器类，表示我们再调用getAdaptiveExtension方法的时候，不需要走上面这么复杂的过程。会直接加载到AdaptiveExtensionFactory。然后在getAdaptiveExtensionClass（）方法处有判断</p><p><img src="/images/1564030226616.png" alt="1564030226616"></p><p><img src="/images/1564030231391.png" alt="1564030231391"></p><p>我们可以看到除了自定义的自适应适配器类以外，还有两个实现类，一个是SPI，一个是Spring，AdaptiveExtensionFactory</p><p>AdaptiveExtensionFactory轮询这2个，从一个中获取到就返回。</p><p> <img src="/images/1564030244077.png" alt="1564030244077"></p><h1 id="Activate自动激活扩展点"><a href="#Activate自动激活扩展点" class="headerlink" title="Activate自动激活扩展点"></a>Activate自动激活扩展点</h1><p>自动激活扩展点，有点类似我们讲springboot的时候用到的conditional，根据条件进行自动激活。但是这里设计的初衷是，对于一个类会加载多个扩展点的实现，这个时候可以通过自动激活扩展点进行动态加载， 从而简化配置我们的配置工作</p><p>@Activate提供了一些配置来允许我们配置加载条件，比如group过滤，比如key过滤。</p><p>举个例子，我们可以看看org.apache.dubbo.Filter这个类，它有非常多的实现，比如说CacheFilter，这个缓存过滤器，配置信息如下</p><p>group表示客户端和和服务端都会加载，value表示url中有cache_key的时候</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate</span>(group = &#123;CONSUMER, PROVIDER&#125;, value = CACHE_KEY)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>通过下面这段代码，演示关于Filter的自动激活扩展点的效果。没有添加“红色部分的代码”时，list的结果是10，添加之后list的结果是11. 会自动把cacheFilter加载进来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExtensionLoader&lt;Filter&gt; loader=ExtensionLoader.getExtensionLoader(Filter.class);</span><br><span class="line">        URL url=<span class="keyword">new</span> URL(<span class="string">""</span>,<span class="string">""</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//        url=url.addParameter("cache","cache"); 有和没有的区别</span></span><br><span class="line">        List&lt;Filter&gt; filters=loader.getActivateExtension(url,<span class="string">"cache"</span>);</span><br><span class="line">        System.out.println(filters.size());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文的源码是基于Dubbo2.7.2版本进行的分析，请大家注意一下代码的变化&lt;/p&gt;
&lt;p&gt;另外，源码这块的量比较多，而且处理过程比较复杂，为了让大家更好的理解呢？ 我打算分几个步骤来讲。&lt;/p&gt;
&lt;p&gt;首先，把Dubbo里面用得比较多的SPI机制做一个详细的分析&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>IntelliJ IDEA导入Zookeeper源码</title>
    <link href="https://istio.tech/2019/07/14/IntelliJ-IDEA%E5%AF%BC%E5%85%A5Zookeeper%E6%BA%90%E7%A0%81/"/>
    <id>https://istio.tech/2019/07/14/IntelliJ-IDEA导入Zookeeper源码/</id>
    <published>2019-07-14T15:09:14.000Z</published>
    <updated>2019-07-18T01:55:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>我在使用IDEA导入zookeeper并且尝试运行时，遇到了很多的问题， 如果大家也遇到类似的需求，可以参考这篇文章来做</p><a id="more"></a><p>我会基于ant和maven两种形式来构建zookeeper的源码</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="下载zookeeper源码"><a href="#下载zookeeper源码" class="headerlink" title="下载zookeeper源码"></a>下载zookeeper源码</h2><p>在github上搜索<code>zookeeper</code>, 一般来说，第一个结果就是zookeeper的源码<br>也可以通过<a href="https://github.com/apache/zookeeper" target="_blank" rel="noopener">直达通道</a>快速进去<br>我们下载源码，一定不要直接clone他的正在维护的分支，而是要进入<code>release</code>菜单，下载对外发布的版本。</p><p><img src="/images/pasted-7.png" alt="upload successful"></p><blockquote><p>本次操作我们使用zookeeper-3.5.5版本。</p></blockquote><p>下载<code>zip</code>或者<code>tar.gz</code>都可以。也可以通过<a href="https://github.com/apache/zookeeper/archive/release-3.5.5.zip" target="_blank" rel="noopener">直达通道</a>直接下载</p><h1 id="配置ant"><a href="#配置ant" class="headerlink" title="配置ant"></a>配置ant</h1><p>zookeeper默认是基于ant来构建，如果有同学不了解ant，也没必要学习了，毕竟现在使用ant来构建项目的已经很少了。</p><p>ant的下载地址<a href="https://ant.apache.org/bindownload.cgi" target="_blank" rel="noopener">https://ant.apache.org/bindownload.cgi</a></p><p>下载好之后，在环境变量里面配置几个东西</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ANT_HOMT=$&#123;ant_home&#125;  //ant_home为自己本地安装的目录</span><br><span class="line">PATH=%ANT_HOME%/bin</span><br><span class="line">CLASSPATH=%ANT_HOME%/lib</span><br></pre></td></tr></table></figure><p>配置好之后，就可以在cmd中执行ant -version. 会得到下面这段信息，说明安装成功</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Apache Ant(TM) version <span class="number">1</span>.<span class="number">9</span>.<span class="number">14</span> compiled on March <span class="number">12</span> <span class="number">2019</span></span><br></pre></td></tr></table></figure><h1 id="配置maven"><a href="#配置maven" class="headerlink" title="配置maven"></a>配置maven</h1><p>由于我们会用两种形式来构建，所以也需要把maven的环境配置好。</p><p>maven的下载地址<a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">http://maven.apache.org/download.cgi</a></p><p>我下载的是<code>apache-maven-3.6.1-bin.tar.gz</code><br>只需要解压到指定目录就行</p><p>配置环境变量</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">M2_HOME=$&#123;maven_home&#125; //替换成自己解压出来的目录</span><br><span class="line"><span class="built_in">PATH</span>=<span class="variable">%M2_HOME%</span>/bin</span><br></pre></td></tr></table></figure><p>同样，输入<code>mvn -version</code>命令，如果得到下面的信息，说明安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Apache Maven 3.5.0 (ff8f5e7444045639af65f6095c62210b5713f426; 2017-04-04T03:39:06+08:00)</span><br><span class="line">Maven home: /Users/xxx/Documents/software/apache-maven-3.5.0</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，如果要用到maven来构建，会要从远程私服上下载jar包，默认会从中央仓库上下载，速度很慢。可以把maven的远程私服改成阿里的仓库，具体的教程我就不再这里说明，大家可以搜索下关键字【maven 阿里】就会有相应的教程来指导</p></blockquote><h1 id="基于ant构建zookeeper源码"><a href="#基于ant构建zookeeper源码" class="headerlink" title="基于ant构建zookeeper源码"></a>基于ant构建zookeeper源码</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>进入到zookeeper解压的根目录下，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ant eclipse</span><br></pre></td></tr></table></figure><p>显示如下结果，表示编译成功</p><p><img src="/images/pasted-11.png" alt="upload successful"></p><h2 id="导入到IDEA中"><a href="#导入到IDEA中" class="headerlink" title="导入到IDEA中"></a>导入到IDEA中</h2><p>选择<code>import project</code></p><blockquote><p><img src="/images/pasted-12.png" alt="upload successful"></p></blockquote><p>接着，选择eclipse,然后一直下一步就行</p><blockquote><p><img src="/images/pasted-13.png" alt="upload successful"></p></blockquote><h2 id="启动zookeeper"><a href="#启动zookeeper" class="headerlink" title="启动zookeeper"></a>启动zookeeper</h2><p>针对单机版本和集群版本，分别对应两个启动类</p><p>单机：ZooKeeperServerMain</p><p>集群：QuorumPeerMain</p><p>源码调试，不需要搭建集群，所以直接基于单机环境来启动即可</p><h3 id="配置run-configuration"><a href="#配置run-configuration" class="headerlink" title="配置run configuration"></a>配置run configuration</h3><p>按照下面这个位置进行配置<br><img src="/images/pasted-14.png" alt="upload successful"></p><p>添加application<br><img src="/images/pasted-15.png" alt="upload successful"></p><p>红色标注部分，分别是ZookeeperServerMain这个类的位置。以及main方法的启动参数zoo.cfg</p><blockquote><p>zoo.cfg默认是不存在的,但是在源码根目录有一个conf目录，里面提供了zoo_sample.cfg。 我们只需要复制一份改一个名字即可</p></blockquote><p><img src="/images/pasted-16.png" alt="upload successful"></p><p>配置好之后，直接启动即可</p><p><img src="/images/pasted-17.png" alt="upload successful"></p><h3 id="配置日志输出"><a href="#配置日志输出" class="headerlink" title="配置日志输出"></a>配置日志输出</h3><p>默认情况下，控制台没有把日志打印出来，应该是没有找到log4j.properties。 </p><p>配置如下jvm启动参数，指定log4j.properties路径即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dlog4j.configuration=file:/Users/mic/Documents/software/opensource/zookeeper-release-3.5.5/conf/log4j.properties</span><br></pre></td></tr></table></figure><p>启动之后，会输出如下日志,表示启动成功， 默认使用<code>2181</code>的端口号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-07-18 09:49:28,391 [myid:] - INFO  [main:JettyAdminServer@112] - Started AdminServer on address 0.0.0.0, port 8080 and command URL /commands</span><br><span class="line">2019-07-18 09:49:28,401 [myid:] - INFO  [main:ServerCnxnFactory@135] - Using org.apache.zookeeper.server.NIOServerCnxnFactory as server connection factory</span><br><span class="line">2019-07-18 09:49:28,407 [myid:] - INFO  [main:NIOServerCnxnFactory@673] - Configuring NIO connection handler with 10s sessionless connection timeout, 1 selector thread(s), 8 worker threads, and 64 kB direct buffers.</span><br><span class="line">2019-07-18 09:49:28,410 [myid:] - INFO  [main:NIOServerCnxnFactory@686] - binding to port 0.0.0.0/0.0.0.0:2181</span><br></pre></td></tr></table></figure><h2 id="连接测试"><a href="#连接测试" class="headerlink" title="连接测试"></a>连接测试</h2><h3 id="zkCli"><a href="#zkCli" class="headerlink" title="zkCli"></a>zkCli</h3><p>用zkCli工具来连接。<br>执行：./zkCli.sh -server 服务器ip:2181</p><h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h3><p>使用telent 命令， 可以测试<br><code>telnet ip 2181</code></p><h1 id="maven形式的导入"><a href="#maven形式的导入" class="headerlink" title="maven形式的导入"></a>maven形式的导入</h1><p>zookeeper源码没有使用maven来构建，如果一定要用maven，可以自己创建一个maven工程。把zookeeper-server的代码全部拷贝过来即可。</p><p>其实本质上就是，自己把它改造成一个maven项目</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我在使用IDEA导入zookeeper并且尝试运行时，遇到了很多的问题， 如果大家也遇到类似的需求，可以参考这篇文章来做&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[弗洛伊德]精神分析学的发展史</title>
    <link href="https://istio.tech/2019/07/11/%E5%AF%BB%E6%89%BE%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7/"/>
    <id>https://istio.tech/2019/07/11/寻找弗洛伊德/</id>
    <published>2019-07-11T14:17:00.000Z</published>
    <updated>2019-07-12T12:54:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>精神分析学是研究人类无意识心理学的一门学科<br>精神分析学说认为，精神疾病的发生是由无意识的冲突造成的。比如焦虑症、抑郁症、精神分裂症的发病都隐藏在无意识里。</p><a id="more"></a><p>待人接物拘谨刻板以及酿成人生不幸的乖戾性格，也可以从无意识里找到原因，这些无意识的原因，使得有些人生性谨慎，不善于沟通；有的人一想到要见人就心慌意乱；有的人很善于和人交往；有的人过分自恋；有的人喜欢支配和利用他人；</p><p>而精神分析学的核心思想就是从无意识中找出造成这些人异常人格的来龙去脉。因此精神分析疗法首先是把无意识里隐藏的冲突外化，再进行治疗</p><h2 id="由无意识产生的疾病案例"><a href="#由无意识产生的疾病案例" class="headerlink" title="由无意识产生的疾病案例"></a>由无意识产生的疾病案例</h2><p>被禁锢的情感（这种情感是不道德的，神经症患者无法接受），会在无意识中造成精神上的创伤记忆引起躯体疾病</p><h3 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h3><p>安娜.欧 ， 患上了“水恐惧症”，她的症状无法从躯体找出病因。在催眠状态下，她说出了一件事：又一次她看到佣人养的狗正在舔食玻璃杯里的水。她感到很恶心，但是出于礼貌她什么话都没有说。在催眠状态下尽情的发泄对于佣人的厌恶情绪。在发泄完以后竟然喝了很多水。从此她”水恐惧症“再也没发生过</p><h3 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h3><p>有一个女孩得了”癫痫症“，通过催眠发现：她曾经被一只口吐白沫扑上来的狗吓得半死。而这个下女孩的症状也是在被狗惊吓之后产生的。通过对这段记忆的消除，这个女孩的症状再也没有复发</p><h1 id="精神分析学的发展历程"><a href="#精神分析学的发展历程" class="headerlink" title="精神分析学的发展历程"></a>精神分析学的发展历程</h1><p>精神分析学的发展历程分为四个阶段</p><h2 id="情感创伤阶段"><a href="#情感创伤阶段" class="headerlink" title="情感创伤阶段"></a>情感创伤阶段</h2><p>弗洛伊德通过观察到夏科博士通过催眠术将原本肢体瘫痪的患者治愈好引发了对于神经学的高度关注。并且他从夏科博士那里获得了两个启发</p><ol><li>精神疾病患者是由心里原因导致</li><li>心理功能具有两个不同的层面，意识和无意识。</li></ol><p>后来，弗洛伊德开了一个诊所专收重症精神疾病患者。他通过催眠治疗法，从很多患者身上发现，癔症症状的发生都伴随着曾经的创伤体验的记忆。这些记忆都异常在无意识中，只要找到它就可以消除病症</p><p>通过多许多病例的研究，他创作了《癔症研究》，这本书的观点认为，绝大部分的精神疾病患者都是由精神上的创伤体验引发的。并且认为，将内心隐藏的创伤记忆说出来就能治愈病症。也就是说，只需要患者把心中压抑的创伤情感发泄出来就能祛除病根，从而治愈疾病。</p><p>并且在这个过程中，弗洛伊德发现了无意识的存在，并且开始探索通过说出遗忘的记忆来达到治愈病症的方法。</p><h2 id="分域论阶段"><a href="#分域论阶段" class="headerlink" title="分域论阶段"></a>分域论阶段</h2><p>这个阶段是精神分析的理论和治疗快速发展的时期。是精神分析分域理论占支配地位的时期，也可以称为本我心理学。<br>通过第一阶段的总结，弗洛伊德认为幼年时期的创伤经验，会通过猛或者精神症状的形式表现出来。精神创伤是实际存在的，关键是造成创伤的内容。而且他还发现，大部分患者的创伤经历都和性有关</p><p>但是，在后续的患者案例分析中，以及弗洛伊德对于自身的分析体检中发现，精神世界的冲突不只来自于现实的创伤，更多的是来自于幻想。引发病症的原因是内心的冲突，而冲突的产生并不是来自于现实的创伤，而是人的内在欲望和幻想。当弗洛伊德理解了这些事实之后，他随后提出了一个新的主张</p><blockquote><p>神经症的起因是患者的内部活动以及与冲动有关的幻想。</p></blockquote><p>弗洛伊德认识到，对梦境的解析非常有助于理解人的内心冲突，他随后对很多患者采用这种方法进行治疗，并且在积累和很多梦的经验之后，他出版了《梦的解析》，在这本书中，大概描绘了“分域模式“的理论框架。也就是说：以地理空间和地理术语来构建心理模型。简单来说就是无意识和意识的分域</p><p>随着理论的不断完善，弗洛伊德的治疗方法也随着完善。让患者说出无意识里隐藏的记忆有两种方法</p><ol><li>使用催眠术并且给一些有意的暗示</li><li>让患者随意想象</li></ol><p>弗洛伊德倾向于后者，让患者在没有任何压力的环境中自由联想，更多的展示他的内心世界。</p><h2 id="结构论阶段"><a href="#结构论阶段" class="headerlink" title="结构论阶段"></a>结构论阶段</h2><p>这一个阶段可以认为是对于分域论的进一步完善，在这个阶段，弗洛伊德主要以自我，本我，超我的人格结构来说明人的精神现象</p><blockquote><p>本我：原始和本能的欲望属于本我，本我是先天性和体质性的</p></blockquote><blockquote><p>自我：自我是从本我中产生出来，自我的基本职责是保存自身，通过延迟满足本能欲望的方法，调节本我的压力和现实要求两者之间的矛盾</p></blockquote><blockquote><p>超我：代表道德和良心，是自我的理想化。超我大部分隐藏在无意识中。</p></blockquote><p>这个阶段的理论认为，意识是”自我感觉器官“自我必须应付3位主人：本我，超我以及外部的现实需求。这3位主人中任何一方吓唬自我，自我都会因焦虑而发抖。</p><p>在这个阶段，弗洛伊德的精神分析法也有了变化，他更加关心自我对现实的认识。</p><h2 id="精神分析学的发展"><a href="#精神分析学的发展" class="headerlink" title="精神分析学的发展"></a>精神分析学的发展</h2><p>在这一阶段，结构论被人们所关注，得到了快速的发展</p><ul><li>弗洛伊德的小女儿安娜出版了《自我和防御机制》和《自我心理学和适应问题》</li><li>英国客体关系理论在精神分析的发展中做出了很大的贡献</li><li>分析家科胡特创立”自我心理学“，在治疗自恋人格障碍方面取得非常好的成绩</li></ul><p>克莱因学派和科胡特学派是精神分析第四阶段最有影响力的学派。克莱因学派以伦敦为中心，后来以南美为中心，形成了很大的影响范围。科胡特学派也积极扩大自己的影响力</p><p>以美国精神分析学会为中心研发者发展了自我心理学，以英国为中心的研发者发展了客体关系的理论，以南美为中心发展的克莱因学派侧重于攻击本能和幻想理论</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;精神分析学是研究人类无意识心理学的一门学科&lt;br&gt;精神分析学说认为，精神疾病的发生是由无意识的冲突造成的。比如焦虑症、抑郁症、精神分裂症的发病都隐藏在无意识里。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://istio.tech/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="心理学" scheme="https://istio.tech/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
      <category term="寻找弗罗伊德" scheme="https://istio.tech/tags/%E5%AF%BB%E6%89%BE%E5%BC%97%E7%BD%97%E4%BC%8A%E5%BE%B7/"/>
    
  </entry>
  
  <entry>
    <title>使用Hexo快速构建个人博客</title>
    <link href="https://istio.tech/2019/07/09/%E4%BD%BF%E7%94%A8Hexo%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://istio.tech/2019/07/09/使用Hexo快速构建个人博客/</id>
    <published>2019-07-09T07:15:00.000Z</published>
    <updated>2019-07-11T14:46:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用github搭建个人博客后，一个不懂前端开发的人如何去写各种前端页面呢？好在，有了hexo，这些都可以轻松搞定.</p><a id="more"></a><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页</p></blockquote><p>这篇文章我会写如何使用hexo快速构建一个漂亮的个人博客。如果想获得更多的素材，可以在<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方文档</a>中查看</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="node环境安装"><a href="#node环境安装" class="headerlink" title="node环境安装"></a>node环境安装</h2><p>下载Node.js 官方地址：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></p><p><strong>选择一个适合系统的版本</strong><br><img src="/images/pasted-5.png" alt="upload successful"></p><p>安装的过程比较简单，直接一直<code>下一步</code>即可。安装成功后，在<code>cmd</code>中输入</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v 查看 node 版本</span><br><span class="line">npm -v 查看 npm 版本</span><br></pre></td></tr></table></figure><h2 id="使用node安装hexo"><a href="#使用node安装hexo" class="headerlink" title="使用node安装hexo"></a>使用node安装hexo</h2><p>node安装好之后，可以使用npm来安装hexo</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog(生成的博客文件夹的名字，自定义,会在对应执行该语句的路径生成对应的文件)</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br><span class="line">hexo server（启动hexo）</span><br></pre></td></tr></table></figure><p>输入: <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a><br>就可以看到默认的博客页面了</p><h1 id="hexo配置"><a href="#hexo配置" class="headerlink" title="hexo配置"></a>hexo配置</h1><h2 id="hexo基本命令"><a href="#hexo基本命令" class="headerlink" title="hexo基本命令"></a>hexo基本命令</h2><p>这些命令，大部分都要在上一步创建好的<code>blog</code>目录下来执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure><h2 id="如何把博客发布到github"><a href="#如何把博客发布到github" class="headerlink" title="如何把博客发布到github"></a>如何把博客发布到github</h2><p>前面我们在本地通过<code>http://localhost:4000</code>可以访问到默认的博客站点，如果需要发布到外网访问，需要把代码上传到github对应站点的repository中。<br>通过<code>hexo deploy</code> 把生成好的静态页面发布到git，但是在此之前，需要配置目标github的地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd blog</span><br><span class="line">vim _config.xml</span><br></pre></td></tr></table></figure><p>找到<code>deploy</code>的配置项，增加如下配置。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repository:</span> <span class="string">git@github.com:2227324689/2227324689.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>接着执行<code>hexo deploy</code>，就能把页面提交到github。</p><blockquote><p>如果出现下面这个错误，说明还需要安装一个插件，在根目录下执行<code>npm install hexo-deployer-git --save</code> 安装插件</p></blockquote><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deployer <span class="keyword">not</span> found: github 或者 Deployer <span class="keyword">not</span> found: git</span><br></pre></td></tr></table></figure><h2 id="如何更新文章呢？"><a href="#如何更新文章呢？" class="headerlink" title="如何更新文章呢？"></a>如何更新文章呢？</h2><p>博客搭建好之后，最重要的就是要更新博客了。有两种方式来更新</p><h3 id="使用命令来创建"><a href="#使用命令来创建" class="headerlink" title="使用命令来创建"></a>使用命令来创建</h3><p>进入到<code>blog</code>目录，执行<code>hexo new &#39;blog-name&#39;</code> 来创建一个页面，在blog\source_post目录下就会生成一个blog-name.md文件</p><p>然后我们使用markdown的语法来写文章即可</p><h3 id="使用hexo-admin更新博客"><a href="#使用hexo-admin更新博客" class="headerlink" title="使用hexo-admin更新博客"></a>使用hexo-admin更新博客</h3><p>hexo提供了一个admin页面，来基于可视化窗口更新博客.<br>执行下面两个命令，安装hexo-admin以及启动hexo server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-admin</span><br><span class="line">hexo server -d(开启hexo操作)</span><br></pre></td></tr></table></figure><p>打开<a href="http://IP:4000/admin" target="_blank" rel="noopener">http://IP:4000/admin</a> 就可以进入控制台。</p><ul><li>posts 新建博客</li><li>pages 页面</li><li>deploy 将更新的博客发布到github</li></ul><h2 id="更新主题"><a href="#更新主题" class="headerlink" title="更新主题"></a>更新主题</h2><p>默认的博客界面比较丑，想要更换主题怎么办呢？</p><p>hexo官方提供了非常多的主题：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a><br>选择自己喜欢的主题，并且下载到本地。<br>把主题拷贝到 <code>blog/themes</code>目录下</p><p>修改_config.yml中的theme: landscape改为theme: yilia，然后执行hexo g来重新基于新的主题生成静态页面</p><h2 id="更多的hexo操作"><a href="#更多的hexo操作" class="headerlink" title="更多的hexo操作"></a>更多的hexo操作</h2><p>由于每个人对于hexo的使用需求不一样，所以大家可以自己去<br><a href="https://hexo.io/zh-cn/docs/plugins" target="_blank" rel="noopener">这个网站</a>查看更多的hexo说明。</p><p><img src="/images/pasted-6.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用github搭建个人博客后，一个不懂前端开发的人如何去写各种前端页面呢？好在，有了hexo，这些都可以轻松搞定.&lt;/p&gt;
    
    </summary>
    
      <category term="备忘录" scheme="https://istio.tech/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
      <category term="Hexo" scheme="https://istio.tech/tags/Hexo/"/>
    
      <category term="Node" scheme="https://istio.tech/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>如何使用Github搭建个人博客</title>
    <link href="https://istio.tech/2019/07/09/hello-world/"/>
    <id>https://istio.tech/2019/07/09/hello-world/</id>
    <published>2019-07-09T05:39:00.000Z</published>
    <updated>2019-07-11T14:40:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作为程序员，我们把大部分写代码的能力交给了搜索引擎，把大部分时间交给了业务逻辑的开发。却很少停下来对自己的工作和学习做一些总结和思考。我认为写博客是一种很好的习惯，不是为了给别人看自己写的东西有多🐂🍺，而是阶段性的给自己做一些总结。长期的积累，能够给自己带来很大的变化！</p></blockquote><a id="more"></a><p>我以前比较喜欢用gitbook来整理一些东西，后来因为github用得多，就干脆基于github来构建一个个人博客，闲暇之余可以把一些东西沉淀下来。</p><h1 id="github配置"><a href="#github配置" class="headerlink" title="github配置"></a>github配置</h1><h2 id="账号注册"><a href="#账号注册" class="headerlink" title="账号注册"></a>账号注册</h2><p>打开这个网址，注册一个github的账号<br><a href="https://github.com/join?source=header-home" target="_blank" rel="noopener">https://github.com/join?source=header-home</a></p><h2 id="创建repository"><a href="#创建repository" class="headerlink" title="创建repository"></a>创建repository</h2><p>创建一个repository，repository name设置的注意事项</p><p>[username].github.io , <code>username</code> 必须是github注册的用户名，否则无法访问</p><p><img src="/images/pasted-0.png" alt="upload successful"></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>创建好repository之后，提交一个基本的index.html。然后使用<br><code>[username].github.io</code> 来访问到index.html页面</p><blockquote><p>在本地的终端上，按照下面的命令，来提交一个index.html文件到github对应刚刚创建的repository中</p></blockquote><p><strong>index.html自己提前创建好，内容没有要求</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add index.html</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git remote add origin https://github.com/2227324689/2227324689.github.io.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>如果本地没有安装git客户端，是无法使用这些命令的。</p><h2 id="git客户端（window"><a href="#git客户端（window" class="headerlink" title="git客户端（window)"></a>git客户端（window)</h2><p>首先下载git for window 客户端<br><a href="https://github.com/git-for-windows/git/releases/tag/v2.22.0.windows.1" target="_blank" rel="noopener">https://github.com/git-for-windows/git/releases/tag/v2.22.0.windows.1</a></p><p>根据自己的操作系统版本来选择对应的下载文件。<br><img src="/images/pasted-1.png" alt="upload successful"></p><p>安装过程就不再赘述，一直<code>下一步</code>即可，安装结束之后，可以在<code>cmd</code>命令中输入<code>git -v</code> ，如果能够返回当前git的版本号，说明git安装成功了。</p><h2 id="git配置ssh"><a href="#git配置ssh" class="headerlink" title="git配置ssh"></a>git配置ssh</h2><p>github提供了两种方式来pull/push 文件，一种是基于https，一种是基于ssh。两种方式都可以用，但是为了方便起见（不用每次都输入密码），可以配置ssh</p><p><img src="/images/pasted-2.png" alt="upload successful"></p><h3 id="在本地生成ssh-公私钥"><a href="#在本地生成ssh-公私钥" class="headerlink" title="在本地生成ssh 公私钥"></a>在本地生成ssh 公私钥</h3><blockquote><p>检查本机是否有ssh key设置</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.ssh 或cd .ssh</span><br><span class="line"></span><br><span class="line">如果没有则提示： No such file or directory</span><br><span class="line"></span><br><span class="line">如果有则进入~/.ssh路径下（ls查看当前路径文件，rm * 删除所有文件）</span><br><span class="line">$ cd ~/.ssh 或cd .ssh</span><br><span class="line"></span><br><span class="line">**如果.ssh文件夹不存在，则创建一个**</span><br></pre></td></tr></table></figure><blockquote><p>使用ssh-keygen生成公私钥</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在.ssh目录下，执行`ssh-keygen -t rsa -C &quot;xxxxxx@yy.com&quot;`</span><br><span class="line">邮箱地址没有限制，建议填有效邮箱</span><br><span class="line">代码参数含义：</span><br><span class="line">-t 指定密钥类型，默认是 rsa ，可以省略。</span><br><span class="line">-C 设置注释文字，比如邮箱。</span><br><span class="line">-f 指定密钥文件存储文件名。</span><br></pre></td></tr></table></figure><p>这个命令执行过程中，会要求你输入文件名和密码，如果不需要改，则直接默认回车就行<br>这里的密码可以不用设，如果设置了，后续每次提交文件到github都需要输入密码验证</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> which to save the key (/Users/mic/.ssh/id_rsa):</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br></pre></td></tr></table></figure><p><strong>命令执行结束后，会在.ssh目录下生成两个文件，<code>id_rsa</code>,<code>id_rsa.pub</code></strong></p><p>id_rsa.pub是公钥，这个公钥可以直接用可以打开，里面就是一段公钥的代码，这段代码需要复制下来。后续需要配置到github上</p><h3 id="github上配置公钥"><a href="#github上配置公钥" class="headerlink" title="github上配置公钥"></a>github上配置公钥</h3><p>进入 &gt; profile -&gt; settings -&gt;ssh and GPG keys。<br>或者直接<a href="https://github.com/settings/keys" target="_blank" rel="noopener">点击这里</a>直接跳转到ssh key配置的页面</p><p><img src="/images/pasted-3.png" alt="upload successful"></p><p>点击<code>New SSH key</code>.</p><p>title  自己定义一个名称，一般来说用来区分当前是哪个机器的key，后续方便管理</p><p>key   把前面生成的<code>id_rsa.pub</code>文件中的内容全部复制粘贴在这里即可。点击<code>Add SSH key</code> 保存</p><p><img src="/images/pasted-4.png" alt="upload successful"></p><blockquote><p>在本地的客户端进行测试</p></blockquote><p>输入下面命令，所有内容都不用改。 </p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line">--如果返回下面这个信息，说明ssh配置成功了</span><br><span class="line">Hi <span class="number">2227324689</span>! You've successfully authenticated, but GitHub does <span class="keyword">not</span> provide shell access.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作为程序员，我们把大部分写代码的能力交给了搜索引擎，把大部分时间交给了业务逻辑的开发。却很少停下来对自己的工作和学习做一些总结和思考。我认为写博客是一种很好的习惯，不是为了给别人看自己写的东西有多🐂🍺，而是阶段性的给自己做一些总结。长期的积累，能够给自己带来很大的变化！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="备忘录" scheme="https://istio.tech/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
      <category term="Hexo" scheme="https://istio.tech/tags/Hexo/"/>
    
      <category term="github" scheme="https://istio.tech/tags/github/"/>
    
      <category term="博客" scheme="https://istio.tech/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>

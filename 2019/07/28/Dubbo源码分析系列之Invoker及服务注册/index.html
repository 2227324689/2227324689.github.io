<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.9.0">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="Java架构师,Java经验分享,架构师成长路线,Java架构技能">
  <meta name="keyword" content="hexo-theme, 咕泡, Mic, Spring Cloud Alibaba">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      Dubbo源码分析系列之Invoker及服务注册 | 风骚的Mic
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
</head>
<div class="wechat-share">
  <img src="/css/images/logo.png">
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>风骚的Mic</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">主页</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">标签</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">归档</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">项目</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/rss/" class="item-link">订阅</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">关于</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">主页</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">标签</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">归档</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">项目</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/rss/" class="menu-link">订阅</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">关于</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>Dubbo源码分析系列之Invoker及服务注册</h2>
  <p class="post-date">2019-07-28</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p>分析服务发布过程中所构建的Invoker，以及服务注册的流程</p>
<p>从前面的分析来看，服务的发布分三个阶段</p>
<p>第一个阶段会创造一个invoker</p>
<p>第二个阶段会把经历过一系列处理的invoker（各种包装），在DubboProtocol中保存到exporterMap中</p>
<p>第三个阶段把dubbo协议的url地址注册到注册中心上</p>
<p>前面没有分析Invoker，我们来简单看看Invoker到底是一个啥东西。</p>
<a id="more"></a>
<p>Invoker是Dubbo领域模型中非常重要的一个概念, 和ExtensionLoader的重要性是一样的，如果Invoker没有搞懂，那么不算是看懂了Dubbo的源码。我们继续回到ServiceConfig中export的代码，这段代码是还没有分析过的。以这个作为入口来分析我们前面export出去的invoker到底是啥东西</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));</span><br></pre></td></tr></table></figure>

<h2 id="ProxyFacotory-getInvoker"><a href="#ProxyFacotory-getInvoker" class="headerlink" title="ProxyFacotory.getInvoker"></a>ProxyFacotory.getInvoker</h2><p>这个是一个代理工程，用来生成invoker，从它的定义来看，它是一个自适应扩展点，看到这样的扩展点，我们几乎可以不假思索的想到它会存在一个动态适配器类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();</span><br></pre></td></tr></table></figure>

<h2 id="ProxyFactory"><a href="#ProxyFactory" class="headerlink" title="ProxyFactory"></a>ProxyFactory</h2><p>这个方法的简单解读为： 它是一个spi扩展点，并且默认的扩展实现是javassit, 这个接口中有三个方法，并且都是加了@Adaptive的自适应扩展点。所以如果调用getInvoker方法，应该会返回一个ProxyFactory$Adaptive</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"javassist"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, <span class="keyword">boolean</span> generic)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException</span>;</span><br></pre></td></tr></table></figure>

<h2 id="ProxyFactory-Adaptive"><a href="#ProxyFactory-Adaptive" class="headerlink" title="ProxyFactory$Adaptive"></a>ProxyFactory$Adaptive</h2><p>这个自适应扩展点，做了两件事情</p>
<ul>
<li>通过ExtensionLoader.getExtensionLoader(ProxyFactory.class).getExtension(extName)获取了一个指定名称的扩展点,</li>
<li>在dubbo-rpc-api/resources/META-INF/com.alibaba.dubbo.rpc.ProxyFactory中，定义了javassis=JavassisProxyFactory</li>
<li>调用JavassisProxyFactory的getInvoker方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">dubbo</span>.<span class="title">rpc</span>.<span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">getProxy</span><span class="params">(org.apache.dubbo.rpc.Invoker arg0)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.Invoker argument == null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg0.getUrl() == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.Invoker argument getUrl() == null"</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class="line">        String extName = url.getParameter(<span class="string">"proxy"</span>, <span class="string">"javassist"</span>);</span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.rpc.ProxyFactory) name from url ("</span> + url.toString() + <span class="string">") use keys([proxy])"</span>);</span><br><span class="line">        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.getProxy(arg0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">getProxy</span><span class="params">(org.apache.dubbo.rpc.Invoker arg0, <span class="keyword">boolean</span> arg1)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.Invoker argument == null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg0.getUrl() == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.Invoker argument getUrl() == null"</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class="line">        String extName = url.getParameter(<span class="string">"proxy"</span>, <span class="string">"javassist"</span>);</span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.rpc.ProxyFactory) name from url ("</span> + url.toString() + <span class="string">") use keys([proxy])"</span>);</span><br><span class="line">        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.getProxy(arg0, arg1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.<span class="function">Invoker <span class="title">getInvoker</span><span class="params">(java.lang.Object arg0, java.lang.Class arg1, org.apache.dubbo.common.URL arg2)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg2 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg2;</span><br><span class="line">        String extName = url.getParameter(<span class="string">"proxy"</span>, <span class="string">"javassist"</span>);</span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.rpc.ProxyFactory) name from url ("</span> + url.toString() + <span class="string">") use keys([proxy])"</span>);</span><br><span class="line">        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.getInvoker(arg0, arg1, arg2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JavassistProxyFactory-getInvoker"><a href="#JavassistProxyFactory-getInvoker" class="headerlink" title="JavassistProxyFactory.getInvoker"></a>JavassistProxyFactory.getInvoker</h2><p>javassist是一个动态类库，用来实现动态代理的。</p>
<p>proxy:接口的实现: com.gupaoedu.practice.dubbo.SayHelloServiceImpl</p>
<p>type:接口全称 com.gupaoedu.dubbo.ISayHelloService</p>
<p>url:协议地址：registry://…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Wrapper cannot handle this scenario correctly: the classname contains '$'</span></span><br><span class="line">        <span class="keyword">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class="string">'$'</span>) &lt; <span class="number">0</span> ? proxy.getClass() : type);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Object[] arguments)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="javassist生成的动态代理代码"><a href="#javassist生成的动态代理代码" class="headerlink" title="javassist生成的动态代理代码"></a>javassist生成的动态代理代码</h2><p>通过断点的方式（Wrapper258行），在Wrapper.getWrapper中的makeWrapper，会创建一个动态代理，核心的方法invokeMethod代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invokeMethod</span><span class="params">(Object o, String n, Class[] p, Object[] v)</span> <span class="keyword">throws</span> java.lang.reflect.InvocationTargetException </span>&#123;</span><br><span class="line">        com.gupaoedu.dubbo.practice.ISayHelloService w;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            w = ((com.gupaoedu.dubbo.practice.ISayHelloService) $<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"sayHello"</span>.equals($<span class="number">2</span>) &amp;&amp; $<span class="number">3</span>.length == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ($w) w.sayHello((java.lang.String) $<span class="number">4</span>[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.lang.reflect.InvocationTargetException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> org.apache.dubbo.common.bytecode.NoSuchMethodException(<span class="string">"Not found method \""</span> + $<span class="number">2</span> + <span class="string">"\" in class com.gupaoedu.dubbo.practice.ISayHelloService."</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>构建好了代理类之后，返回一个AbstractproxyInvoker,并且它实现了doInvoke方法，这个地方似乎看到了dubbo消费者调用过来的时候触发的影子，因为wrapper.invokeMethod本质上就是触发上面动态代理类的方法invokeMethod.  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Object[] arguments)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>所以，简单总结一下Invoke本质上应该是一个代理，经过层层包装最终进行了发布。当消费者发起请求的时候，会获得这个invoker进行调用。</p>
<p>最终发布出去的invoker, 也不是单纯的一个代理，也是经过多层包装</p>
<p>InvokerDelegate(DelegateProviderMetaDataInvoker(AbstractProxyInvoker()))</p>
<h1 id="服务注册流程"><a href="#服务注册流程" class="headerlink" title="服务注册流程"></a>服务注册流程</h1><p>关于服务发布这一条线分析完成之后，再来了解一下服务注册的过程，希望大家还记得我们之所以走到这一步，是因为我们在RegistryProtocol这个类中，看到了服务发布的流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class="line">        <span class="comment">// url to export locally</span></span><br><span class="line">        URL providerUrl = getProviderUrl(originInvoker);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Subscribe the override data</span></span><br><span class="line">        <span class="comment">// FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call</span></span><br><span class="line">        <span class="comment">//  the same service. Because the subscribed is cached key with the name of the service, it causes the</span></span><br><span class="line">        <span class="comment">//  subscription information to cover.</span></span><br><span class="line">        <span class="keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(providerUrl);</span><br><span class="line">        <span class="keyword">final</span> OverrideListener overrideSubscribeListener = <span class="keyword">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class="line">        overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line"></span><br><span class="line">        providerUrl = overrideUrlWithConfig(providerUrl, overrideSubscribeListener);</span><br><span class="line">        <span class="comment">//export invoker</span></span><br><span class="line">        <span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker, providerUrl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// url to registry</span></span><br><span class="line">        <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line">        <span class="keyword">final</span> URL registeredProviderUrl = getRegisteredProviderUrl(providerUrl, registryUrl);</span><br><span class="line">        ProviderInvokerWrapper&lt;T&gt; providerInvokerWrapper = ProviderConsumerRegTable.registerProvider(originInvoker,</span><br><span class="line">                registryUrl, registeredProviderUrl);</span><br><span class="line">        <span class="comment">//to judge if we need to delay publish</span></span><br><span class="line">        <span class="keyword">boolean</span> register = registeredProviderUrl.getParameter(<span class="string">"register"</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (register) &#123;</span><br><span class="line">            register(registryUrl, registeredProviderUrl);</span><br><span class="line">            providerInvokerWrapper.setReg(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Deprecated! Subscribe to override rules in 2.6.x or before.</span></span><br><span class="line">        registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line"></span><br><span class="line">        exporter.setRegisterUrl(registeredProviderUrl);</span><br><span class="line">        exporter.setSubscribeUrl(overrideSubscribeUrl);</span><br><span class="line">        <span class="comment">//Ensure that a new exporter instance is returned every time export</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DestroyableExporter&lt;&gt;(exporter);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="服务注册核心代码"><a href="#服务注册核心代码" class="headerlink" title="服务注册核心代码"></a>服务注册核心代码</h2><p>从export方法中抽离出来的部分代码，就是服务注册的流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// url to registry</span></span><br><span class="line">        <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line">        <span class="keyword">final</span> URL registeredProviderUrl = getRegisteredProviderUrl(providerUrl, registryUrl);</span><br><span class="line">        ProviderInvokerWrapper&lt;T&gt; providerInvokerWrapper = ProviderConsumerRegTable.registerProvider(originInvoker,</span><br><span class="line">                registryUrl, registeredProviderUrl);</span><br><span class="line">        <span class="comment">//to judge if we need to delay publish</span></span><br><span class="line">        <span class="keyword">boolean</span> register = registeredProviderUrl.getParameter(<span class="string">"register"</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (register) &#123;</span><br><span class="line">            register(registryUrl, registeredProviderUrl);</span><br><span class="line">            providerInvokerWrapper.setReg(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="getRegistry"><a href="#getRegistry" class="headerlink" title="getRegistry"></a>getRegistry</h2><ol>
<li>把url转化为对应配置的注册中心的具体协议</li>
<li>根据具体协议，从registryFactory中获得指定的注册中心实现</li>
</ol>
<p>那么这个registryFactory具体是怎么赋值的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Registry <span class="title">getRegistry</span><span class="params">(<span class="keyword">final</span> Invoker&lt;?&gt; originInvoker)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把url转化为配置的具体协议，比如zookeeper://ip:port. 这样后续获得的注册中心就会是基于zk的实现</span></span><br><span class="line">        URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class="line">        <span class="keyword">return</span> registryFactory.getRegistry(registryUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在RegistryProtocol中存在一段这样的代码，很明显这是通过依赖注入来实现的扩展点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RegistryFactory registryFactory; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRegistryFactory</span><span class="params">(RegistryFactory registryFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.registryFactory = registryFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照扩展点的加载规则，我们可以先看看/META-INF/dubbo/internal路径下找到RegistryFactory的配置文件.这个factory有多个扩展点的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dubbo=org.apache.dubbo.registry.dubbo.DubboRegistryFactory</span><br><span class="line">multicast=org.apache.dubbo.registry.multicast.MulticastRegistryFactory</span><br><span class="line">zookeeper=org.apache.dubbo.registry.zookeeper.ZookeeperRegistryFactory</span><br><span class="line">redis=org.apache.dubbo.registry.redis.RedisRegistryFactory</span><br><span class="line">consul=org.apache.dubbo.registry.consul.ConsulRegistryFactory</span><br><span class="line"></span><br><span class="line">etcd3=org.apache.dubbo.registry.etcd.EtcdRegistryFactory</span><br></pre></td></tr></table></figure>

<p>接着，找到RegistryFactory的实现, 发现它里面有一个自适应的方法，根据url中protocol传入的值进行适配</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"dubbo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RegistryFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;<span class="string">"protocol"</span>&#125;)</span><br><span class="line">    <span class="function">Registry <span class="title">getRegistry</span><span class="params">(URL url)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="RegistryFactory-Adaptive"><a href="#RegistryFactory-Adaptive" class="headerlink" title="RegistryFactory$Adaptive"></a>RegistryFactory$Adaptive</h2><p>由于在前面的代码中，url中的protocol已经改成了zookeeper，那么这个时候根据zookeeper获得的spi扩展点应该是ZookeeperRegistryFactory</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegistryFactory</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">dubbo</span>.<span class="title">registry</span>.<span class="title">RegistryFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.registry.<span class="function">Registry <span class="title">getRegistry</span><span class="params">(org.apache.dubbo.common.URL arg0)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg0;</span><br><span class="line">        String extName = ( url.getProtocol() == <span class="keyword">null</span> ? <span class="string">"dubbo"</span> : url.getProtocol() );</span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.registry.RegistryFactory) name from url ("</span> + url.toString() + <span class="string">") use keys([protocol])"</span>);</span><br><span class="line">        org.apache.dubbo.registry.RegistryFactory extension = (org.apache.dubbo.registry.RegistryFactory)ExtensionLoader.getExtensionLoader(org.apache.dubbo.registry.RegistryFactory.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.getRegistry(arg0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ZookeeperRegistryFactory"><a href="#ZookeeperRegistryFactory" class="headerlink" title="ZookeeperRegistryFactory"></a>ZookeeperRegistryFactory</h2><p>这个方法中并没有getRegistry方法，而是在父类AbstractRegistryFactory</p>
<ul>
<li>从缓存REGISTRIES中，根据key获得对应的Registry</li>
<li>如果不存在，则创建Registry</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Registry <span class="title">getRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        url = URLBuilder.from(url)</span><br><span class="line">                .setPath(RegistryService.class.getName())</span><br><span class="line">                .addParameter(Constants.INTERFACE_KEY, RegistryService.class.getName())</span><br><span class="line">                .removeParameters(Constants.EXPORT_KEY, Constants.REFER_KEY)</span><br><span class="line">                .build();</span><br><span class="line">        String key = url.toServiceStringWithoutResolving();</span><br><span class="line">        <span class="comment">// Lock the registry access process to ensure a single instance of the registry</span></span><br><span class="line">        LOCK.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Registry registry = REGISTRIES.get(key);</span><br><span class="line">            <span class="keyword">if</span> (registry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> registry;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//创建注册中心</span></span><br><span class="line">            registry = createRegistry(url);</span><br><span class="line">            <span class="keyword">if</span> (registry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Can not create registry "</span> + url);</span><br><span class="line">            &#125;</span><br><span class="line">            REGISTRIES.put(key, registry);</span><br><span class="line">            <span class="keyword">return</span> registry;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Release the lock</span></span><br><span class="line">            LOCK.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="createRegistry"><a href="#createRegistry" class="headerlink" title="createRegistry"></a>createRegistry</h2><p>创建一个zookeeperRegistry，把url和zookeepertransporter作为参数传入。</p>
<p>zookeeperTransporter 这个属性也是基于依赖注入来赋值的，具体的流程就不再分析了，这个的值应该是</p>
<p><code>CuratorZookeeperTransporter</code> 表示具体使用什么框架来和zk产生连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Registry <span class="title">createRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ZookeeperRegistry(url, zookeeperTransporter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ZookeeperRegistry"><a href="#ZookeeperRegistry" class="headerlink" title="ZookeeperRegistry"></a>ZookeeperRegistry</h2><p>这个方法中使用了CuratorZookeeperTransport来实现zk的连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZookeeperRegistry</span><span class="params">(URL url, ZookeeperTransporter zookeeperTransporter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(url);</span><br><span class="line">        <span class="keyword">if</span> (url.isAnyHost()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"registry address == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//获得group名称</span></span><br><span class="line">        String group = url.getParameter(Constants.GROUP_KEY, DEFAULT_ROOT);</span><br><span class="line">        <span class="keyword">if</span> (!group.startsWith(Constants.PATH_SEPARATOR)) &#123;</span><br><span class="line">            group = Constants.PATH_SEPARATOR + group;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.root = group;</span><br><span class="line">    <span class="comment">//产生一个zookeeper连接</span></span><br><span class="line">        zkClient = zookeeperTransporter.connect(url);</span><br><span class="line">    <span class="comment">//添加zookeeper状态变化事件</span></span><br><span class="line">        zkClient.addStateListener(state -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (state == StateListener.RECONNECTED) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    recover();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    logger.error(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="registry-register-registedProviderUrl"><a href="#registry-register-registedProviderUrl" class="headerlink" title="registry.register(registedProviderUrl);"></a>registry.register(registedProviderUrl);</h2><p>继续往下分析，会调用registry.register去讲dubbo://的协议地址注册到zookeeper上</p>
<p>这个方法会调用FailbackRegistry类中的register. 为什么呢？因为ZookeeperRegistry这个类中并没有register这个方法，但是他的父类FailbackRegistry中存在register方法，而这个类又重写了AbstractRegistry类中的register方法。所以我们可以直接定位大FailbackRegistry这个类中的register方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">register(registryUrl, registeredProviderUrl);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL registryUrl, URL registeredProviderUrl)</span> </span>&#123;</span><br><span class="line">        Registry registry = registryFactory.getRegistry(registryUrl);</span><br><span class="line">        registry.register(registeredProviderUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FailbackRegistry-register"><a href="#FailbackRegistry-register" class="headerlink" title="FailbackRegistry.register"></a>FailbackRegistry.register</h2><ul>
<li>FailbackRegistry，从名字上来看，是一个失败重试机制</li>
<li>调用父类的register方法，讲当前url添加到缓存集合中</li>
</ul>
<p>调用doRegister方法，这个方法很明显，是一个抽象方法，会由ZookeeperRegistry子类实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.register(url);</span><br><span class="line">        removeFailedRegistered(url);</span><br><span class="line">        removeFailedUnregistered(url);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用子类实现真正的服务注册，把url注册到zk上</span></span><br><span class="line">            doRegister(url);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Throwable t = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果开启了启动时检测，则直接抛出异常</span></span><br><span class="line">            <span class="keyword">boolean</span> check = getUrl().getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)</span><br><span class="line">                    &amp;&amp; url.getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)</span><br><span class="line">                    &amp;&amp; !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol());</span><br><span class="line">            <span class="keyword">boolean</span> skipFailback = t <span class="keyword">instanceof</span> SkipFailbackWrapperException;</span><br><span class="line">            <span class="keyword">if</span> (check || skipFailback) &#123;</span><br><span class="line">                <span class="keyword">if</span> (skipFailback) &#123;</span><br><span class="line">                    t = t.getCause();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to register "</span> + url + <span class="string">" to registry "</span> + getUrl().getAddress() + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.error(<span class="string">"Failed to register "</span> + url + <span class="string">", waiting for retry, cause: "</span> + t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将失败的注册请求记录到失败列表，定时重试</span></span><br><span class="line">            addFailedRegistered(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ZookeeperRegistry-doRegister"><a href="#ZookeeperRegistry-doRegister" class="headerlink" title="ZookeeperRegistry.doRegister"></a>ZookeeperRegistry.doRegister</h2><p>最终调用curator的客户端把服务地址注册到zk</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, <span class="keyword">true</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to register "</span> + url + <span class="string">" to zookeeper "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="思考服务消费应该要具备的逻辑"><a href="#思考服务消费应该要具备的逻辑" class="headerlink" title="思考服务消费应该要具备的逻辑"></a>思考服务消费应该要具备的逻辑</h1><p>如果要实现服务的消费，大家可以结合之前手写rpc的课程来思考一下</p>
<ol>
<li>生成远程服务的代理</li>
<li>获得目标服务的url地址</li>
<li>实现远程网络通信</li>
<li>实现负载均衡</li>
<li>实现集群容错</li>
</ol>
<p><img src="http://dubbo.apache.org/docs/zh-cn/dev/sources/images/dubbo_rpc_refer.jpg" alt="/dev-guide/images/dubbo_rpc_refer.jpg"></p>
<h1 id="服务的消费"><a href="#服务的消费" class="headerlink" title="服务的消费"></a>服务的消费</h1><p>消费端的代码解析是从下面这段代码开始的</p>
<p><code>&lt;dubbo:reference id=&quot;xxxService&quot; interface=&quot;xxx.xxx.Service&quot;/&gt;</code></p>
<p>注解的方式的初始化入口是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReferenceAnnotationBeanPostProcessor-&gt;ReferenceBeanInvocationHandler.init-&gt;ReferenceConfig.get() 获得一个远程代理类</span><br></pre></td></tr></table></figure>

<h2 id="ReferenceConfig-get"><a href="#ReferenceConfig-get" class="headerlink" title="ReferenceConfig.get"></a>ReferenceConfig.get</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkAndUpdateSubConfigs(); <span class="comment">//检查和修改配置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The invoker of ReferenceConfig("</span> + url + <span class="string">") has already destroyed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ref == <span class="keyword">null</span>) &#123; <span class="comment">//如果当前接口的远程代理引用为空，则进行初始化</span></span><br><span class="line">            init();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ref;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><p>初始化的过程，和服务发布的过程类似，会有特别多的判断以及参数的组装. 我们只需要关注createProxy，创建代理类的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line"> 	ref = createProxy(map);   </span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="createProxy"><a href="#createProxy" class="headerlink" title="createProxy"></a>createProxy</h2><p>代码比较长，但是逻辑相对比较清晰</p>
<ol>
<li>判断是否为本地调用，如果是则使用injvm协议进行调用</li>
<li>判断是否为点对点调用，如果是则把url保存到urls集合中，如果url为1，进入步骤4，如果urls&gt;1 ，则执行5</li>
<li>如果是配置了注册中心，遍历注册中心，把url添加到urls集合，url为1，进入步骤4，如果urls&gt;1 ，则执行5</li>
<li>直连构建invoker</li>
<li>构建invokers集合，通过cluster合并多个invoker</li>
<li>最后调用 ProxyFactory 生成代理类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createProxy</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldJvmRefer(map)) &#123; <span class="comment">//判断是否是在同一个jvm进程中调用</span></span><br><span class="line">            URL url = <span class="keyword">new</span> URL(Constants.LOCAL_PROTOCOL, Constants.LOCALHOST_VALUE, <span class="number">0</span>, interfaceClass.getName()).addParameters(map);</span><br><span class="line">            invoker = refprotocol.refer(interfaceClass, url);</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"Using injvm service "</span> + interfaceClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//url 如果不为空，说明是点对点通信</span></span><br><span class="line">            <span class="keyword">if</span> (url != <span class="keyword">null</span> &amp;&amp; url.length() &gt; <span class="number">0</span>) &#123; <span class="comment">// user specified URL, could be peer-to-peer address, or register center's address.</span></span><br><span class="line">                String[] us = Constants.SEMICOLON_SPLIT_PATTERN.split(url);</span><br><span class="line">                <span class="keyword">if</span> (us != <span class="keyword">null</span> &amp;&amp; us.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String u : us) &#123;</span><br><span class="line">                        URL url = URL.valueOf(u);</span><br><span class="line">                        <span class="keyword">if</span> (StringUtils.isEmpty(url.getPath())) &#123;</span><br><span class="line">                            url = url.setPath(interfaceName);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 检测 url 协议是否为 registry，若是，表明用户想使用指定的注册中心</span></span><br><span class="line">                        <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">                             <span class="comment">// 将 map 转换为查询字符串，并作为 refer 参数的值添加到 url 中</span></span><br><span class="line">                            urls.add(url.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 合并 url，移除服务提供者的一些配置（这些配置来源于用户配置的 url 属性），</span></span><br><span class="line">                        <span class="comment">// 比如线程池相关配置。并保留服务提供者的部分配置，比如版本，group，时间戳等</span></span><br><span class="line">                        <span class="comment">// 最后将合并后的配置设置为 url 查询字符串中。</span></span><br><span class="line">                            urls.add(ClusterUtils.mergeUrl(url, map));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// assemble URL from register center's configuration</span></span><br><span class="line">                checkRegistry(); <span class="comment">//校验注册中心的配置以及是否有必要从配置中心组装url</span></span><br><span class="line">                <span class="comment">//这里的代码实现和服务端类似，也是根据注册中心配置进行解析得到URL</span></span><br><span class="line">      <span class="comment">//这里的URL肯定也是： registry://ip:port/org.apache.dubbo.service.RegsitryService</span></span><br><span class="line">                List&lt;URL&gt; us = loadRegistries(<span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (CollectionUtils.isNotEmpty(us)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (URL u : us) &#123;</span><br><span class="line">                        URL monitorUrl = loadMonitor(u);</span><br><span class="line">                        <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));</span><br><span class="line">                        &#125;</span><br><span class="line">                        urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果没有配置注册中心，则报错</span></span><br><span class="line">                <span class="keyword">if</span> (urls.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No such any registry to reference "</span> + interfaceName + <span class="string">" on the consumer "</span> + NetUtils.getLocalHost() + <span class="string">" use dubbo version "</span> + Version.getVersion() + <span class="string">", please config &lt;dubbo:registry address=\"...\" /&gt; to your spring config."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//如果值配置了一个注册中心或者一个服务提供者，直接使用refprotocol.refer</span></span><br><span class="line">            <span class="keyword">if</span> (urls.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                invoker = refprotocol.refer(interfaceClass, urls.get(<span class="number">0</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                List&lt;Invoker&lt;?&gt;&gt; invokers = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;?&gt;&gt;();</span><br><span class="line">                URL registryURL = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (URL url : urls) &#123;<span class="comment">//遍历urls生成多个invoker</span></span><br><span class="line">                    invokers.add(refprotocol.refer(interfaceClass, url));</span><br><span class="line">                    <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">                        registryURL = url; <span class="comment">// use last registry url</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (registryURL != <span class="keyword">null</span>) &#123; <span class="comment">//如果registryUrl不为空，构建静态directory</span></span><br><span class="line">                    <span class="comment">// 使用RegistryAwareCluster</span></span><br><span class="line">                    URL u = registryURL.addParameter(Constants.CLUSTER_KEY, RegistryAwareCluster.NAME);</span><br><span class="line">                    <span class="comment">// 通过Cluster将多个invoker合并 RegistryAwareClusterInvoker(StaticDirectory) -&gt; FailoverClusterInvoker(RegistryDirectory, will execute route) -&gt; Invoker</span></span><br><span class="line">                    invoker = cluster.join(<span class="keyword">new</span> StaticDirectory(u, invokers));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                    invoker = cluster.join(<span class="keyword">new</span> StaticDirectory(invokers));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//检查invoker的有效性</span></span><br><span class="line">        <span class="keyword">if</span> (shouldCheck() &amp;&amp; !invoker.isAvailable()) &#123;</span><br><span class="line">            <span class="comment">// make it possible for consumer to retry later if provider is temporarily unavailable</span></span><br><span class="line">            initialized = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to check the status of the service "</span> + interfaceName + <span class="string">". No provider available for the service "</span> + (group == <span class="keyword">null</span> ? <span class="string">""</span> : group + <span class="string">"/"</span>) + interfaceName + (version == <span class="keyword">null</span> ? <span class="string">""</span> : <span class="string">":"</span> + version) + <span class="string">" from the url "</span> + invoker.getUrl() + <span class="string">" to the consumer "</span> + NetUtils.getLocalHost() + <span class="string">" use dubbo version "</span> + Version.getVersion());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Refer dubbo service "</span> + interfaceClass.getName() + <span class="string">" from url "</span> + invoker.getUrl());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@since</span> 2.7.0</span></span><br><span class="line"><span class="comment">         * ServiceData Store</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        MetadataReportService metadataReportService = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((metadataReportService = getMetadataReportService()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            URL consumerURL = <span class="keyword">new</span> URL(Constants.CONSUMER_PROTOCOL, map.remove(Constants.REGISTER_IP_KEY), <span class="number">0</span>, map.get(Constants.INTERFACE_KEY), map);</span><br><span class="line">            metadataReportService.publishConsumer(consumerURL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// create service proxy</span></span><br><span class="line">        <span class="keyword">return</span> (T) proxyFactory.getProxy(invoker);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="protocol-refer"><a href="#protocol-refer" class="headerlink" title="protocol.refer"></a>protocol.refer</h2><p>这里通过指定的协议来调用refer生成一个invoker对象，invoker前面讲过，它是一个代理对象。那么在当前的消费端而言，invoker主要用于执行远程调用。</p>
<p>这个protocol，又是一个自适应扩展点，它得到的是一个Protocol$Adaptive.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Protocol refprotocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension()</span><br></pre></td></tr></table></figure>

<p>这段代码中，根据当前的协议url，得到一个指定的扩展点，传递进来的参数中，协议地址为registry://，所以，我们可以直接定位到RegistryProtocol.refer代码</p>
<blockquote>
<p><strong>Protocol$Adaptive中的refer方法</strong></p>
</blockquote>
<p>根据当前的协议扩展名registry, 获得一个被包装过的RegistryProtocol</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> org.apache.dubbo.rpc.<span class="function">Invoker <span class="title">refer</span><span class="params">(java.lang.Class arg0, org.apache.dubbo.common.URL arg1)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg1 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg1;</span><br><span class="line">        String extName = ( url.getProtocol() == <span class="keyword">null</span> ? <span class="string">"dubbo"</span> : url.getProtocol() );</span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url ("</span> + url.toString() + <span class="string">") use keys([protocol])"</span>);</span><br><span class="line">        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.refer(arg0, arg1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="RegistryProtocol-refer"><a href="#RegistryProtocol-refer" class="headerlink" title="RegistryProtocol.refer"></a>RegistryProtocol.refer</h2><p>这里面的代码逻辑比较简单</p>
<ul>
<li>组装注册中心协议的url</li>
<li>判断是否配置legroup，如果有，则cluster=getMergeableCluster()，构建invoker</li>
<li>doRefer构建invoker</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">//这段代码也很熟悉，就是根据配置的协议，生成注册中心的url: zookeeper://</span></span><br><span class="line">       url = URLBuilder.from(url)</span><br><span class="line">               .setProtocol(url.getParameter(REGISTRY_KEY, DEFAULT_REGISTRY))</span><br><span class="line">               .removeParameter(REGISTRY_KEY)</span><br><span class="line">               .build();</span><br><span class="line">       Registry registry = registryFactory.getRegistry(url);</span><br><span class="line">       <span class="keyword">if</span> (RegistryService.class.equals(type)) &#123;</span><br><span class="line">           <span class="keyword">return</span> proxyFactory.getInvoker((T) registry, type, url);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 解析group参数，根据group决定cluster的类型</span></span><br><span class="line">       Map&lt;String, String&gt; qs = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY));</span><br><span class="line">       String group = qs.get(Constants.GROUP_KEY);</span><br><span class="line">       <span class="keyword">if</span> (group != <span class="keyword">null</span> &amp;&amp; group.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> ((COMMA_SPLIT_PATTERN.split(group)).length &gt; <span class="number">1</span> || <span class="string">"*"</span>.equals(group)) &#123;</span><br><span class="line">               <span class="keyword">return</span> doRefer(getMergeableCluster(), registry, type, url);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> doRefer(cluster, registry, type, url);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="doRefer"><a href="#doRefer" class="headerlink" title="doRefer"></a>doRefer</h2><p>doRefer里面就稍微复杂一些，涉及到比较多的东西，我们先关注主线</p>
<ul>
<li>构建一个RegistryDirectory</li>
<li>构建一个consumer://协议的地址注册到注册中心</li>
<li>订阅zookeeper中节点的变化</li>
<li>调用cluster.join方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doRefer</span><span class="params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//RegistryDirectory初始化</span></span><br><span class="line">        RegistryDirectory&lt;T&gt; directory = <span class="keyword">new</span> RegistryDirectory&lt;T&gt;(type, url);</span><br><span class="line">        directory.setRegistry(registry);</span><br><span class="line">        directory.setProtocol(protocol);</span><br><span class="line">        <span class="comment">// all attributes of REFER_KEY</span></span><br><span class="line">        Map&lt;String, String&gt; parameters = <span class="keyword">new</span> HashMap&lt;String, String&gt;(directory.getUrl().getParameters());</span><br><span class="line">    <span class="comment">//注册consumer://协议的url</span></span><br><span class="line">        URL subscribeUrl = <span class="keyword">new</span> URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), <span class="number">0</span>, type.getName(), parameters);</span><br><span class="line">        <span class="keyword">if</span> (!ANY_VALUE.equals(url.getServiceInterface()) &amp;&amp; url.getParameter(REGISTER_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            directory.setRegisteredConsumerUrl(getRegisteredConsumerUrl(subscribeUrl, url));</span><br><span class="line">            registry.register(directory.getRegisteredConsumerUrl());</span><br><span class="line">        &#125;</span><br><span class="line">        directory.buildRouterChain(subscribeUrl);</span><br><span class="line">    <span class="comment">//订阅事件监听</span></span><br><span class="line">        directory.subscribe(subscribeUrl.addParameter(CATEGORY_KEY,</span><br><span class="line">                PROVIDERS_CATEGORY + <span class="string">","</span> + CONFIGURATORS_CATEGORY + <span class="string">","</span> + ROUTERS_CATEGORY));</span><br><span class="line">	<span class="comment">//构建invoker</span></span><br><span class="line">        Invoker invoker = cluster.join(directory);</span><br><span class="line">        ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);</span><br><span class="line">        <span class="keyword">return</span> invoker;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="Cluster是什么"><a href="#Cluster是什么" class="headerlink" title="Cluster是什么"></a>Cluster是什么</h1><p>我们只关注一下Invoker这个代理类的创建过程,其他的暂且不关心</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoker invoker=cluster.join(directory)</span><br></pre></td></tr></table></figure>

<p>cluster其实是在RegistryProtocol中通过set方法完成依赖注入的，并且，它还是一个被包装的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCluster</span><span class="params">(Cluster cluster)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cluster = cluster;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Cluster扩展点的定义, 由于它是一个自适应扩展点，那么会动态生成一个Cluster$Adaptive的动态代理类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(FailoverCluster.NAME)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cluster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Cluster-Adaptive"><a href="#Cluster-Adaptive" class="headerlink" title="Cluster$Adaptive"></a>Cluster$Adaptive</h2><p>在动态适配的类中会基于extName，选择一个合适的扩展点进行适配，由于默认情况下cluster:failover，所以</p>
<p>getExtension(“failover”)理论上应该返回FailOverCluster。但实际上，这里做了包装</p>
<p>MockClusterWrapper（FailOverCluster）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cluster</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">dubbo</span>.<span class="title">rpc</span>.<span class="title">cluster</span>.<span class="title">Cluster</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.<span class="function">Invoker <span class="title">join</span><span class="params">(org.apache.dubbo.rpc.cluster.Directory arg0)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.cluster.Directory argument == null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg0.getUrl() == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.cluster.Directory argument getUrl() == null"</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class="line">        String extName = url.getParameter(<span class="string">"cluster"</span>, <span class="string">"failover"</span>);</span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.rpc.cluster.Cluster) name from url ("</span> + url.toString() + <span class="string">") use keys([cluster])"</span>);</span><br><span class="line">        org.apache.dubbo.rpc.cluster.Cluster extension = (org.apache.dubbo.rpc.cluster.Cluster)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.cluster.Cluster.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.join(arg0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="cluster-join"><a href="#cluster-join" class="headerlink" title="cluster.join"></a>cluster.join</h2><p>所以再回到doRefer方法，下面这段代码, 实际是调用MockClusterWrapper(FailOverCluster.join)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoker invoker = cluster.join(directory);</span><br></pre></td></tr></table></figure>

<p>所以这里返回的invoker，应该是MockClusterWrapper(FailOverCluster（directory）)</p>
<blockquote>
<p>接着回到ReferenceConfig.createProxy方法中的最后一行</p>
</blockquote>
<h2 id="proxyFactory-getProxy"><a href="#proxyFactory-getProxy" class="headerlink" title="proxyFactory.getProxy"></a>proxyFactory.getProxy</h2><p>拿到invoker之后，会调用获得一个动态代理类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (T) proxyFactory.getProxy(invoker);</span><br></pre></td></tr></table></figure>

<p>而这里的proxyFactory又是一个自适应扩展点，所以会进入下面的方法</p>
<h2 id="JavassistProxyFactory-getProxy"><a href="#JavassistProxyFactory-getProxy" class="headerlink" title="JavassistProxyFactory.getProxy"></a>JavassistProxyFactory.getProxy</h2><p>通过这个方法生成了一个动态代理类，并且对invoker再做了一层处理，InvokerInvocationHandler。意味着后续发起服务调用的时候，会由InvokerInvocationHandler来进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.getProxy(interfaces).newInstance(<span class="keyword">new</span> InvokerInvocationHandler(invoker));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="proxy-getProxy"><a href="#proxy-getProxy" class="headerlink" title="proxy.getProxy"></a>proxy.getProxy</h2><p>在proxy.getProxy这个方法中会生成一个动态代理类，通过debug的形式可以看到动态代理类的原貌</p>
<p>在getProxy这个方法位置加一个断点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy = (Proxy) pc.newInstance();</span><br></pre></td></tr></table></figure>

<p>然后在debug窗口，找到ccp这个变量 -&gt; mMethods。</p>
<p>![1564292685365](F:\教研-课件\vip课程\第三轮\课程研发\Java架构课件\Mic老师\分布式专题\03. 微服务系列之阿里体系\11. Apache Dubbo进阶之服务注册源码分析\1564292685365.png)</p>
<p>调整一下格式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.<span class="function">String <span class="title">sayHello</span><span class="params">(java.lang.String arg0)</span></span>&#123;</span><br><span class="line">  Object[] args = <span class="keyword">new</span> Object[<span class="number">1</span>]; </span><br><span class="line">  args[<span class="number">0</span>] = ($w)$<span class="number">1</span>; </span><br><span class="line">  Object ret = handler.invoke(<span class="keyword">this</span>, methods[<span class="number">0</span>], args); </span><br><span class="line"><span class="keyword">return</span> (java.lang.String)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这个sayHello方法可以看出，我们通过</p>
<p>@Reference注入的一个对象实例本质上就是一个动态代理类，通过调用这个类中的方法，会触发</p>
<p>handler.invoke(), 而这个handler就是InvokerInvocationHandler</p>
<h1 id="网络连接的建立"><a href="#网络连接的建立" class="headerlink" title="网络连接的建立"></a>网络连接的建立</h1><p>前面分析的逻辑中，只讲到了动态代理类的生成，那么目标服务地址信息以及网络通信的建立在哪里实现的呢？我们继续回到RegistryProtocol.refer这个方法中</p>
<p>这里我们暂且关注directory.subscribe这个方法，它是实现服务目标服务订阅的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doRefer</span><span class="params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">        RegistryDirectory&lt;T&gt; directory = <span class="keyword">new</span> RegistryDirectory&lt;T&gt;(type, url);</span><br><span class="line">        directory.setRegistry(registry);</span><br><span class="line">        directory.setProtocol(protocol);</span><br><span class="line">        <span class="comment">// all attributes of REFER_KEY</span></span><br><span class="line">        Map&lt;String, String&gt; parameters = <span class="keyword">new</span> HashMap&lt;String, String&gt;(directory.getUrl().getParameters());</span><br><span class="line">        URL subscribeUrl = <span class="keyword">new</span> URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), <span class="number">0</span>, type.getName(), parameters);</span><br><span class="line">        <span class="keyword">if</span> (!ANY_VALUE.equals(url.getServiceInterface()) &amp;&amp; url.getParameter(REGISTER_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            directory.setRegisteredConsumerUrl(getRegisteredConsumerUrl(subscribeUrl, url));</span><br><span class="line">            registry.register(directory.getRegisteredConsumerUrl());</span><br><span class="line">        &#125;</span><br><span class="line">        directory.buildRouterChain(subscribeUrl);</span><br><span class="line">        directory.subscribe(subscribeUrl.addParameter(CATEGORY_KEY,</span><br><span class="line">                PROVIDERS_CATEGORY + <span class="string">","</span> + CONFIGURATORS_CATEGORY + <span class="string">","</span> + ROUTERS_CATEGORY));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*省略部分代码*/</span></span><br><span class="line">        <span class="keyword">return</span> invoker;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="RegistryDirectory-subscribe"><a href="#RegistryDirectory-subscribe" class="headerlink" title="RegistryDirectory.subscribe"></a>RegistryDirectory.subscribe</h2><p>订阅注册中心指定节点的变化，如果发生变化，则通知到RegistryDirectory。Directory其实和服务的注册以及服务的发现有非常大的关联.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        setConsumerUrl(url); <span class="comment">//设置consumerUrl</span></span><br><span class="line">        <span class="comment">//把当前RegistryDirectory作为listener，去监听zk上节点的变化</span></span><br><span class="line">        consumerConfigurationListener.addNotifyListener(<span class="keyword">this</span>); </span><br><span class="line">        serviceConfigurationListener = <span class="keyword">new</span> ReferenceConfigurationListener(<span class="keyword">this</span>, url);</span><br><span class="line">        registry.subscribe(url, <span class="keyword">this</span>);<span class="comment">//订阅 -&gt; 这里的registry是zookeeperRegsitry</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这里的registry 是ZookeeperRegistry ，会去监听并获取路径下面的节点。监听的路径是： </p>
<p><code>/dubbo/org.apache.dubbo.demo.DemoService/providers 、/dubbo/org.apache.dubbo.demo.DemoService/configurators、/dubbo/org.apache.dubbo.demo.DemoService/routers</code>节点下面的子节点变动</p>
<h2 id="FailbackRegistry-subscribe"><a href="#FailbackRegistry-subscribe" class="headerlink" title="FailbackRegistry.subscribe"></a>FailbackRegistry.subscribe</h2><p>listener为RegistryDirectory，后续要用到</p>
<p>移除失效的listener，调用doSubscribe进行订阅</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(URL url, NotifyListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.subscribe(url, listener);</span><br><span class="line">        removeFailedSubscribed(url, listener);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Sending a subscription request to the server side</span></span><br><span class="line">            doSubscribe(url, listener);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Throwable t = e;</span><br><span class="line"></span><br><span class="line">            List&lt;URL&gt; urls = getCacheUrls(url);</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(urls)) &#123;</span><br><span class="line">                notify(url, listener, urls);</span><br><span class="line">                logger.error(<span class="string">"Failed to subscribe "</span> + url + <span class="string">", Using cached list: "</span> + urls + <span class="string">" from cache file: "</span> + getUrl().getParameter(Constants.FILE_KEY, System.getProperty(<span class="string">"user.home"</span>) + <span class="string">"/dubbo-registry-"</span> + url.getHost() + <span class="string">".cache"</span>) + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// If the startup detection is opened, the Exception is thrown directly.</span></span><br><span class="line">                <span class="keyword">boolean</span> check = getUrl().getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)</span><br><span class="line">                        &amp;&amp; url.getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">boolean</span> skipFailback = t <span class="keyword">instanceof</span> SkipFailbackWrapperException;</span><br><span class="line">                <span class="keyword">if</span> (check || skipFailback) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (skipFailback) &#123;</span><br><span class="line">                        t = t.getCause();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to subscribe "</span> + url + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logger.error(<span class="string">"Failed to subscribe "</span> + url + <span class="string">", waiting for retry, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Record a failed registration request to a failed list, retry regularly</span></span><br><span class="line">            addFailedSubscribed(url, listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ZookeeperRegistry-doSubscribe"><a href="#ZookeeperRegistry-doSubscribe" class="headerlink" title="ZookeeperRegistry.doSubscribe"></a>ZookeeperRegistry.doSubscribe</h2><p>这个方法是订阅，逻辑实现比较多，可以分两段来看，这里的实现把所有Service层发起的订阅以及指定的Service层发起的订阅分开处理。所有Service层类似于监控中心发起的订阅。指定的Service层发起的订阅可以看作是服务消费者的订阅。我们只需要关心指定service层发起的订阅即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSubscribe</span><span class="params">(<span class="keyword">final</span> URL url, <span class="keyword">final</span> NotifyListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (Constants.ANY_VALUE.equals(url.getServiceInterface())) &#123;</span><br><span class="line">                <span class="comment">//省略部分代码</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (String path : toCategoriesPath(url)) &#123;</span><br><span class="line">                    ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners = zkListeners.get(url);</span><br><span class="line">                    <span class="comment">// 如果之前该路径没有添加过listener，则创建一个map来放置listener</span></span><br><span class="line">                    <span class="keyword">if</span> (listeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        zkListeners.putIfAbsent(url, <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">                        listeners = zkListeners.get(url);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ChildListener zkListener = listeners.get(listener);</span><br><span class="line">                    <span class="keyword">if</span> (zkListener == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">// 如果没有添加过对于子节点的listener，则创建,通知服务变化 回调NotifyListener</span></span><br><span class="line">                        listeners.putIfAbsent(listener, (parentPath, currentChilds) -&gt; ZookeeperRegistry.<span class="keyword">this</span>.notify(url, listener, toUrlsWithEmpty(url, parentPath, currentChilds)));</span><br><span class="line">                        </span><br><span class="line">                        zkListener = listeners.get(listener);</span><br><span class="line">                    &#125;</span><br><span class="line">                    zkClient.create(path, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">//添加path节点的当前节点及子节点监听，并且获取子节点信息</span></span><br><span class="line">                    <span class="comment">//也就是dubbo://ip:port/...</span></span><br><span class="line">                    List&lt;String&gt; children = zkClient.addChildListener(path, zkListener);</span><br><span class="line">                    <span class="keyword">if</span> (children != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        urls.addAll(toUrlsWithEmpty(url, path, children));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//调用notify进行通知，对已经可用的列表进行通知</span></span><br><span class="line">                notify(url, listener, urls);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to subscribe "</span> + url + <span class="string">" to zookeeper "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="FailbackRegistry-notify"><a href="#FailbackRegistry-notify" class="headerlink" title="FailbackRegistry.notify"></a>FailbackRegistry.notify</h2><p>调用FailbackRegistry.notify， 对参数进行判断。 然后调用AbstractRegistry.notify方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(URL url, NotifyListener listener, List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"notify url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (listener == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"notify listener == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doNotify(url, listener, urls);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception t) &#123;</span><br><span class="line">            <span class="comment">// Record a failed registration request to a failed list, retry regularly</span></span><br><span class="line">            addFailedNotified(url, listener, urls);</span><br><span class="line">            logger.error(<span class="string">"Failed to notify for subscribe "</span> + url + <span class="string">", waiting for retry, cause: "</span> + t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="AbstractRegistry-notify"><a href="#AbstractRegistry-notify" class="headerlink" title="AbstractRegistry.notify"></a>AbstractRegistry.notify</h2><p>这里面会针对每一个category，调用listener.notify进行通知，然后更新本地的缓存文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(URL url, NotifyListener listener, List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略部分代码</span></span><br><span class="line">        <span class="comment">// keep every provider's category.</span></span><br><span class="line">        Map&lt;String, List&lt;URL&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (URL u : urls) &#123;</span><br><span class="line">            <span class="keyword">if</span> (UrlUtils.isMatch(url, u)) &#123;</span><br><span class="line">                String category = u.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);</span><br><span class="line">                List&lt;URL&gt; categoryList = result.computeIfAbsent(category, k -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">                categoryList.add(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, List&lt;URL&gt;&gt; categoryNotified = notified.computeIfAbsent(url, u -&gt; <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;URL&gt;&gt; entry : result.entrySet()) &#123;</span><br><span class="line">            String category = entry.getKey();</span><br><span class="line">            List&lt;URL&gt; categoryList = entry.getValue();</span><br><span class="line">            categoryNotified.put(category, categoryList);</span><br><span class="line">            listener.notify(categoryList);</span><br><span class="line">            <span class="comment">// We will update our cache file after each notification.</span></span><br><span class="line">            <span class="comment">// When our Registry has a subscribe failure due to network jitter, we can return at least the existing cache URL.</span></span><br><span class="line">            saveProperties(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>消费端的listener是最开始传递过来的RegistryDirectory，所以这里会触发RegistryDirectory.notify</p>
<h2 id="RegistryDirectory-notify"><a href="#RegistryDirectory-notify" class="headerlink" title="RegistryDirectory.notify"></a>RegistryDirectory.notify</h2><p>Invoker的网络连接以及后续的配置变更，都会调用这个notify方法</p>
<p>urls:  zk的path数据，这里表示的是dubbo://</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对url列表进行校验、过滤，然后分成 config、router、provider 3个分组map</span></span><br><span class="line">        Map&lt;String, List&lt;URL&gt;&gt; categoryUrls = urls.stream()</span><br><span class="line">                .filter(Objects::nonNull)</span><br><span class="line">                .filter(<span class="keyword">this</span>::isValidCategory)</span><br><span class="line">                .filter(<span class="keyword">this</span>::isNotCompatibleFor26x)</span><br><span class="line">                .collect(Collectors.groupingBy(url -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (UrlUtils.isConfigurator(url)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> CONFIGURATORS_CATEGORY;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (UrlUtils.isRoute(url)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> ROUTERS_CATEGORY;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (UrlUtils.isProvider(url)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> PROVIDERS_CATEGORY;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">                &#125;));</span><br><span class="line"></span><br><span class="line">        List&lt;URL&gt; configuratorURLs = categoryUrls.getOrDefault(CONFIGURATORS_CATEGORY, Collections.emptyList());</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">this</span>.configurators = Configurator.toConfigurators(configuratorURLs).orElse(<span class="keyword">this</span>.configurators);</span><br><span class="line"><span class="comment">// 如果router 路由节点有变化，则从新将router 下的数据生成router</span></span><br><span class="line">        List&lt;URL&gt; routerURLs = categoryUrls.getOrDefault(ROUTERS_CATEGORY, Collections.emptyList());</span><br><span class="line">        toRouters(routerURLs).ifPresent(<span class="keyword">this</span>::addRouters);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得provider URL，然后调用refreshOverrideAndInvoker进行刷新</span></span><br><span class="line">        List&lt;URL&gt; providerURLs = categoryUrls.getOrDefault(PROVIDERS_CATEGORY, Collections.emptyList());</span><br><span class="line">        refreshOverrideAndInvoker(providerURLs);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="refreshOverrideAndInvoker"><a href="#refreshOverrideAndInvoker" class="headerlink" title="refreshOverrideAndInvoker"></a>refreshOverrideAndInvoker</h2><ul>
<li>逐个调用注册中心里面的配置，覆盖原来的url，组成最新的url 放入overrideDirectoryUrl 存储</li>
<li>根据 provider urls，重新刷新Invoker </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshOverrideAndInvoker</span><span class="params">(List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mock zookeeper://xxx?mock=return null</span></span><br><span class="line">    overrideDirectoryUrl();</span><br><span class="line">    refreshInvoker(urls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="refreshInvoker"><a href="#refreshInvoker" class="headerlink" title="refreshInvoker"></a>refreshInvoker</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshInvoker</span><span class="params">(List&lt;URL&gt; invokerUrls)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(invokerUrls, <span class="string">"invokerUrls should not be null"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (invokerUrls.size() == <span class="number">1</span></span><br><span class="line">                &amp;&amp; invokerUrls.get(<span class="number">0</span>) != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; Constants.EMPTY_PROTOCOL.equals(invokerUrls.get(<span class="number">0</span>).getProtocol())) &#123;</span><br><span class="line">           <span class="comment">//省略部分代码，如果是空协议，则直接返回不允许访问</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.forbidden = <span class="keyword">false</span>; <span class="comment">// Allow to access</span></span><br><span class="line">            </span><br><span class="line">            Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap = <span class="keyword">this</span>.urlInvokerMap; <span class="comment">// local reference</span></span><br><span class="line">            <span class="keyword">if</span> (invokerUrls.isEmpty()) &#123;<span class="comment">//如果url为空，则直接返回</span></span><br><span class="line">                <span class="keyword">return</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据provider url，生成新的invoker</span></span><br><span class="line">            Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = toInvokers(invokerUrls);<span class="comment">// </span></span><br><span class="line">           <span class="comment">//转化为list</span></span><br><span class="line">            List&lt;Invoker&lt;T&gt;&gt; newInvokers = Collections.unmodifiableList(<span class="keyword">new</span> ArrayList&lt;&gt;(newUrlInvokerMap.values()));</span><br><span class="line">            </span><br><span class="line">            routerChain.setInvokers(newInvokers);</span><br><span class="line">            <span class="comment">//如果服务配置了分组，则把分组下的provider包装成StaticDirectory,组成一个invoker</span></span><br><span class="line">            <span class="comment">//实际上就是按照group进行合并</span></span><br><span class="line">            <span class="keyword">this</span>.invokers = multiGroup ? toMergeInvokerList(newInvokers) : newInvokers;</span><br><span class="line">            <span class="keyword">this</span>.urlInvokerMap = newUrlInvokerMap;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//旧的url 是否在新map里面存在，不存在，就是销毁url对应的Invoker</span></span><br><span class="line">                destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap); <span class="comment">// Close the unused Invoker</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.warn(<span class="string">"destroyUnusedInvokers error. "</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="toInvokers"><a href="#toInvokers" class="headerlink" title="toInvokers"></a>toInvokers</h2><p>这个方法中有比较长的判断和处理逻辑，我们只需要关心invoker是什么时候初始化的就行。</p>
<p>这里用到了protocol.refer来构建了一个invoker</p>
<p><code>invoker = new InvokerDelegate&lt;&gt;(protocol.refer(serviceType, url), url, providerUrl);</code></p>
<p>构建完成之后，会保存在<code>Map&lt;String, Invoker&lt;T&gt;&gt; urlInvokerMap</code> 这个集合中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Invoker&lt;T&gt;&gt; toInvokers(List&lt;URL&gt; urls) &#123;</span><br><span class="line">        Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            Map&lt;String, Invoker&lt;T&gt;&gt; localUrlInvokerMap = <span class="keyword">this</span>.urlInvokerMap; <span class="comment">// local reference</span></span><br><span class="line">            Invoker&lt;T&gt; invoker = localUrlInvokerMap == <span class="keyword">null</span> ? <span class="keyword">null</span> : localUrlInvokerMap.get(key);</span><br><span class="line">            <span class="keyword">if</span> (invoker == <span class="keyword">null</span>) &#123; <span class="comment">// Not in the cache, refer again</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> enabled = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (url.hasParameter(Constants.DISABLED_KEY)) &#123;</span><br><span class="line">                        enabled = !url.getParameter(Constants.DISABLED_KEY, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        enabled = url.getParameter(Constants.ENABLED_KEY, <span class="keyword">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">                        invoker = <span class="keyword">new</span> InvokerDelegate&lt;&gt;(protocol.refer(serviceType, url), url, providerUrl);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.error(<span class="string">"Failed to refer invoker for interface:"</span> + serviceType + <span class="string">",url:("</span> + url + <span class="string">")"</span> + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (invoker != <span class="keyword">null</span>) &#123; <span class="comment">// Put new invoker in cache</span></span><br><span class="line">                    newUrlInvokerMap.put(key, invoker);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newUrlInvokerMap.put(key, invoker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        keys.clear();</span><br><span class="line">        <span class="keyword">return</span> newUrlInvokerMap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="protocol-refer-1"><a href="#protocol-refer-1" class="headerlink" title="protocol.refer"></a>protocol.refer</h1><p>调用指定的协议来进行远程引用。protocol是一个Protocol$Adaptive类</p>
<p>而真正的实现应该是： ProtocolListenerWrapper(ProtocolFilterWrapper(QosProtocolWrapper(DubboProtocol.refer)</p>
<p>前面的包装过程，在服务发布的时候已经分析过了，我们直接进入DubboProtocol.refer方法</p>
<h2 id="DubboProtocol-refer"><a href="#DubboProtocol-refer" class="headerlink" title="DubboProtocol.refer"></a>DubboProtocol.refer</h2><ul>
<li>优化序列化</li>
<li>构建DubboInvoker</li>
</ul>
<p>在构建DubboInvoker时，会构建一个ExchangeClient，通过getClients(url)方法，这里基本可以猜到到是服务的通信建立</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; serviceType, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        optimizeSerialization(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create rpc invoker.</span></span><br><span class="line">        DubboInvoker&lt;T&gt; invoker = <span class="keyword">new</span> DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);</span><br><span class="line">        invokers.add(invoker);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invoker;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="getClients"><a href="#getClients" class="headerlink" title="getClients"></a>getClients</h2><p>这里面是获得客户端连接的方法</p>
<ul>
<li>判断是否为共享连接，默认是共享同一个连接进行通信</li>
<li>是否配置了多个连接通道 connections，默认只有一个</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ExchangeClient[] getClients(URL url) &#123;</span><br><span class="line">        <span class="comment">// whether to share connection</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> useShareConnect = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> connections = url.getParameter(Constants.CONNECTIONS_KEY, <span class="number">0</span>);</span><br><span class="line">        List&lt;ReferenceCountExchangeClient&gt; shareClients = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果没有配置连接数，则默认为共享连接</span></span><br><span class="line">        <span class="keyword">if</span> (connections == <span class="number">0</span>) &#123;</span><br><span class="line">            useShareConnect = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * The xml configuration should have a higher priority than properties.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            String shareConnectionsStr = url.getParameter(Constants.SHARE_CONNECTIONS_KEY, (String) <span class="keyword">null</span>);</span><br><span class="line">            connections = Integer.parseInt(StringUtils.isBlank(shareConnectionsStr) ? ConfigUtils.getProperty(Constants.SHARE_CONNECTIONS_KEY,</span><br><span class="line">                    Constants.DEFAULT_SHARE_CONNECTIONS) : shareConnectionsStr);</span><br><span class="line">            shareClients = getSharedClient(url, connections);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ExchangeClient[] clients = <span class="keyword">new</span> ExchangeClient[connections];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clients.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (useShareConnect) &#123;</span><br><span class="line">                clients[i] = shareClients.get(i);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                clients[i] = initClient(url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clients;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="getSharedClient"><a href="#getSharedClient" class="headerlink" title="getSharedClient"></a>getSharedClient</h2><p>获得一个共享连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;ReferenceCountExchangeClient&gt; <span class="title">getSharedClient</span><span class="params">(URL url, <span class="keyword">int</span> connectNum)</span> </span>&#123;</span><br><span class="line">        String key = url.getAddress();</span><br><span class="line">        List&lt;ReferenceCountExchangeClient&gt; clients = referenceClientMap.get(key);</span><br><span class="line">       <span class="comment">//检查当前的key检查连接是否已经创建过并且可用，如果是，则直接返回并且增加连接的个数的统计</span></span><br><span class="line">        <span class="keyword">if</span> (checkClientCanUse(clients)) &#123;</span><br><span class="line">            batchClientRefIncr(clients);</span><br><span class="line">            <span class="keyword">return</span> clients;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//如果连接已经关闭或者连接没有创建过</span></span><br><span class="line">        locks.putIfAbsent(key, <span class="keyword">new</span> Object());</span><br><span class="line">        <span class="keyword">synchronized</span> (locks.get(key)) &#123;</span><br><span class="line">            clients = referenceClientMap.get(key);</span><br><span class="line">            <span class="comment">// 在创建连接之前，在做一次检查，防止连接并发创建</span></span><br><span class="line">            <span class="keyword">if</span> (checkClientCanUse(clients)) &#123;</span><br><span class="line">                batchClientRefIncr(clients);</span><br><span class="line">                <span class="keyword">return</span> clients;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 连接数必须大于等于1</span></span><br><span class="line">            connectNum = Math.max(connectNum, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果当前消费者还没有和服务端产生连接，则初始化</span></span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isEmpty(clients)) &#123;</span><br><span class="line">                clients = buildReferenceCountExchangeClientList(url, connectNum);</span><br><span class="line">                <span class="comment">//创建clients之后，保存到map中</span></span><br><span class="line">                referenceClientMap.put(key, clients);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果clients不为空，则从clients数组中进行遍历</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clients.size(); i++) &#123;</span><br><span class="line">                    ReferenceCountExchangeClient referenceCountExchangeClient = clients.get(i);</span><br><span class="line">                    <span class="comment">// 如果在集合中存在一个连接但是这个连接处于closed状态，则重新构建一个进行替换</span></span><br><span class="line">                    <span class="keyword">if</span> (referenceCountExchangeClient == <span class="keyword">null</span> || referenceCountExchangeClient.isClosed()) &#123;</span><br><span class="line">                        clients.set(i, buildReferenceCountExchangeClient(url));</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//增加个数</span></span><br><span class="line">                    referenceCountExchangeClient.incrementAndGetCount();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * I understand that the purpose of the remove operation here is to avoid the expired url key</span></span><br><span class="line"><span class="comment">             * always occupying this memory space.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            locks.remove(key);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> clients;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="buildReferenceCountExchangeClientList"><a href="#buildReferenceCountExchangeClientList" class="headerlink" title="buildReferenceCountExchangeClientList"></a>buildReferenceCountExchangeClientList</h2><p>根据连接数配置，来构建指定个数的链接。默认为1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;ReferenceCountExchangeClient&gt; <span class="title">buildReferenceCountExchangeClientList</span><span class="params">(URL url, <span class="keyword">int</span> connectNum)</span> </span>&#123;</span><br><span class="line">        List&lt;ReferenceCountExchangeClient&gt; clients = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; connectNum; i++) &#123;</span><br><span class="line">            clients.add(buildReferenceCountExchangeClient(url));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clients;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ReferenceCountExchangeClient <span class="title">buildReferenceCountExchangeClient</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        ExchangeClient exchangeClient = initClient(url);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReferenceCountExchangeClient(exchangeClient);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="initClient"><a href="#initClient" class="headerlink" title="initClient"></a>initClient</h2><p>终于进入到初始化客户端连接的方法了，猜测应该是根据url中配置的参数进行远程通信的构建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ExchangeClient <span class="title">initClient</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得连接类型</span></span><br><span class="line">        String str = url.getParameter(Constants.CLIENT_KEY, url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_CLIENT));</span><br><span class="line">        <span class="comment">//添加默认序列化方恨死</span></span><br><span class="line">        url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);</span><br><span class="line">        <span class="comment">// enable heartbeat by default</span></span><br><span class="line">    <span class="comment">//设置心跳时间</span></span><br><span class="line">        url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断str是否存在于扩展点中，如果不存在则直接报错</span></span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span> &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Unsupported client type: "</span> + str + <span class="string">","</span> +</span><br><span class="line">                    <span class="string">" supported client type is "</span> + StringUtils.join(ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions(), <span class="string">" "</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ExchangeClient client;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 是否需要延迟创建连接，注意哦，这里的requestHandler是一个适配器</span></span><br><span class="line">            <span class="keyword">if</span> (url.getParameter(Constants.LAZY_CONNECT_KEY, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                client = <span class="keyword">new</span> LazyConnectExchangeClient(url, requestHandler);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                client = Exchangers.connect(url, requestHandler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Fail to create remoting client for service("</span> + url + <span class="string">"): "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Exchangers-connect"><a href="#Exchangers-connect" class="headerlink" title="Exchangers.connect"></a>Exchangers.connect</h2><p>创建一个客户端连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExchangeClient <span class="title">connect</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handler == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        url = url.addParameterIfAbsent(Constants.CODEC_KEY, <span class="string">"exchange"</span>);</span><br><span class="line">        <span class="keyword">return</span> getExchanger(url).connect(url, handler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="HeaderExchange-connect"><a href="#HeaderExchange-connect" class="headerlink" title="HeaderExchange.connect"></a>HeaderExchange.connect</h2><p>主要关注transporters.connect</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExchangeClient <span class="title">connect</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeaderExchangeClient(Transporters.connect(url, <span class="keyword">new</span> DecodeHandler(<span class="keyword">new</span> HeaderExchangeHandler(handler))), <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="NettyTransport-connect"><a href="#NettyTransport-connect" class="headerlink" title="NettyTransport.connect"></a>NettyTransport.connect</h2><p>使用netty构建了一个客户端连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Client <span class="title">connect</span><span class="params">(URL url, ChannelHandler listener)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NettyClient(url, listener);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们讲到了<code>RegistryProtocol.refer</code>过程中有一个关键步骤，即在监听到服务提供者url时触发<code>RegistryDirectory.notify()</code>方法。</p>
<p> <code>RegistryDirectory.notify()</code>方法调用<code>refreshInvoker()</code>方法将服务提供者urls转换为对应的<code>远程invoker</code>，最终调用到<code>DubboProtocol.refer()</code>方法生成对应的<code>DubboInvoker</code>。</p>
<p> <code>DubboInvoker</code>的构造方法中有一项入参<code>ExchangeClient[] clients</code>，即对应本文要讲的网络客户端<code>Client</code>。DubboInvoker就是通过调用<code>client.request()</code>方法完成网络通信的请求发送和响应接收功能。</p>
<p> <code>Client</code>的具体生成过程就是通过<code>DubboProtocol</code>的<code>initClient(URL url)</code>方法创建了一个<code>HeaderExchangeClient</code>。</p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#源码分析" >
    <span class="tag-code">源码分析</span>
  </a>

  <a href="/tags#Dubbo" >
    <span class="tag-code">Dubbo</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    <div class="qrcode">
      <canvas id="share-qrcode"></canvas>
      <p class="notice">扫描二维码，分享此文章</p>
    </div>
    <!-- 二维码 END -->
    
      <!-- Gitment START -->
      <div id="comments"></div>
      <!-- Gitment END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">目录</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#ProxyFacotory-getInvoker"><span class="toc-nav-text">ProxyFacotory.getInvoker</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#ProxyFactory"><span class="toc-nav-text">ProxyFactory</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#ProxyFactory-Adaptive"><span class="toc-nav-text">ProxyFactory$Adaptive</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#JavassistProxyFactory-getInvoker"><span class="toc-nav-text">JavassistProxyFactory.getInvoker</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#javassist生成的动态代理代码"><span class="toc-nav-text">javassist生成的动态代理代码</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#服务注册流程"><span class="toc-nav-text">服务注册流程</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#服务注册核心代码"><span class="toc-nav-text">服务注册核心代码</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#getRegistry"><span class="toc-nav-text">getRegistry</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#RegistryFactory-Adaptive"><span class="toc-nav-text">RegistryFactory$Adaptive</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#ZookeeperRegistryFactory"><span class="toc-nav-text">ZookeeperRegistryFactory</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#createRegistry"><span class="toc-nav-text">createRegistry</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#ZookeeperRegistry"><span class="toc-nav-text">ZookeeperRegistry</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#registry-register-registedProviderUrl"><span class="toc-nav-text">registry.register(registedProviderUrl);</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#FailbackRegistry-register"><span class="toc-nav-text">FailbackRegistry.register</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#ZookeeperRegistry-doRegister"><span class="toc-nav-text">ZookeeperRegistry.doRegister</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#思考服务消费应该要具备的逻辑"><span class="toc-nav-text">思考服务消费应该要具备的逻辑</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#服务的消费"><span class="toc-nav-text">服务的消费</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#ReferenceConfig-get"><span class="toc-nav-text">ReferenceConfig.get</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#init"><span class="toc-nav-text">init</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#createProxy"><span class="toc-nav-text">createProxy</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#protocol-refer"><span class="toc-nav-text">protocol.refer</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#RegistryProtocol-refer"><span class="toc-nav-text">RegistryProtocol.refer</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#doRefer"><span class="toc-nav-text">doRefer</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Cluster是什么"><span class="toc-nav-text">Cluster是什么</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Cluster-Adaptive"><span class="toc-nav-text">Cluster$Adaptive</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#cluster-join"><span class="toc-nav-text">cluster.join</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#proxyFactory-getProxy"><span class="toc-nav-text">proxyFactory.getProxy</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#JavassistProxyFactory-getProxy"><span class="toc-nav-text">JavassistProxyFactory.getProxy</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#proxy-getProxy"><span class="toc-nav-text">proxy.getProxy</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#网络连接的建立"><span class="toc-nav-text">网络连接的建立</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#RegistryDirectory-subscribe"><span class="toc-nav-text">RegistryDirectory.subscribe</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#FailbackRegistry-subscribe"><span class="toc-nav-text">FailbackRegistry.subscribe</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#ZookeeperRegistry-doSubscribe"><span class="toc-nav-text">ZookeeperRegistry.doSubscribe</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#FailbackRegistry-notify"><span class="toc-nav-text">FailbackRegistry.notify</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#AbstractRegistry-notify"><span class="toc-nav-text">AbstractRegistry.notify</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#RegistryDirectory-notify"><span class="toc-nav-text">RegistryDirectory.notify</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#refreshOverrideAndInvoker"><span class="toc-nav-text">refreshOverrideAndInvoker</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#refreshInvoker"><span class="toc-nav-text">refreshInvoker</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#toInvokers"><span class="toc-nav-text">toInvokers</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#protocol-refer-1"><span class="toc-nav-text">protocol.refer</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#DubboProtocol-refer"><span class="toc-nav-text">DubboProtocol.refer</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#getClients"><span class="toc-nav-text">getClients</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#getSharedClient"><span class="toc-nav-text">getSharedClient</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#buildReferenceCountExchangeClientList"><span class="toc-nav-text">buildReferenceCountExchangeClientList</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#initClient"><span class="toc-nav-text">initClient</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Exchangers-connect"><span class="toc-nav-text">Exchangers.connect</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#HeaderExchange-connect"><span class="toc-nav-text">HeaderExchange.connect</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#NettyTransport-connect"><span class="toc-nav-text">NettyTransport.connect</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#总结"><span class="toc-nav-text">总结</span></a></li></ol>
    
  </div>
</aside>

  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://istio.tech/2019/07/28/Dubbo源码分析系列之Invoker及服务注册/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "2227324689";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "Dubbo源码分析系列之Invoker及服务注册",
        owner: "2227324689",
        repo: "discus",
        oauth: {
          client_id: "9f7383daf559285bdfbd",
          client_secret: "b459e4b2189adbd2fd9fbc28443cd29fc4b44dbc"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2020 | Proudly powered by <a href="https://www.gupaoedu.cn" target="_blank">GuPaoEdu</a>
    <br>
    Blog by <a href="https://github.com/2227324689">Mic</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine == 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>

  </body>
</html>
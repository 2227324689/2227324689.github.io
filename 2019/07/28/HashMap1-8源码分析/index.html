<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.9.0">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="Java架构师,Java经验分享,架构师成长路线,Java架构技能">
  <meta name="keyword" content="hexo-theme, 咕泡, Mic, Spring Cloud Alibaba">
  
    <link rel="shortcut icon" type="image/ico" href="css/images/favorite.ico"> 
  
  <title>
    
      HashMap1.8源码分析 | 风骚的Mic
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
</head>
<div class="wechat-share">
  <img src="/css/images/logo.png">
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>风骚的Mic</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">主页</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">标签</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">归档</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">项目</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/atom.xml" class="item-link">订阅</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">关于</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">主页</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">标签</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">归档</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">项目</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/atom.xml" class="menu-link">订阅</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">关于</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>HashMap1.8源码分析</h2>
  <p class="post-date">2019-07-28</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p>对于HashMap想必大家都不陌生，无论是平时code还是面试都经常和它打交道。今天我们通过源码的层面来分析一下它的实现原理，注意本文基于的是JDK1.8。</p>
<p>问题是从哪边开始聊起呢？我觉得不妨先从一段熟悉的代码开始。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"Jack"</span>);</span><br></pre></td></tr></table></figure>

<p>然后我们会迫不及待点开HashMap这个类，发现里面有大量的属性和方法，一脸懵逼。那就直接点开put方法？点了之后发现下面这段代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<p>依旧一脸懵逼，完全没有看下去的欲望，怎么办？为什么会这样？原因是我们不了解HashMap的数据结构，什么意思？也就是说，当把key，value存储到HashMap中之后，不知道它们是以何种数据排列的方式去存储的，这样根本就不明白源码写的思路是什么，所以我们先把目光转向到数据结构，更准备地说是HashMap的数据结构。</p>
<h1 id="1-HashMap数据结构"><a href="#1-HashMap数据结构" class="headerlink" title="1 HashMap数据结构"></a>1 HashMap数据结构</h1><p>从网上的很多资料我们知道，HashMap1.7的数据结构是数组+链表，HashMap1.8的数据结构是数组+链表+红黑树，下面这张图我画出了HashMap1.8的数据结构。</p>
<p><img src="/images/image-20190304144017271.png" alt></p>
<p>有些哥们可能会说，我在网上看到的不是这样。这时候你可以发挥空间想象能力逆时针旋转个90度，也就是下面这样的展示形式。</p>
<p><img src="/images/image-20190304144257210.png" alt></p>
<p>不管如何，反正都能体现出是数组+链表+红黑树的数据结构的方式。虽然数据结构是知道了，但是关键是图解中的每个小格子表示的是什么呢？对于我们了解HashMap的原理和源码有什么作用吗？先别急，一个个来看，先看每个小格子表示什么。</p>
<h1 id="2-每个小格子的含义"><a href="#2-每个小格子的含义" class="headerlink" title="2 每个小格子的含义"></a>2 每个小格子的含义</h1><p>我们可以猜想一下，每个小格子表示里面至少包含了key，value，为什么这么说呢？因为hashmap.put(key,value)之后，就会形成上述的数组+链表+红黑树的结构，那这个结构中的每个小格子至少把key和value涵盖进去了，如果不是，那么key,value怎么存储呢？ok，假如这个猜想是对的，那Java中想要同时存储key,value两个值，该怎么表示呢？我觉得可以用XXX类，比如下面的伪代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XXX</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer key;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我觉得靠谱，如果真的是这样，那么要想形成上述的数据结构的图解，只需要创建一个个XXX类的对象，然后排列好它们的方式不就ok了吗？没错，关键这个排列要形式数组+链表+红黑树的数据结构。我们暂且给XXX一个名称叫”Node”，于是就是这样了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer key;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候有些哥们想，上面都是你主观的一个猜想，源码中真的是这样做的吗？我们不妨在HashMap类中搜索一下”Node”，发现有这样一个内部类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ok，至此每个小格子表示的含义猜想和验证已经完成，发现源码中真的也有这样一个Node类，并且里面维护了key和value属性，至于其他属性是什么含义，我们后面再聊。</p>
<h1 id="3-Node的排列方式-数据结构"><a href="#3-Node的排列方式-数据结构" class="headerlink" title="3 Node的排列方式/数据结构"></a>3 Node的排列方式/数据结构</h1><p>上面既然已经验证了小格子对应的就是Node类，或者可以称为是Node节点。接下来我们的任务就是将这些节点来排列成数组+链表+红黑树的形式。</p>
<h2 id="3-1-数组"><a href="#3-1-数组" class="headerlink" title="3.1 数组"></a>3.1 数组</h2><p>想要将Node节点形式数组，按照以往的经验只需要在类中维护一个Node[]的属性即可，那么源码中是否有这样做呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment">    * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment">    * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment">    * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>

<p>我们会发现源码中维护了这样一个成员变量，Node&lt;K,V&gt;[] table，这样数组的排列方式就解决了。</p>
<h2 id="3-2-链表"><a href="#3-2-链表" class="headerlink" title="3.2 链表"></a>3.2 链表</h2><p>链表无非就是Node节点和Node节点的关系的维护，这个关系可以分为单向链表或者双向链表，在前面的图解中我们发现这个链表是单向的，但是如果要想在源码中验证这个单向链表，只需要在原来的Node类中维护一个Node属性，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer key;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="keyword">private</span> Node next;    <span class="comment">//单向链表属性的维护</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那源码中是否是这样做的呢？通过下面代码中的Node&lt;K,V&gt; next属性可以发现的确是单向链表的方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-红黑树"><a href="#3-3-红黑树" class="headerlink" title="3.3 红黑树"></a>3.3 红黑树</h2><p>红黑树是一种特殊的二叉树，对于二叉树我们比较熟悉，会有父节点，左子树，右子树等。</p>
<p>这时候我们会想，源码中是否有这样来做呢？搜索”TreeNode”，发现会有这样一段代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn</span></span><br><span class="line"><span class="comment">     * extends Node) so can be used as extension of either regular or</span></span><br><span class="line"><span class="comment">     * linked node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>跟我们的猜想是一样的，有表示父节点的parent属性，有表示左子树的left属性，还有表示右子树的right属性。</p>
<h2 id="3-4-总结"><a href="#3-4-总结" class="headerlink" title="3.4 总结"></a>3.4 总结</h2><p>通过上面3点源码的分析，可以感受到数组，链表和红黑树的代码，也就是能够验证HashMap1.8的数据结构是数组+链表+红黑树的实现方式。</p>
<h1 id="4-再看HashMap1-8源码"><a href="#4-再看HashMap1-8源码" class="headerlink" title="4 再看HashMap1.8源码"></a>4 再看HashMap1.8源码</h1><p>经过前面的分析，已经能够得到结论HashMap1.8果然是基于数组+链表+红黑树的方式实现的。</p>
<p>这时候再看HashMap1.8源码的实现就会很清晰。</p>
<p>当put(key,value)的时候，肯定先要创建数组，然后基于数组的下标索引创建出链表或者红黑树。这里有一点要注意，上述HashMap的数据结构图解是最终的效果图，但是在没有put任何数据之前，这个数据结构是什么都没有的，也就是一片空白，是需要经过一个个Node节点创建然后形成起来的。</p>
<p>所以先要创建出数组。</p>
<h2 id="4-1-数组的创建"><a href="#4-1-数组的创建" class="headerlink" title="4.1 数组的创建"></a>4.1 数组的创建</h2><p>在putVal方法中开始有这段代码。判断table是否为null，也就是Node[]数组是否为null，如果是，则需要先初始化数组的大小。初始化数组的大小是通过resize()方法，我们定位到resize()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br></pre></td></tr></table></figure>

<ul>
<li>resize()</li>
</ul>
<p>注意下面的代码截取的是resize()方法的间断性部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//再次判断数组是否为null，如果为null，则oldCap赋值为0</span></span><br><span class="line"><span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line"><span class="comment">//此时oldCap的判断会走这段逻辑</span></span><br><span class="line"><span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">    <span class="comment">//将DEFAULT_INITIAL_CAPACITY赋值给变量newCap</span></span><br><span class="line">   	<span class="comment">//DEFAULT_INITIAL_CAPACITY值为16，指的是数组的默认大小，后面会具体说这个大小</span></span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    <span class="comment">//DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY===&gt;16*0.75=12</span></span><br><span class="line">    <span class="comment">//DEFAULT_LOAD_FACTOR值为0.75，得到的结果12是扩容的标准，这个值后面也会说</span></span><br><span class="line">    newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是根据这个默认数组的大小16初始化数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line"><span class="comment">//根据newCap=16初始化数组的大小，并且赋值给table，此时成员变量Node[]数组大小为16</span></span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br></pre></td></tr></table></figure>

<p>到这里，在上述的数据结构图解中，数组的部分就已经形成。但是里面还没有存元素，这个元素的类型前面我们已经分析过，应该是Node节点，换句话说也就是有key,value等这些组成的Node的对象。</p>
<h2 id="4-2-put之前Node节点位置的确定"><a href="#4-2-put之前Node节点位置的确定" class="headerlink" title="4.2 put之前Node节点位置的确定"></a>4.2 put之前Node节点位置的确定</h2><p>Node节点要想存储到上面初始化好的数组中，关键是到底存到哪个位置呢？上述数组初始化的大小为16，也就是Node节点到底是落在0-15索引的哪个位置。有哥们可能会想要不就从下标0开始存储？虽然是可行，但是问题是什么时候存储到1的位置呢？什么时候存储到2的位置呢？似乎这个界限不明确，还是放弃这样的想法。那怎么确定？要不这样，使用Random对象随机出一个0-15之间的数值？好像可以，如果是这样，万一不小心随机的数值一直是1和2，那最终可能只有1和2位置以及下面有Node节点，其他位置没有得到充分的利用，如下图所示。</p>
<p>这时候，1和2所在位置索引下面的节点就会很多。一方面看起来不美观其他位置没有得到充分的利用，另外一方面每次想要查询尾端的节点的值时，要经历过的过程必须知道前一个节点是什么，此时时间和空间复杂度比较高，所以Random这种产生Node节点位置的方式不合理。</p>
<p><img src="/images/image-20190304181624047.png" alt></p>
<ul>
<li>得到Node节点在数组中的位置</li>
</ul>
<p>经过上述尝试后，不妨这样，具体的位置由Node节点中的key本身来决定，也就是根据key来得到这个落点值。</p>
<p>我们可以将这个过程分为两步，第一：根据key得到一个整型数；第二：控制这个整形数在0-15之间。</p>
<p>（1）根据key得到整型数hash</p>
<p>key.hashCode():因为在Object类中有一个hashCode()方法，是一个native的方法，可以得到一个int类型的整型数，正好符合我们的想法。</p>
<p>我们暂且用一个int hash=key.hashCode()记录这个整型数的值，后面会调整。</p>
<p>（2）控制整型数hash的范围在0-15之间</p>
<p>int index=hash%16，此时index的结果就是0-15之间，后面这块也会调整。</p>
<p>至少目前为止这个落点我们能够计算出来了，虽然后面还会优化这块内容，但是思路是没错的。</p>
<ul>
<li>优化控制整型数hash的范围</li>
</ul>
<p>原来我们是通过hash%16这种方式，但是效率不够高，不妨一起来看下源码中是怎么做的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>可以发现，源码中是通过hash%(n-1)这种方式，而不是hash%n，注意这里的n是数组的大小，比如默认大小16。</p>
<p>先不管这样做的优势如何，也就是也得到0-15的数值，我们就将这个&amp;计算通过二进制来折腾一下。</p>
<p>hash:                     010100101010101010101010101                 32位</p>
<p>n-1:                                                                        01111                 15的二进制表示</p>
<hr>
<p>​                                        index</p>
<p>这个index最终结果最小值为00000，最大值为01111，换算成10进制，也就是0-15，即和hash%n的结果是一样的。那为什么作者使用的是&amp;运算而不是%运算呢？很简单，&amp;这样的效率更高，速度更快，这也是面试中很重要的一个点，大家一定要注意。</p>
<ul>
<li>优化hash值的计算方式</li>
</ul>
<p>原来hash的计算方式直接是key.hashCode()，得出的结果直接和n-1进行&amp;运算，得到index之后，就可以确定Node节点的位置了，但是这样真的好吗？其实index的结果真正取决于hash值，因为n-1是01111。</p>
<p>所以hash的值，或者说是hash二进制表示最后的几位决定了index的值，我们希望的是index的值尽可能不一样，这样数组每个索引位置能尽肯能得到充分的利用，雨露均沾嘛，不然index值重复的可能性太高的话，就会形成像原来Random设想的那种方案，一方面不美观，一方面影响时间和空间复杂度。</p>
<p>那么hash值的最后几位能否尽可能不一样呢？或者说源码中对hash的计算方式和我们原来认为的key.hashCode()是否一样呢？不妨一起来看下put方法调用的时候，有一个hash(key)函数，点开该方法代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们会发现，它采用的是使用key.hashCode()的高16位和低16位异或的方式</p>
<p>0101010101001100100101010010101010原本是这样</p>
<p>01010101010011001</p>
<p>00101010010101010        ^</p>
<hr>
<p>​                           hash       这个hash结果采用的是key.hashCode()高低16位进行异或运算后的结果</p>
<p>也就是说这里让key.hashCode()的高16位和低16位都参与了运算，得到的hash值最后几位重复的可能性会大大降低，也就是hash(key)算法的设计。所以平时面试中问HashMap中hash算法的设计是怎样的，就是上面的这个过程。</p>
<p>同时到这里也解决了源码中Node类里面为什么有一个int hash的属性，其实这个属性就是保存的hash算法计算的结果值，这个值确定了，Node节点落点的位置就确定了，也就是按照面向对象的思想，Node节点最终落到哪个数组的位置它自己得知道。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;     <span class="comment">//保存hash函数最终计算的hash值</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-数组大小为什么是2的N次幂"><a href="#4-3-数组大小为什么是2的N次幂" class="headerlink" title="4.3 数组大小为什么是2的N次幂"></a>4.3 数组大小为什么是2的N次幂</h2><p>这时候我们先不着急看put下面的代码，不妨来看一下对于数组默认大小属性的定义。</p>
<p>不难发现，这个DEFAULT_INITIAL_CAPACITY采用的是位移运算，也就是1向左位移4位，也就是1后面加上4个0，也就是10000，换算成10进制，就是2的4次方，即16。</p>
<p>有哥们可能会想为什么采用位移运算？因为速度快。对于DEFAULT_INITIAL_CAPACITY上面有注释，意思是必须是2的N次幂，也就是数组的大小必须是2的N次幂。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure>

<p>这时候来想想为什么呢？不妨再回到计算Node落点的(n-1)&amp;hash。</p>
<p>hash:                     010100101010101010101010101                 32位</p>
<p>n-1:                                                                        01111                 15的二进制表示</p>
<hr>
<p>​                                        index</p>
<p>我们上面说过，index的值尽可能的不要重复，不然最终Node节点都集中在一两个索引位置之下了。为了尽可能不重复，hash算法进行了高低16位的异或计算。n-1的值是01111所以index的结果实际上取决于hash的值，试想一下如果n-1不是01111，如果是01110会怎样？这时候hash的二进制结果最后一位无论是1还是0，index重复的可能性就会增加，所以必须保证n-1的结果是01111，换句话说必须保证n是10000这样的形式，也就是n[数组的大小]必须是2的N次幂。</p>
<ul>
<li>如果在初始化HashMap的时候传入的大小不是2的N次幂呢？</li>
</ul>
<p>总有人会不按照规则出牌，这时候就需要看HashMap的构造函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">    initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">    initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">    loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">//最终会调用tableSizeFor调整数组的大小</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继而来看tableSizeFor(initialCapacity)到底做了什么，我们会发现，这个方法会根据传入的cap得到一个2的N次幂的值作为数组的大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-4-继续源码的put过程"><a href="#4-4-继续源码的put过程" class="headerlink" title="4.4 继续源码的put过程"></a>4.4 继续源码的put过程</h2><p>上面已经对数组进行了初始化，也得到了每个Node节点应该在的位置。</p>
<p>这时候比如真的来一个key和value，得到该Node节点应该在的位置，接下来的流程该是如何呢？肯定要判断原来数组该索引位置中是否有Node节点。若没有，则直接将该节点放到该位置；若有，有的话就再看咯。</p>
<p>我们先来看没有的时候，源码是怎么做的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">//直接根据hash,key,value创建出一个Node节点放到数组下标对应的位置</span></span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>如果有的话，则不能直接放到该位置，如下图所示</p>
<p><img src="/images/image-20190304191149132.png" alt></p>
<p>这个时候可以分为三种情况：</p>
<p>如果key值相同，只需要将原来下标位置的value值替换掉即可；</p>
<p>如果key值不同，则将新的节点放到原来索引节点的后面形成单向链表；</p>
<p>如果key值不同，原来索引下面已经是红黑树的数据结构了，则按照红黑树的数据结构将新的节点存储。</p>
<h3 id="4-4-1-仅仅替换value值"><a href="#4-4-1-仅仅替换value值" class="headerlink" title="4.4.1 仅仅替换value值"></a>4.4.1 仅仅替换value值</h3><p><img src="/images/image-20190304191626023.png" alt></p>
<p><code>代码实现</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; e; K k;</span><br><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">    			<span class="comment">//使用一个临时变量e节点记录一下</span></span><br><span class="line">                e = p;</span><br></pre></td></tr></table></figure>

<p>如果最终e的值不为空，则使用新value替换老的value</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-2-按照红黑树方式存储Node"><a href="#4-4-2-按照红黑树方式存储Node" class="headerlink" title="4.4.2 按照红黑树方式存储Node"></a>4.4.2 按照红黑树方式存储Node</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">    e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br></pre></td></tr></table></figure>

<h3 id="4-4-3-按链表方式存储Node"><a href="#4-4-3-按链表方式存储Node" class="headerlink" title="4.4.3 按链表方式存储Node"></a>4.4.3 按链表方式存储Node</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//循环遍历原来索引下链表，有可能原来已经是链表的数据结构了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//要把新的节点放到链表的最末尾的节点才行</span></span><br><span class="line">            <span class="comment">//所以这边要一直循环遍历到链表节点的next为null，说明已经到了末尾了</span></span><br><span class="line">            p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//如果链表的长度超过某个值，就将链表转红黑树，这块后面会说</span></span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在链表put的过程中同样也是判断key值是否相同</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        p = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5-链表转红黑树"><a href="#4-5-链表转红黑树" class="headerlink" title="4.5 链表转红黑树"></a>4.5 链表转红黑树</h2><p>通过上述代码可以发现在链表put的过程中，如果链表太长会将其转成红黑树。我们先想想为什么要转？之前说如果index的结果一样，key值不同，会慢慢往Node节点往下延长形成链表的数据结构，但是对于链表而言，长度太长的话，存取效率会低，因为链表要想找到某个节点必须要知道它的上一个节点。</p>
<p>但是即使采用了hash算法，保证了数组的大小是2的N次幂，还是避免不了链表长度慢慢变长，这时候查询或者插入效率降低，怎么办呢？不妨这样将链表的结构变形成树形结构，如下图所示。</p>
<p><img src="/images/image-20190304192953352.png" alt></p>
<p>那转换的条件是什么呢？也就是链表到底多长才需要转呢？在源码中是怎样定义的？</p>
<p>也就是说链表节点长度超过8就需要转红黑树，如果红黑树中节点数目小于6就再转成链表。</p>
<p>而且之前在链表节点不断增加时候代码也是这样判断的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果链表的长度超过某个值，就将链表转红黑树，这块后面会说</span></span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                treeifyBin(tab, hash);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment"> * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment"> * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment"> * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment"> * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment"> * shrinkage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment"> * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment"> * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment"> * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment"> * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment"> * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="4-6-数组扩容的探讨"><a href="#4-6-数组扩容的探讨" class="headerlink" title="4.6 数组扩容的探讨"></a>4.6 数组扩容的探讨</h2><p>到这边想必大家都有点累了，此时把自己的脑袋给放空，只回想一个图，就是一开始HashMap的数据结构图，一张由数组+链表+红黑树的图。通过上述的分析，我们发现数组的索引位置会被Node节点占用，而且index相同的情况下还会形成链表或者红黑树的结构。试想有没有这样一种情况，就是数组的索引位置不够用了，或者说虽然可以不断往下形成链表或者红黑树，但是数组的大小难道就一直保持在16不变吗？比如Node节点已经像下面这样的分布了呢？</p>
<p>大家应该能明白我想表达的意思，这时候你会发现数据结构比较复杂，也不利于我们的存取节点了。所以得要指定一个标准，比如整个数据结构中节点的数量超过某个值之后就把数组的大小扩大一下，这样可以有效减轻节点的一个分布压力。就像是链表太长要转红黑树一样。那这个数组扩大的临界值怎么确定呢？</p>
<p><img src="/images/image-20190304193928061.png" alt></p>
<h3 id="4-6-1-扩容-加载因子"><a href="#4-6-1-扩容-加载因子" class="headerlink" title="4.6.1 扩容/加载因子"></a>4.6.1 扩容/加载因子</h3><p>在成员变量中有一个这样的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-2-扩容标准"><a href="#4-6-2-扩容标准" class="headerlink" title="4.6.2 扩容标准"></a>4.6.2 扩容标准</h3><p>这个临界值的确定可以用数组大小*扩容因子，其实在数组初始化方法resize中我们见过这个公式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br></pre></td></tr></table></figure>

<p>这个newThr=16*0.75=12就是扩容的标准，在resize()方法中最终将这个赋值给了一个成员变量，赋值的过程如下所示，也就是说这个threshold等于12。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threshold = newThr;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-3-扩容过程"><a href="#4-6-3-扩容过程" class="headerlink" title="4.6.3 扩容过程"></a>4.6.3 扩容过程</h3><p>每当put一个Node节点成功，最后会有这段代码的判断。</p>
<p>也就是说会通过一个成员变量size，默认值为0，记录每次put的次数，如果这个++size&gt;threshold[12]，之后就进行resize()操作，也就是进行扩容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">           resize();</span><br></pre></td></tr></table></figure>

<ul>
<li>数组的2倍扩容</li>
</ul>
<p>到这里，我们能够知道resize()除了有初始化数组的功能，还会有扩容的功能，而且这个扩容会2倍扩容，原因是要保证数组的大小必须是2的N次幂，原因前面已经说过咯。</p>
<p>判断数组的大小，此时数组大小是16。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br></pre></td></tr></table></figure>

<p>此时oldCap的大小则大于0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过向左位移1位将数组的大小*2</span></span><br><span class="line">    <span class="comment">//同时扩容的标准12也需要变成24，也就是oldThr&lt;&lt;1</span></span><br><span class="line">    <span class="comment">//这里采用位移也是因为效率高</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">        newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当新数组的大小变成32之后，就将新数组的大小创建成功。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br></pre></td></tr></table></figure>

<p>此时会面临一个问题，新创建数组中没有任何Node节点，我们需要将原来数组中的Node节点”搬运“到新的数组中，那怎么搬运呢？</p>
<ul>
<li>老数组中Node节点搬运到新数组中</li>
</ul>
<p>搬运要按照节点的类型来区分，我们可以采取这样的方式，先循环遍历原来数组的索引位置，要确保原来数组下表位置不为空才有必要进行搬运。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候可以分为3种情况。</p>
<p>（1）数组索引下标下面没有元素</p>
<p>这时候只需要使用hash值重新&amp;上新数组n-1的值，计算节点在新数组中的位置即可。</p>
<p><img src="/images/image-20190304213315800.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br></pre></td></tr></table></figure>

<p>（2）数组索引下标下面有元素，且元素类型为红黑树</p>
<p>如果索引下面的节点类型是红黑树，则按照红黑树的方式将Node节点切分，然后移动到新的数组中。</p>
<p><img src="/images/image-20190304213236203.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br></pre></td></tr></table></figure>

<p>（3）数组索引下标下面有所愿，且元素类型为链表</p>
<p><img src="/images/image-20190304213353962.png" alt></p>
<p>这种情况表示原数组索引下面的节点类型为链表，此时要循环遍历链表，使用的是do-while循环。</p>
<p>下面这段代码最重要的其实是这句话</p>
<p><code>if ((e.hash &amp; oldCap) == 0)</code>，也就是这块会计算链表中每个节点的hash&amp;oldCap的值，最终结果和0比较，根据结果进行不同的处理，那么这种结果什么时候为0，什么时候不为0呢?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        next = e.next;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">        newTab[j] = loHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">        newTab[j + oldCap] = hiHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们把if ((e.hash &amp; oldCap) == 0)这个计算公式写出来</p>
<p>hash:                 010010101001100101010101101010</p>
<p>oldCap:                                                                    10000     &amp;</p>
<hr>
<p>​                                                                                 result</p>
<p>上述result到底何时才为0？细心的哥们会发现只有hash的倒数第5位位0的时候，结果才会0，否则结果不为0，而且为0的时候result和不为0的result相差是10000，也就是16，也就是oldCap的大小。</p>
<p>本来要移动老数组中链表的Node节点要重新计算hash&amp;(n-1)的值，但是此时只要知道hash的倒数第5位是否为0，就能知道本来应该计算的结果。</p>
<p>如果hash二进制表示倒数第5位为0，即使采用hash&amp;(n-1)的结果还是和原来index一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">        loHead = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        loTail.next = e;</span><br><span class="line">    loTail = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果hash二进制表示倒数第5位为1，那么采用hash&amp;(n-1)的结果就会比原来index大oldCap的大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">        hiHead = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        hiTail.next = e;</span><br><span class="line">    hiTail = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实上述两段代码形成的最终结果是，也就是节点在新的数组中的位置要么是在原来位置，要么是在原来位置+oldCap的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">    loTail.next = <span class="keyword">null</span>;</span><br><span class="line">    newTab[j] = loHead;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">    hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">    newTab[j + oldCap] = hiHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><p>通过本文分析，我们了解了HashMap1.8的数据结构以及源码原理源码实现，包括hash算法，put过程，加载因子，扩容等，希望对大家有所帮助。如若有不对之处，欢迎大家一起探讨交流，谢谢。</p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#源码分析" >
    <span class="tag-code">源码分析</span>
  </a>

  <a href="/tags#HashMap" >
    <span class="tag-code">HashMap</span>
  </a>

  <a href="/tags#红黑树" >
    <span class="tag-code">红黑树</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    <div class="qrcode">
      <canvas id="share-qrcode"></canvas>
      <p class="notice">扫描二维码，分享此文章</p>
    </div>
    <!-- 二维码 END -->
    
      <!-- Gitment START -->
      <div id="comments"></div>
      <!-- Gitment END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">目录</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#1-HashMap数据结构"><span class="toc-nav-text">1 HashMap数据结构</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#2-每个小格子的含义"><span class="toc-nav-text">2 每个小格子的含义</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#3-Node的排列方式-数据结构"><span class="toc-nav-text">3 Node的排列方式/数据结构</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-1-数组"><span class="toc-nav-text">3.1 数组</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-2-链表"><span class="toc-nav-text">3.2 链表</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-3-红黑树"><span class="toc-nav-text">3.3 红黑树</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-4-总结"><span class="toc-nav-text">3.4 总结</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#4-再看HashMap1-8源码"><span class="toc-nav-text">4 再看HashMap1.8源码</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-1-数组的创建"><span class="toc-nav-text">4.1 数组的创建</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-2-put之前Node节点位置的确定"><span class="toc-nav-text">4.2 put之前Node节点位置的确定</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-3-数组大小为什么是2的N次幂"><span class="toc-nav-text">4.3 数组大小为什么是2的N次幂</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-4-继续源码的put过程"><span class="toc-nav-text">4.4 继续源码的put过程</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-4-1-仅仅替换value值"><span class="toc-nav-text">4.4.1 仅仅替换value值</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-4-2-按照红黑树方式存储Node"><span class="toc-nav-text">4.4.2 按照红黑树方式存储Node</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-4-3-按链表方式存储Node"><span class="toc-nav-text">4.4.3 按链表方式存储Node</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-5-链表转红黑树"><span class="toc-nav-text">4.5 链表转红黑树</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-6-数组扩容的探讨"><span class="toc-nav-text">4.6 数组扩容的探讨</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-6-1-扩容-加载因子"><span class="toc-nav-text">4.6.1 扩容/加载因子</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-6-2-扩容标准"><span class="toc-nav-text">4.6.2 扩容标准</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-6-3-扩容过程"><span class="toc-nav-text">4.6.3 扩容过程</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#5-总结"><span class="toc-nav-text">5 总结</span></a></li></ol>
    
  </div>
</aside>

  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://istio.tech/2019/07/28/HashMap1-8源码分析/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "2227324689";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "HashMap1.8源码分析",
        owner: "2227324689",
        repo: "discus",
        oauth: {
          client_id: "9f7383daf559285bdfbd",
          client_secret: "b459e4b2189adbd2fd9fbc28443cd29fc4b44dbc"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2020 | Proudly powered by <a href="https://www.gupaoedu.cn" target="_blank">GuPaoEdu</a>
    <br>
    Blog by <a href="https://github.com/2227324689">Mic</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine == 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>

  </body>
</html>
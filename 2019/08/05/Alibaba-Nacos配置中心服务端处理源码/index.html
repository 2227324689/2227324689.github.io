<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.9.0">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="Java架构师,Java经验分享,架构师成长路线,Java架构技能">
  <meta name="keyword" content="hexo-theme, 咕泡, Mic, Spring Cloud Alibaba">
  
    <link rel="shortcut icon" type="image/ico" href="css/images/favorite.ico"> 
  
  <title>
    
      Alibaba Nacos配置中心服务端处理源码 | 风骚的Mic
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
</head>
<div class="wechat-share">
  <img src="/css/images/logo.png">
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>风骚的Mic</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">主页</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">标签</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">归档</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">项目</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/atom.xml" class="item-link">订阅</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">关于</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">主页</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">标签</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">归档</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">项目</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/atom.xml" class="menu-link">订阅</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">关于</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>Alibaba Nacos配置中心服务端处理源码</h2>
  <p class="post-date">2019-08-05</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p>服务端收到客户端的配置变更请求查询的长轮训请求之后，服务端怎么来处理这个长轮训呢？</p>
<p>上文中讲到了配置更新的整个原理及源码，我们知道客户端会有一个长轮训的任务去检查服务器端的配置是否发生了变化，如果发生了变更，那么客户端会拿到变更的 groupKey 再根据 groupKey 去获取配置项的最新值更新到本地的缓存以及文件中，那么这种每次都靠客户端去请求，那请求的时间间隔设置多少合适呢？</p>
<p>如果间隔时间设置的太长的话有可能无法及时获取服务端的变更，如果间隔时间设置的太短的话，那么频繁的请求对于服务端来说无疑也是一种负担，所以最好的方式是客户端每隔一段长度适中的时间去服务端请求，而在这期间如果配置发生变更，服务端能够主动将变更后的结果推送给客户端，这样既能保证客户端能够实时感知到配置的变化，也降低了服务端的压力。 我们来看看nacos设置的间隔时间是多久</p>
<a id="more"></a>

<h2 id="长轮训的概念"><a href="#长轮训的概念" class="headerlink" title="长轮训的概念"></a>长轮训的概念</h2><p>那么在讲解原理之前，先给大家解释一下什么叫长轮训</p>
<p>客户端发起一个请求到服务端，服务端收到客户端的请求后，并不会立刻响应给客户端，而是先把这个请求hold住，然后服务端会在hold住的这段时间检查数据是否有更新，如果有，则响应给客户端，如果一直没有数据变更，则达到一定的时间（长轮训时间间隔）才返回。</p>
<p>长轮训典型的场景有： 扫码登录、扫码支付。</p>
<p><img src="/images/1564895144314.png" alt="1564895144314"></p>
<h2 id="客户端长轮训"><a href="#客户端长轮训" class="headerlink" title="客户端长轮训"></a>客户端长轮训</h2><p>回到我们昨天上课讲到的代码,在ClientWorker这个类里面，找到<code>checkUpdateConfigStr</code>这个方法，这里面就是去服务器端查询发生变化的groupKey。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;String&gt; <span class="title">checkUpdateConfigStr</span><span class="params">(String probeUpdateString, <span class="keyword">boolean</span> isInitializingCacheList)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; params = Arrays.asList(Constants.PROBE_MODIFY_REQUEST, probeUpdateString);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; headers = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">2</span>);</span><br><span class="line">        headers.add(<span class="string">"Long-Pulling-Timeout"</span>);</span><br><span class="line">        headers.add(<span class="string">""</span> + timeout);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// told server do not hang me up if new initializing cacheData added in</span></span><br><span class="line">        <span class="keyword">if</span> (isInitializingCacheList) &#123;</span><br><span class="line">            headers.add(<span class="string">"Long-Pulling-Timeout-No-Hangup"</span>);</span><br><span class="line">            headers.add(<span class="string">"true"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(probeUpdateString)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HttpResult result = agent.httpPost(Constants.CONFIG_CONTROLLER_PATH + <span class="string">"/listener"</span>, headers, params,</span><br><span class="line">                agent.getEncode(), timeout);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (HttpURLConnection.HTTP_OK == result.code) &#123;</span><br><span class="line">                setHealthServer(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> parseUpdateDataIdResponse(result.content);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                setHealthServer(<span class="keyword">false</span>);</span><br><span class="line">                LOGGER.error(<span class="string">"[&#123;&#125;] [check-update] get changed dataId error, code: &#123;&#125;"</span>, agent.getName(), result.code);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            setHealthServer(<span class="keyword">false</span>);</span><br><span class="line">            LOGGER.error(<span class="string">"["</span> + agent.getName() + <span class="string">"] [check-update] get changed dataId exception"</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法最终会发起http请求，注意这里面有一个<code>timeout</code>的属性，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpResult result = agent.httpPost(Constants.CONFIG_CONTROLLER_PATH + <span class="string">"/listener"</span>, headers, params,</span><br><span class="line">                agent.getEncode(), timeout);</span><br></pre></td></tr></table></figure>

<p>timeout是在init这个方法中赋值的，默认情况下是30秒，可以通过configLongPollTimeout进行修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.timeout = (<span class="keyword">long</span>)Math.max(NumberUtils.toInt(properties.getProperty(<span class="string">"configLongPollTimeout"</span>), <span class="number">30000</span>), <span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">this</span>.taskPenaltyTime = NumberUtils.toInt(properties.getProperty(<span class="string">"configRetryTime"</span>), <span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">this</span>.enableRemoteSyncConfig = Boolean.parseBoolean(properties.getProperty(<span class="string">"enableRemoteSyncConfig"</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>所以从这里得出的一个基本结论是</p>
<blockquote>
<p>客户端发起一个轮询请求，超时时间是30s。 那么客户端为什么要等待30s才超时呢？不是越快越好吗？</p>
</blockquote>
<h2 id="客户端长轮训的时间间隔"><a href="#客户端长轮训的时间间隔" class="headerlink" title="客户端长轮训的时间间隔"></a>客户端长轮训的时间间隔</h2><p>我们可以在nacos的日志目录下<code>$NACOS_HOME/nacos/logs/config-client-request.log</code>文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2019-08-04 13:22:19,736|0|nohangup|127.0.0.1|polling|1|55|0</span><br><span class="line">2019-08-04 13:22:49,443|29504|timeout|127.0.0.1|polling|1|55</span><br><span class="line">2019-08-04 13:23:18,983|29535|timeout|127.0.0.1|polling|1|55</span><br><span class="line">2019-08-04 13:23:48,493|29501|timeout|127.0.0.1|polling|1|55</span><br><span class="line">2019-08-04 13:24:18,003|29500|timeout|127.0.0.1|polling|1|55</span><br><span class="line">2019-08-04 13:24:47,509|29501|timeout|127.0.0.1|polling|1|55</span><br></pre></td></tr></table></figure>

<p>可以看到一个现象，在配置没有发生变化的情况下，客户端会等29.5s以上，才请求到服务器端的结果。然后客户端拿到服务器端的结果之后，在做后续的操作。</p>
<p>如果在配置变更的情况下，由于客户端基于长轮训的连接保持，所以返回的时间会非常的短，我们可以做个小实验，在nacos console中频繁修改数据然后再观察一下</p>
<p><code>config-client-request.log</code>的变化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2019-08-04 13:30:17,016|0|in-advance|127.0.0.1|polling|1|55|example+DEFAULT_GROUP</span><br><span class="line">2019-08-04 13:30:17,022|3|null|127.0.0.1|get|example|DEFAULT_GROUP||e10e4d5973c497e490a8d7a9e4e9be64|unknown</span><br><span class="line">2019-08-04 13:30:20,807|10|true|0:0:0:0:0:0:0:1|publish|example|DEFAULT_GROUP||81360b7e732a5dbb37d62d81cebb85d2|null</span><br><span class="line">2019-08-04 13:30:20,843|0|in-advance|127.0.0.1|polling|1|55|example+DEFAULT_GROUP</span><br><span class="line">2019-08-04 13:30:20,848|1|null|127.0.0.1|get|example|DEFAULT_GROUP||81360b7e732a5dbb37d62d81cebb85d2|unknown</span><br></pre></td></tr></table></figure>

<p><img src="/images/1564896925676.png" alt="1564896925676"></p>
<h1 id="服务端的处理"><a href="#服务端的处理" class="headerlink" title="服务端的处理"></a>服务端的处理</h1><p>分析完客户端之后，随着好奇心的驱使，服务端是如何处理客户端的请求的？那么同样，我们需要思考几个问题</p>
<ul>
<li>客户端的长轮训响应时间受到哪些因素的影响</li>
<li>客户端的超时时间为什么要设置30s</li>
</ul>
<p>客户端发送的请求地址是:<code>/v1/cs/configs/listener</code> 找到服务端对应的方法</p>
<h2 id="ConfigController"><a href="#ConfigController" class="headerlink" title="ConfigController"></a>ConfigController</h2><p>nacos是使用spring mvc提供的rest api。这里面会调用inner.doPollingConfig进行处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/listener"</span>, method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listener</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        request.setAttribute(<span class="string">"org.apache.catalina.ASYNC_SUPPORTED"</span>, <span class="keyword">true</span>);</span><br><span class="line">        String probeModify = request.getParameter(<span class="string">"Listening-Configs"</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(probeModify)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"invalid probeModify"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        probeModify = URLDecoder.decode(probeModify, Constants.ENCODE);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; clientMd5Map;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clientMd5Map = MD5Util.getClientMd5Map(probeModify);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"invalid probeModify"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// do long-polling</span></span><br><span class="line">        inner.doPollingConfig(request, response, clientMd5Map, probeModify.length());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="doPollingConfig"><a href="#doPollingConfig" class="headerlink" title="doPollingConfig"></a>doPollingConfig</h2><p>这个方法中，兼容了长轮训和短轮询的逻辑，我们只需要关注长轮训的部分。再次进入到<code>longPollingService.addLongPollingClient</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">doPollingConfig</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Map&lt;String, String&gt; clientMd5Map, <span class="keyword">int</span> probeRequestSize)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 长轮询</span></span><br><span class="line">        <span class="keyword">if</span> (LongPollingService.isSupportLongPolling(request)) &#123;</span><br><span class="line">            longPollingService.addLongPollingClient(request, response, clientMd5Map, probeRequestSize);</span><br><span class="line">            <span class="keyword">return</span> HttpServletResponse.SC_OK + <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// else 兼容短轮询逻辑</span></span><br><span class="line">        List&lt;String&gt; changedGroups = MD5Util.compareMd5(request, response, clientMd5Map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 兼容短轮询result</span></span><br><span class="line">        String oldResult = MD5Util.compareMd5OldResult(changedGroups);</span><br><span class="line">        String newResult = MD5Util.compareMd5ResultString(changedGroups);</span><br><span class="line"></span><br><span class="line">        String version = request.getHeader(Constants.CLIENT_VERSION_HEADER);</span><br><span class="line">        <span class="keyword">if</span> (version == <span class="keyword">null</span>) &#123;</span><br><span class="line">            version = <span class="string">"2.0.0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> versionNum = Protocol.getVersionNumber(version);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 2.0.4版本以前, 返回值放入header中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (versionNum &lt; START_LONGPOLLING_VERSION_NUM) &#123;</span><br><span class="line">            response.addHeader(Constants.PROBE_MODIFY_RESPONSE, oldResult);</span><br><span class="line">            response.addHeader(Constants.PROBE_MODIFY_RESPONSE_NEW, newResult);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            request.setAttribute(<span class="string">"content"</span>, newResult);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁用缓存</span></span><br><span class="line">        response.setHeader(<span class="string">"Pragma"</span>, <span class="string">"no-cache"</span>);</span><br><span class="line">        response.setDateHeader(<span class="string">"Expires"</span>, <span class="number">0</span>);</span><br><span class="line">        response.setHeader(<span class="string">"Cache-Control"</span>, <span class="string">"no-cache,no-store"</span>);</span><br><span class="line">        response.setStatus(HttpServletResponse.SC_OK);</span><br><span class="line">        <span class="keyword">return</span> HttpServletResponse.SC_OK + <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="longPollingService-addLongPollingClient"><a href="#longPollingService-addLongPollingClient" class="headerlink" title="longPollingService.addLongPollingClient"></a>longPollingService.addLongPollingClient</h2><p>从方法名字上可以推测出，这个方法应该是把客户端的长轮训请求添加到某个任务中去。</p>
<ul>
<li>获得客户端传递过来的超时时间，并且进行本地计算，提前500ms返回响应，这就能解释为什么客户端响应超时时间是29.5+了。当然如果<code>isFixedPolling=true</code>的情况下，不会提前返回响应</li>
<li>根据客户端请求过来的md5和服务器端对应的group下对应内容的md5进行比较，如果不一致，则通过<code>generateResponse</code>将结果返回</li>
<li>如果配置文件没有发生变化，则通过<code>scheduler.execute</code> 启动了一个定时任务，将客户端的长轮询请求封装成一个叫 ClientLongPolling 的任务，交给 scheduler 去执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLongPollingClient</span><span class="params">(HttpServletRequest req, HttpServletResponse rsp, Map&lt;String, String&gt; clientMd5Map,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">int</span> probeRequestSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//str表示超时时间，也就是timeout</span></span><br><span class="line">        String str = req.getHeader(LongPollingService.LONG_POLLING_HEADER);</span><br><span class="line">        String noHangUpFlag = req.getHeader(LongPollingService.LONG_POLLING_NO_HANG_UP_HEADER);</span><br><span class="line">        String appName = req.getHeader(RequestUtil.CLIENT_APPNAME_HEADER);</span><br><span class="line">        String tag = req.getHeader(<span class="string">"Vipserver-Tag"</span>);</span><br><span class="line">        <span class="keyword">int</span> delayTime = SwitchService.getSwitchInteger(SwitchService.FIXED_DELAY_TIME, <span class="number">500</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 提前500ms返回响应，为避免客户端超时 <span class="doctag">@qiaoyi</span>.dingqy 2013.10.22改动  add delay time for LoadBalance</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">long</span> timeout = Math.max(<span class="number">10000</span>, Long.parseLong(str) - delayTime);</span><br><span class="line">        <span class="keyword">if</span> (isFixedPolling()) &#123;</span><br><span class="line">            timeout = Math.max(<span class="number">10000</span>, getFixedPollingInterval());</span><br><span class="line">            <span class="comment">// do nothing but set fix polling timeout</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            List&lt;String&gt; changedGroups = MD5Util.compareMd5(req, rsp, clientMd5Map);</span><br><span class="line">            <span class="keyword">if</span> (changedGroups.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                generateResponse(req, rsp, changedGroups);</span><br><span class="line">                LogUtil.clientLog.info(<span class="string">"&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;"</span>,</span><br><span class="line">                    System.currentTimeMillis() - start, <span class="string">"instant"</span>, RequestUtil.getRemoteIp(req), <span class="string">"polling"</span>,</span><br><span class="line">                    clientMd5Map.size(), probeRequestSize, changedGroups.size());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (noHangUpFlag != <span class="keyword">null</span> &amp;&amp; noHangUpFlag.equalsIgnoreCase(TRUE_STR)) &#123;</span><br><span class="line">                LogUtil.clientLog.info(<span class="string">"&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;"</span>, System.currentTimeMillis() - start, <span class="string">"nohangup"</span>,</span><br><span class="line">                    RequestUtil.getRemoteIp(req), <span class="string">"polling"</span>, clientMd5Map.size(), probeRequestSize,</span><br><span class="line">                    changedGroups.size());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String ip = RequestUtil.getRemoteIp(req);</span><br><span class="line">        <span class="comment">// 一定要由HTTP线程调用，否则离开后容器会立即发送响应</span></span><br><span class="line">        <span class="keyword">final</span> AsyncContext asyncContext = req.startAsync();</span><br><span class="line">        <span class="comment">// AsyncContext.setTimeout()的超时时间不准，所以只能自己控制</span></span><br><span class="line">        asyncContext.setTimeout(<span class="number">0L</span>);</span><br><span class="line"></span><br><span class="line">        scheduler.execute(</span><br><span class="line">            <span class="keyword">new</span> ClientLongPolling(asyncContext, clientMd5Map, ip, probeRequestSize, timeout, appName, tag));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ClientLongPolling"><a href="#ClientLongPolling" class="headerlink" title="ClientLongPolling"></a>ClientLongPolling</h2><p>接下来我们来分析一下，clientLongPolling到底做了什么操作。或者说我们可以先猜测一下应该会做什么事情</p>
<ul>
<li>这个任务要阻塞29.5s才能执行，因为立马执行没有任何意义，毕竟前面已经执行过一次了</li>
<li>如果在29.5s+之内，数据发生变化，需要提前通知。需要有一种监控机制</li>
</ul>
<p>基于这些猜想，我们可以看看它的实现过程</p>
<p>从代码粗粒度来看，它的实现似乎和我们的猜想一致，在run方法中，通过scheduler.schedule实现了一个定时任务，它的delay时间正好是前面计算的29.5s。在这个任务中，会通过MD5Util.compareMd5来进行计算</p>
<p>那另外一个，当数据发生变化以后，肯定不能等到29.5s之后才通知呀，那怎么办呢？我们发现有一个<code>allSubs</code>的东西，它似乎和发布订阅有关系。那是不是有可能当前的clientLongPolling订阅了数据变化的事件呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    asyncTimeoutFuture = scheduler.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                getRetainIps().put(ClientLongPolling.<span class="keyword">this</span>.ip, System.currentTimeMil·<span class="number">1</span>·s());</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 删除订阅关系</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                allSubs.remove(ClientLongPolling.<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isFixedPolling()) &#123;</span><br><span class="line">                    LogUtil.clientLog.info(<span class="string">"&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;"</span>,</span><br><span class="line">                                           (System.currentTimeMillis() - createTime),</span><br><span class="line">                                           <span class="string">"fix"</span>, RequestUtil.getRemoteIp((HttpServletRequest)asyncContext.getRequest()),</span><br><span class="line">                                           <span class="string">"polling"</span>,</span><br><span class="line">                                           clientMd5Map.size(), probeRequestSize);</span><br><span class="line">                    List&lt;String&gt; changedGroups = MD5Util.compareMd5(</span><br><span class="line">                        (HttpServletRequest)asyncContext.getRequest(),</span><br><span class="line">                        (HttpServletResponse)asyncContext.getResponse(), clientMd5Map);</span><br><span class="line">                    <span class="keyword">if</span> (changedGroups.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        sendResponse(changedGroups);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        sendResponse(<span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    LogUtil.clientLog.info(<span class="string">"&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;"</span>,</span><br><span class="line">                                           (System.currentTimeMillis() - createTime),</span><br><span class="line">                                           <span class="string">"timeout"</span>, RequestUtil.getRemoteIp((HttpServletRequest)asyncContext.getRequest()),</span><br><span class="line">                                           <span class="string">"polling"</span>,</span><br><span class="line">                                           clientMd5Map.size(), probeRequestSize);</span><br><span class="line">                    sendResponse(<span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                LogUtil.defaultLog.error(<span class="string">"long polling error:"</span> + t.getMessage(), t.getCause());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;, timeoutTime, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    allSubs.add(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="allSubs"><a href="#allSubs" class="headerlink" title="allSubs"></a>allSubs</h2><p>allSubs是一个队列，队列里面放了ClientLongPolling这个对象。这个队列似乎和配置变更有某种关联关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 长轮询订阅关系</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Queue&lt;ClientLongPolling&gt; allSubs;</span><br><span class="line"></span><br><span class="line">allSubs.add(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<p>那这个时候，我的第一想法是，先去看一下当前这个类的类图，发现LongPollingService集成了AbstractEventListener，事件监听？果然没猜错。</p>
<p><img src="/images/1564902541390.png" alt="1564902541390"></p>
<h2 id="AbstractEventListener"><a href="#AbstractEventListener" class="headerlink" title="AbstractEventListener"></a>AbstractEventListener</h2><p>这里面有一个抽象的onEvent方法，明显是用来处理事件的方法，而抽象方法必须由子类实现，所以意味着LongPollingService里面肯定实现了onEvent方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractEventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AbstractEventListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * automatic register</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            EventDispatcher.addEventListener(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 感兴趣的事件列表</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> event list</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">abstract</span> <span class="keyword">public</span> List&lt;Class&lt;? extends Event&gt;&gt; interest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 处理事件</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> event event</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event event)</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="LongPollingService-onEvent"><a href="#LongPollingService-onEvent" class="headerlink" title="LongPollingService.onEvent"></a>LongPollingService.onEvent</h2><p>这个事件的实现方法中</p>
<ul>
<li>判断事件类型是否为LocalDataChangeEvent</li>
<li>通过scheduler.execute执行DataChangeTask这个任务</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFixedPolling()) &#123;</span><br><span class="line">            <span class="comment">// ignore</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (event <span class="keyword">instanceof</span> LocalDataChangeEvent) &#123;</span><br><span class="line">                LocalDataChangeEvent evt = (LocalDataChangeEvent)event;</span><br><span class="line">                scheduler.execute(<span class="keyword">new</span> DataChangeTask(evt.groupKey, evt.isBeta, evt.betaIps));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="DataChangeTask-run"><a href="#DataChangeTask-run" class="headerlink" title="DataChangeTask.run"></a>DataChangeTask.run</h2><p>从名字可以看出来，这个是数据变化的任务，最让人兴奋的应该是，它里面有一个循环迭代器，从allSubs里面获得ClientLongPolling</p>
<p>最后通过clientSub.sendResponse把数据返回到客户端。所以，这也就能够理解为何数据变化能够实时触发更新了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ConfigService.getContentBetaMd5(groupKey);</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;ClientLongPolling&gt; iter = allSubs.iterator(); iter.hasNext(); ) &#123;</span><br><span class="line">            ClientLongPolling clientSub = iter.next();</span><br><span class="line">            <span class="keyword">if</span> (clientSub.clientMd5Map.containsKey(groupKey)) &#123;</span><br><span class="line">                <span class="comment">// 如果beta发布且不在beta列表直接跳过</span></span><br><span class="line">                <span class="keyword">if</span> (isBeta &amp;&amp; !betaIps.contains(clientSub.ip)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果tag发布且不在tag列表直接跳过</span></span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isNotBlank(tag) &amp;&amp; !tag.equals(clientSub.tag)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                getRetainIps().put(clientSub.ip, System.currentTimeMillis());</span><br><span class="line">                iter.remove(); <span class="comment">// 删除订阅关系</span></span><br><span class="line">                LogUtil.clientLog.info(<span class="string">"&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;"</span>,</span><br><span class="line">                                       (System.currentTimeMillis() - changeTime),</span><br><span class="line">                                       <span class="string">"in-advance"</span>,</span><br><span class="line">                                       RequestUtil.getRemoteIp((HttpServletRequest)clientSub.asyncContext.getRequest()),</span><br><span class="line">                                       <span class="string">"polling"</span>,</span><br><span class="line">                                       clientSub.clientMd5Map.size(), clientSub.probeRequestSize, groupKey);</span><br><span class="line">                clientSub.sendResponse(Arrays.asList(groupKey));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        LogUtil.defaultLog.error(<span class="string">"data change error:"</span> + t.getMessage(), t.getCause());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么接下来还有一个疑问是，数据变化之后是如何触发事件的呢？ 所以我们定位到数据变化的请求类中，在ConfigController这个类中，找到POST请求的方法</p>
<p>找到配置变更的位置， 发现数据持久化之后，会通过EventDispatcher进行事件发布<code>EventDispatcher.fireEvent</code> 但是这个事件似乎不是我们所关心的时间，原因是这里发布的事件是<code>ConfigDataChangeEvent</code>, 而LongPollingService感兴趣的事件是<code>LocalDataChangeEvent</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(method = RequestMethod.POST)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">publishConfig</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        <span class="comment">//省略部分代码</span></span><br><span class="line">        ConfigInfo configInfo = <span class="keyword">new</span> ConfigInfo(dataId, group, tenant, appName, content);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(betaIps)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(tag)) &#123;</span><br><span class="line">                persistService.insertOrUpdate(srcIp, srcUser, configInfo, time, configAdvanceInfo, <span class="keyword">false</span>);</span><br><span class="line">                EventDispatcher.fireEvent(<span class="keyword">new</span> ConfigDataChangeEvent(<span class="keyword">false</span>, dataId, group, tenant, time.getTime()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                persistService.insertOrUpdateTag(configInfo, tag, srcIp, srcUser, time, <span class="keyword">false</span>);</span><br><span class="line">                EventDispatcher.fireEvent(<span class="keyword">new</span> ConfigDataChangeEvent(<span class="keyword">false</span>, dataId, group, tenant, tag, time.getTime()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// beta publish</span></span><br><span class="line">            persistService.insertOrUpdateBeta(configInfo, betaIps, srcIp, srcUser, time, <span class="keyword">false</span>);</span><br><span class="line">            EventDispatcher.fireEvent(<span class="keyword">new</span> ConfigDataChangeEvent(<span class="keyword">true</span>, dataId, group, tenant, time.getTime()));</span><br><span class="line">        &#125;</span><br><span class="line">        ConfigTraceService.logPersistenceEvent(dataId, group, tenant, requestIpApp, time.getTime(),</span><br><span class="line">            LOCAL_IP, ConfigTraceService.PERSISTENCE_EVENT_PUB, content);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>后来我发现，在Nacos中有一个DumpService，它会定时把变更后的数据dump到磁盘上，DumpService在spring启动之后，会调用init方法启动几个dump任务。然后在任务执行结束之后，会触发一个LocalDataChangeEvent 的事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LogUtil.defaultLog.warn(<span class="string">"DumpService start"</span>);</span><br><span class="line">        DumpProcessor processor = <span class="keyword">new</span> DumpProcessor(<span class="keyword">this</span>);</span><br><span class="line">        DumpAllProcessor dumpAllProcessor = <span class="keyword">new</span> DumpAllProcessor(<span class="keyword">this</span>);</span><br><span class="line">        DumpAllBetaProcessor dumpAllBetaProcessor = <span class="keyword">new</span> DumpAllBetaProcessor(<span class="keyword">this</span>);</span><br><span class="line">        DumpAllTagProcessor dumpAllTagProcessor = <span class="keyword">new</span> DumpAllTagProcessor(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>简单总结一下刚刚分析的整个过程。</p>
<ul>
<li>客户端发起长轮训请求</li>
<li>服务端收到请求以后，先比较服务端缓存中的数据是否相同，如果不通，则直接返回</li>
<li>如果相同，则通过schedule延迟29.5s之后再执行比较</li>
<li>为了保证当服务端在29.5s之内发生数据变化能够及时通知给客户端，服务端采用事件订阅的方式来监听服务端本地数据变化的事件，一旦收到事件，则触发DataChangeTask的通知，并且遍历allStubs队列中的ClientLongPolling,把结果写回到客户端，就完成了一次数据的推送</li>
<li>如果 DataChangeTask 任务完成了数据的 “推送” 之后，ClientLongPolling 中的调度任务又开始执行了怎么办呢？<br>很简单，只要在进行 “推送” 操作之前，先将原来等待执行的调度任务取消掉就可以了，这样就防止了推送操作写完响应数据之后，调度任务又去写响应数据，这时肯定会报错的。所以，在ClientLongPolling方法中，最开始的一个步骤就是删除订阅事件</li>
</ul>
<p>所以总的来说，Nacos采用推+拉的形式，来解决最开始关于长轮训时间间隔的问题。当然，30s这个时间是可以设置的，而之所以定30s，应该是一个经验值。</p>
<h1 id="集群选举问题"><a href="#集群选举问题" class="headerlink" title="集群选举问题"></a>集群选举问题</h1><p>Nacos支持集群模式，很显然。 </p>
<p>而一旦涉及到集群，就涉及到主从，那么nacos是一种什么样的机制来实现的集群呢？</p>
<p>nacos的集群类似于zookeeper， 它分为leader角色和follower角色， 那么从这个角色的名字可以看出来，这个集群存在选举的机制。 因为如果自己不具备选举功能，角色的命名可能就是master/slave了，当然这只是我基于这么多组件的命名的一个猜测</p>
<h2 id="选举算法"><a href="#选举算法" class="headerlink" title="选举算法"></a>选举算法</h2><p>Nacos集群采用raft算法来实现，它是相对zookeeper的选举算法较为简单的一种。 </p>
<p>选举算法的核心在<code>RaftCore</code>  中，包括数据的处理和数据同步</p>
<p><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">raft算法演示地址</a></p>
<p>在Raft中，节点有三种角色：</p>
<ul>
<li>Leader：负责接收客户端的请求</li>
<li>Candidate：用于选举Leader的一种角色</li>
<li>Follower：负责响应来自Leader或者Candidate的请求</li>
</ul>
<p>选举分为两个节点</p>
<ul>
<li>服务启动的时候</li>
<li>leader挂了的时候</li>
</ul>
<p>所有节点启动的时候，都是follower状态。 如果在一段时间内如果没有收到leader的心跳（可能是没有leader，也可能是leader挂了），那么follower会变成Candidate。然后发起选举，选举之前，会增加term，这个term和zookeeper中的epoch的道理是一样的。</p>
<ul>
<li>follower会投自己一票，并且给其他节点发送票据vote，等到其他节点回复</li>
<li>在这个过程中，可能出现几种情况<ul>
<li>收到过半的票数通过，则成为leader</li>
<li>被告知其他节点已经成为leader，则自己切换为follower</li>
<li>一段时间内没有收到过半的投票，则重新发起选举</li>
</ul>
</li>
<li><strong>约束条件在任一term中，单个节点最多只能投一票</strong></li>
</ul>
<p>选举的几种情况</p>
<ul>
<li>第一种情况，赢得选举之后，leader会给所有节点发送消息，避免其他节点触发新的选举</li>
<li>第二种情况，比如有三个节点A B C。A B同时发起选举，而A的选举消息先到达C，C给A投了一票，当B的消息到达C时，已经不能满足上面提到的第一个约束，即C不会给B投票，而A和B显然都不会给对方投票。A胜出之后，会给B,C发心跳消息，节点B发现节点A的term不低于自己的term，知道有已经有Leader了，于是转换成follower</li>
<li>第三种情况， 没有任何节点获得majority投票，可能是平票的情况。加入总共有四个节点（A/B/C/D），Node C、Node D同时成为了candidate，但Node A投了NodeD一票，NodeB投了Node C一票，这就出现了平票 split vote的情况。这个时候大家都在等啊等，直到超时后重新发起选举。如果出现平票的情况，那么就延长了系统不可用的时间,因此raft引入了randomized election timeouts来尽量避免平票情况</li>
</ul>
<h2 id="数据的处理"><a href="#数据的处理" class="headerlink" title="数据的处理"></a>数据的处理</h2><p>对于事务操作，请求会转发给leader</p>
<p>非事务操作上，可以任意一个节点来处理</p>
<p>下面这段代码摘自 RaftCore ， 在发布内容的时候，做了两个事情</p>
<ul>
<li>如果当前的节点不是leader，则转发给leader节点处理</li>
<li>如果是，则向所有节点发送onPublish</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signalPublish</span><span class="params">(String key, Record value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isLeader()) &#123;</span><br><span class="line">            JSONObject params = <span class="keyword">new</span> JSONObject();</span><br><span class="line">            params.put(<span class="string">"key"</span>, key);</span><br><span class="line">            params.put(<span class="string">"value"</span>, value);</span><br><span class="line">            Map&lt;String, String&gt; parameters = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">            parameters.put(<span class="string">"key"</span>, key);</span><br><span class="line"></span><br><span class="line">            raftProxy.proxyPostLarge(getLeader().ip, API_PUB, params.toJSONString(), parameters);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            OPERATE_LOCK.lock();</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">final</span> Datum datum = <span class="keyword">new</span> Datum();</span><br><span class="line">            datum.key = key;</span><br><span class="line">            datum.value = value;</span><br><span class="line">            <span class="keyword">if</span> (getDatum(key) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                datum.timestamp.set(<span class="number">1L</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                datum.timestamp.set(getDatum(key).timestamp.incrementAndGet());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            JSONObject json = <span class="keyword">new</span> JSONObject();</span><br><span class="line">            json.put(<span class="string">"datum"</span>, datum);</span><br><span class="line">            json.put(<span class="string">"source"</span>, peers.local());</span><br><span class="line"></span><br><span class="line">            onPublish(datum, peers.local());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> String content = JSON.toJSONString(json);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(peers.majorityCount());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">final</span> String server : peers.allServersIncludeMyself()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isLeader(server)) &#123;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">final</span> String url = buildURL(server, API_ON_PUB);</span><br><span class="line">                HttpClient.asyncHttpPostLarge(url, Arrays.asList(<span class="string">"key="</span> + key), content, <span class="keyword">new</span> AsyncCompletionHandler&lt;Integer&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Integer <span class="title">onCompleted</span><span class="params">(Response response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (response.getStatusCode() != HttpURLConnection.HTTP_OK) &#123;</span><br><span class="line">                            Loggers.RAFT.warn(<span class="string">"[RAFT] failed to publish data to peer, datumId=&#123;&#125;, peer=&#123;&#125;, http code=&#123;&#125;"</span>,</span><br><span class="line">                                datum.key, server, response.getStatusCode());</span><br><span class="line">                            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        latch.countDown();</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> STATE <span class="title">onContentWriteCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> STATE.CONTINUE;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!latch.await(UtilsAndCommons.RAFT_PUBLISH_TIMEOUT, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                <span class="comment">// only majority servers return success can we consider this update success</span></span><br><span class="line">                Loggers.RAFT.error(<span class="string">"data publish failed, caused failed to notify majority, key=&#123;&#125;"</span>, key);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"data publish failed, caused failed to notify majority, key="</span> + key);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">            Loggers.RAFT.info(<span class="string">"signalPublish cost &#123;&#125; ms, key: &#123;&#125;"</span>, (end - start), key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            OPERATE_LOCK.unlock();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>#</p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#Nacos" >
    <span class="tag-code">Nacos</span>
  </a>

  <a href="/tags#源码分析" >
    <span class="tag-code">源码分析</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    <div class="qrcode">
      <canvas id="share-qrcode"></canvas>
      <p class="notice">扫描二维码，分享此文章</p>
    </div>
    <!-- 二维码 END -->
    
      <!-- Gitment START -->
      <div id="comments"></div>
      <!-- Gitment END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">目录</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#长轮训的概念"><span class="toc-nav-text">长轮训的概念</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#客户端长轮训"><span class="toc-nav-text">客户端长轮训</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#客户端长轮训的时间间隔"><span class="toc-nav-text">客户端长轮训的时间间隔</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#服务端的处理"><span class="toc-nav-text">服务端的处理</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#ConfigController"><span class="toc-nav-text">ConfigController</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#doPollingConfig"><span class="toc-nav-text">doPollingConfig</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#longPollingService-addLongPollingClient"><span class="toc-nav-text">longPollingService.addLongPollingClient</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#ClientLongPolling"><span class="toc-nav-text">ClientLongPolling</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#allSubs"><span class="toc-nav-text">allSubs</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#AbstractEventListener"><span class="toc-nav-text">AbstractEventListener</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#LongPollingService-onEvent"><span class="toc-nav-text">LongPollingService.onEvent</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#DataChangeTask-run"><span class="toc-nav-text">DataChangeTask.run</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#简单总结"><span class="toc-nav-text">简单总结</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#集群选举问题"><span class="toc-nav-text">集群选举问题</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#选举算法"><span class="toc-nav-text">选举算法</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#数据的处理"><span class="toc-nav-text">数据的处理</span></a></li></ol>
    
  </div>
</aside>

  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://istio.tech/2019/08/05/Alibaba-Nacos配置中心服务端处理源码/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "2227324689";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "Alibaba Nacos配置中心服务端处理源码",
        owner: "2227324689",
        repo: "discus",
        oauth: {
          client_id: "9f7383daf559285bdfbd",
          client_secret: "b459e4b2189adbd2fd9fbc28443cd29fc4b44dbc"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2020 | Proudly powered by <a href="https://www.gupaoedu.cn" target="_blank">GuPaoEdu</a>
    <br>
    Blog by <a href="https://github.com/2227324689">Mic</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine == 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>

  </body>
</html>